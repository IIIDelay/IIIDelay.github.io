import{_ as a,W as e,X as i,a1 as n}from"./framework-b5ea9e64.js";const r="/assets/image-20230328141517507-e27d0677.png",l="/assets/image-20230328143326619-3618a918.png",t="/assets/image-20230328143502439-d2e61bd0.png",o="/assets/image-20230328144120247-e78c10a3.png",h={},c=n('<h1 id="w" tabindex="-1"><a class="header-anchor" href="#w" aria-hidden="true">#</a> w</h1><h1 id="synchronized相关问题" tabindex="-1"><a class="header-anchor" href="#synchronized相关问题" aria-hidden="true">#</a> Synchronized相关问题</h1><h4 id="_1-synchronized用过吗-其原理是什么" tabindex="-1"><a class="header-anchor" href="#_1-synchronized用过吗-其原理是什么" aria-hidden="true">#</a> 1. Synchronized用过吗？其原理是什么</h4><h4 id="_2-获取对象的锁-这个锁到底是什么-如何确定对象的锁" tabindex="-1"><a class="header-anchor" href="#_2-获取对象的锁-这个锁到底是什么-如何确定对象的锁" aria-hidden="true">#</a> 2. 获取对象的锁，这个锁到底是什么？如何确定对象的锁？</h4><h4 id="_3-jvm对java的原生锁做了哪些优化" tabindex="-1"><a class="header-anchor" href="#_3-jvm对java的原生锁做了哪些优化" aria-hidden="true">#</a> 3. JVM对java的原生锁做了哪些优化?</h4><h4 id="_4-什么是可重入性-为什么sysnchronized是可重入锁" tabindex="-1"><a class="header-anchor" href="#_4-什么是可重入性-为什么sysnchronized是可重入锁" aria-hidden="true">#</a> 4. 什么是可重入性，为什么sysnchronized是可重入锁？</h4><blockquote><p><strong>可重入锁</strong>：</p><ul><li>又名 递归锁: 指在同一个线程的外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁(前提，锁对象是同一个对象)，不会因为之前已经获取过还没有释放而阻塞</li><li>Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。</li></ul><p>小结：一个线程中的多个流程可以获取同一把锁，持有这把同步锁可以再次进入。自己可以获取自己的内部锁</p></blockquote><blockquote><p>可重入锁种类:</p><ul><li>隐式锁(synchronized关键字使用的锁)默认是可重入锁 <ul><li>可重入锁：可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁，这样的锁叫做可重入锁</li><li>在一个synchronized修饰的方法或者代码块内部，调用本类的其他synchronized修饰的方法或者代码时，是永远可以得到锁的</li></ul></li><li>synchronized的重入实现机理: <ul><li>每个锁对象都拥有一个锁计数器和一个指向持有该锁线程的指针 <ul><li>当执行monitorenter时，如果目标对象的计数器为0，那么说明没有被其他线程所持有，Java虚拟机会将该锁对象持有线程设置为当前线程，并且将计数器累加i。在目标锁对象的计数器不为零的情况下，如果锁对象的持有线程时当前线程，那么Java虚拟机可以将其计数器加1，否则需要等待，直至持有线程释放该锁，当执行monitorexit时，Java虚拟机则将锁对象的计数器减1。计数器为0代表锁已经被释放。</li></ul></li></ul></li><li>显示锁(Lock)中reentrantlock也是可重入锁</li></ul></blockquote><h4 id="_5-为什么说sysnchronized是非公平锁" tabindex="-1"><a class="header-anchor" href="#_5-为什么说sysnchronized是非公平锁" aria-hidden="true">#</a> 5. 为什么说sysnchronized是非公平锁</h4><h4 id="_6-什么是锁消除和锁粗化" tabindex="-1"><a class="header-anchor" href="#_6-什么是锁消除和锁粗化" aria-hidden="true">#</a> 6. 什么是锁消除和锁粗化？</h4><h4 id="_7-为什么说sysnchronized是悲观锁-乐观锁的实现原理是什么-什么是cas" tabindex="-1"><a class="header-anchor" href="#_7-为什么说sysnchronized是悲观锁-乐观锁的实现原理是什么-什么是cas" aria-hidden="true">#</a> 7. 为什么说sysnchronized是悲观锁？乐观锁的实现原理是什么？什么是CAS?</h4><h4 id="_8-乐观锁一定是好的吗" tabindex="-1"><a class="header-anchor" href="#_8-乐观锁一定是好的吗" aria-hidden="true">#</a> 8. 乐观锁一定是好的吗？</h4><h1 id="可重入锁reentrantlock及其他显式锁相关问题" tabindex="-1"><a class="header-anchor" href="#可重入锁reentrantlock及其他显式锁相关问题" aria-hidden="true">#</a> 可重入锁ReentrantLock及其他显式锁相关问题</h1><h4 id="_1-根sysnchronized相比-可重入锁reentrantlock其实现原理有什么不同" tabindex="-1"><a class="header-anchor" href="#_1-根sysnchronized相比-可重入锁reentrantlock其实现原理有什么不同" aria-hidden="true">#</a> 1. 根sysnchronized相比，可重入锁reentrantLock其实现原理有什么不同？</h4><h4 id="_2-请谈" tabindex="-1"><a class="header-anchor" href="#_2-请谈" aria-hidden="true">#</a> 2. 请谈</h4><h4 id="谈aqs框架是怎么回事" tabindex="-1"><a class="header-anchor" href="#谈aqs框架是怎么回事" aria-hidden="true">#</a> 谈AQS框架是怎么回事？</h4><blockquote><p>AbstractQueuedSynchronizer之AQS</p><ul><li><p>字面意思:</p><ul><li>抽象的队列同步器</li><li>在Java Util concurrent locks包下</li></ul></li><li><p>技术翻译:</p><ul><li>是用来构建锁或者其他同步器组件的重量级基础框架及整合juc体系的基石，通过内置的<strong>FIFO队列</strong>来完成资源获取线程的排队工作，并通过一个int类变量表示持有锁的状态</li></ul><figure><img src="'+r+'" alt="image-20230328141517507" tabindex="0" loading="lazy"><figcaption>image-20230328141517507</figcaption></figure></li></ul></blockquote><blockquote><p>AQS为什么是JUC内容中最重要的基石？</p><ul><li></li><li>进一步理解锁和同步器的关系 <ul><li>锁：面向锁的<u>使用者</u><ul><li>定义了程序员和锁交互的使用层API，隐藏了实现细节，你低调用即可</li></ul></li><li>同步器: 面向锁的<u>实现者</u><ul><li>比如Java并发大神Douglee，提出统一规范并简化锁的实现，屏蔽了同步状态管理、阻塞线程排队和通知、唤醒机制等</li></ul></li></ul></li></ul></blockquote><blockquote><p>AQS能干什么？</p><ul><li><p>加锁会导致阻塞</p><ul><li>有阻塞就需要排队，实现排队必然需要有某种形式的队列来管理</li></ul></li><li><p>解释说明:</p><ul><li><p>抢到资源的线程直接使用办理业务，抢占不到资源的线程必然涉及一种<u>排队等候机制</u>，抢占资源失败的线程继续去等待，仍然保留获取锁的可能且获取锁的流程仍在继续</p></li><li><p>排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？</p><ul><li>如果共享资源被占用，就需要一定的阻塞等待唤醒机制保证锁分配。这个机制就是用CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中，这个队列就是AQS的抽象表现。它将请求共享资源的线程封装成队列的节点(Node),通过CAS、自旋以及LockSuport.park()方式，维护state变量的状态，使得并发达到同步的效果</li></ul><figure><img src="'+l+'" alt="image-20230328143326619" tabindex="0" loading="lazy"><figcaption>image-20230328143326619</figcaption></figure></li></ul></li></ul></blockquote><blockquote><p>AQS初步</p><ul><li><p>AQS初识</p><ul><li>官网解释:</li></ul><figure><img src="'+t+'" alt="image-20230328143502439" tabindex="0" loading="lazy"><figcaption>image-20230328143502439</figcaption></figure><ul><li>有阻塞就需要有排队，实现排队必然需要队列</li></ul></li><li><p>AQS内部体系架构</p><ul><li><img src="'+o+'" alt="image-20230328144120247" tabindex="0" loading="lazy"><figcaption>image-20230328144120247</figcaption></li><li></li></ul></li></ul></blockquote><h4 id="_3-请尽可能详细对比下synchronized与reentrantlock的异同" tabindex="-1"><a class="header-anchor" href="#_3-请尽可能详细对比下synchronized与reentrantlock的异同" aria-hidden="true">#</a> 3. 请尽可能详细对比下synchronized与reentrantLock的异同</h4><h4 id="_4-reentrantlock是如何实现可重入性的" tabindex="-1"><a class="header-anchor" href="#_4-reentrantlock是如何实现可重入性的" aria-hidden="true">#</a> 4. ReentrantLock是如何实现可重入性的？</h4><h1 id="aqs" tabindex="-1"><a class="header-anchor" href="#aqs" aria-hidden="true">#</a> AQS</h1><blockquote><p>队列同步器AbstractQueuedSynchronizer，是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。</p><p><strong>同步器的主要使用方式</strong>：继承，子类通过继承同步器并实现它的抽象方法来管理同步状态，它<strong>独占式</strong>和<strong>共享式</strong>两种方式获取同步状态，多线程并发情况下通过CAS的方式修改同步状态。</p><p>同步器的设计基于<strong>模板方法模式</strong>：</p><ol><li>继承同步器并重写指定的方法</li><li>将同步器组合在自定义同步组件的实现中</li><li>调用同步器提供的模板方法</li><li>模板方法将会调用使用者重写的方法</li></ol></blockquote><h1 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a></h1>',25),d=[c];function s(u,p){return e(),i("div",null,d)}const _=a(h,[["render",s],["__file","juc.html.vue"]]);export{_ as default};
