import{_ as n,W as a,X as s,a1 as e}from"./framework-b5ea9e64.js";const t="/assets/image-20230410145414581-072424ad.png",o="/assets/image-20230410150905638-2a32548e.png",i="/assets/image-20230410151029260-21331d53.png",l="/assets/image-20230410153953458-e97db014.png",c="/assets/image-20230410161633094-bf6e8bfe.png",p="/assets/image-20230410162755052-f0a6d34f.png",u="/assets/image-20230410170138619-5c7f5b7b.png",r="/assets/image-20230328141517507-e27d0677.png",d="/assets/image-20230328143326619-3618a918.png",k="/assets/image-20230328143502439-d2e61bd0.png",h="/assets/image-20230328144120247-e78c10a3.png",m={},b=e(`<h1 id="java-current-util" tabindex="-1"><a class="header-anchor" href="#java-current-util" aria-hidden="true">#</a> Java Current Util</h1><h2 id="锁" tabindex="-1"><a class="header-anchor" href="#锁" aria-hidden="true">#</a> 锁</h2><h4 id="_1-悲观锁" tabindex="-1"><a class="header-anchor" href="#_1-悲观锁" aria-hidden="true">#</a> 1. 悲观锁</h4><blockquote><p>适合写操作多的场景, 先加锁可以保证写操作时数据正确</p><ul><li>显示的锁定之后再操作同步资源</li></ul><p>通俗讲: 认为自己在使用数据的时候一定有别的线程来修改数据, 因此再获取数据的时候会先加锁, 确保数据不会被别的线程修改</p><ul><li>synchronized关键字和Lock的实现类都是悲观锁</li></ul></blockquote><ul><li>悲观锁</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">m1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 加锁后的业务逻辑......</span>
<span class="token punctuation">}</span>

<span class="token comment">// 保证多个线程使用的是同一个lock对象的前提下</span>
<span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">m2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// 操作同步资源</span>
    <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>乐观锁</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 保证多个线程使用的是同一个AtomicInteger</span>
<span class="token keyword">private</span> <span class="token class-name">AtomicInteger</span> atomicInteger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
atomicInteger<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-乐观锁" tabindex="-1"><a class="header-anchor" href="#_2-乐观锁" aria-hidden="true">#</a> 2. 乐观锁</h4><blockquote><p>适合读多写少的场景, 不加锁的特点能够使其读操作的性能大幅提升</p><p>乐观锁是直接去操作同步资源, 是一种无锁算法, 得不到锁就一直抢</p></blockquote><blockquote><p>乐观锁一般有两种实现方式:</p><ul><li>采用版本号机制</li><li>CAS(Compare-and-Swap, 即比较并替换)算法实现</li></ul><p>通俗讲:</p><ul><li>乐观锁认为自己在使用数据时不会有别的线程修改数据, 所以不会添加锁, 只是在更新数据的时候去判断之前有没有别的线程更新了这个数据</li><li>如果这个数据没有被更新, 当前线程自己修改的数据成功写入. 如果数据已经被别的线程更新, 则根据不同的实现方式执行不同的操作</li><li>乐观锁在Java中是通过使用无锁编程来实现的, 最常用的是CAS算法, Java原子类中的递增操作就是通过CAS自旋实现的.</li></ul></blockquote><h4 id="_3-synchronized" tabindex="-1"><a class="header-anchor" href="#_3-synchronized" aria-hidden="true">#</a> 3. synchronized</h4><blockquote><p>8种锁的案例实际体验在三个地方:</p><ul><li>作用于实例方法, 当前实例加锁, 进入同步代码前要获得当前实例的锁</li><li>作用于代码块, 对括号里配置的对象加锁</li><li>作用于静态方法, 当前类加锁, 进去同步代码块前要获得当前对象的锁</li></ul></blockquote><h5 id="字节码角度分析synchronized" tabindex="-1"><a class="header-anchor" href="#字节码角度分析synchronized" aria-hidden="true">#</a> 字节码角度分析synchronized</h5><ul><li>javap -c xxx.class文件反编译| -v 信息更多</li></ul><img src="`+t+'" alt="image-20230410145414581" style="zoom:67%;"><blockquote><p>synchronized同步代码块: 实现使用的是monitorenter和monitorexit指令</p><ul><li>保证异常也能正常释放锁</li></ul></blockquote><ul><li>普通同步方法反编译</li></ul><img src="'+o+'" alt="image-20230410150905638" style="zoom:67%;"><blockquote><p>调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置。 如果设置了，执行线程会将先持有monitor然后再执行方法， 最后在方法完成(无论是正常完成还是非正常完成)时释放 monitor</p></blockquote><ul><li>静态同步方法反编译</li></ul><img src="'+i+'" alt="image-20230410151029260" style="zoom:67%;"><blockquote><p><code>ACC_STATIC</code>, <code>ACC_SYNCHRONIZED</code>访问标志区分该方法是否静态同步方法</p></blockquote><h5 id="反编译synchronized锁是什么" tabindex="-1"><a class="header-anchor" href="#反编译synchronized锁是什么" aria-hidden="true">#</a> 反编译synchronized锁是什么</h5><blockquote><p>锁: 管程monitor</p></blockquote><blockquote><p>管程(Monitors, 也称为监视器): 是一种程序结构, 结构内多个子程序(对象或者模块)形成的多个工作线程互斥访问共享资源</p></blockquote><blockquote><p>同步指令: Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步, 这两种同步结构都是(Monitor, 更常见的称为&#39;锁&#39;)来实现的</p><p>执行线程: 就是要求成功持有管程, 然后才能执行方法, 最后当方法完成(无论是正常完成还是异常)时释放管程. 在方法执行期间, 执行线程持有了管程, 其他任何线程都无法在获取到同一个管程</p></blockquote><blockquote><p>在HotSpot虚拟机中, monitor采用<code>ObjectMonitor</code>实现</p><p>C++源码解读: ObjectMonitor.java -&gt; ObjectMonitor.cpp -&gt; ObjectMonitor.hpp</p><p>Tip: 每个对象天生就带着一个对象监视器</p></blockquote><blockquote><p>synchronized必须作用于某个对象, 所以Java在对象的头文件存储了锁相关信息. 锁升级功能主要依赖于MarkWord中锁标志位和偏向锁标志位</p><figure><img src="'+l+`" alt="image-20230410153953458" tabindex="0" loading="lazy"><figcaption>image-20230410153953458</figcaption></figure></blockquote><h4 id="公平锁与非公平锁" tabindex="-1"><a class="header-anchor" href="#公平锁与非公平锁" aria-hidden="true">#</a> 公平锁与非公平锁</h4><blockquote><p>排队讲求先来后到视为公平。</p><p>程序中的公平性也是符合请求锁的绝对时间的，其实就是 FIFO，否则视为不公平</p></blockquote><h5 id="reentrantlock卖票案例演示公平与非公平" tabindex="-1"><a class="header-anchor" href="#reentrantlock卖票案例演示公平与非公平" aria-hidden="true">#</a> ReentrantLock卖票案例演示公平与非公平</h5><ul><li>案例代码</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">L</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Ticket</span> ticket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Ticket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> ticket<span class="token punctuation">.</span><span class="token function">sale</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Ticket</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sale</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;票已售罄.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token operator">--</span>count<span class="token punctuation">;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;当前线程是: &quot;</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; 还剩下票: &quot;</span> <span class="token operator">+</span> count <span class="token operator">+</span> <span class="token string">&quot; 张&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>结果</li></ul><figure><img src="`+c+'" alt="image-20230410161633094" tabindex="0" loading="lazy"><figcaption>image-20230410161633094</figcaption></figure><h5 id="源码解读reentrantlock" tabindex="-1"><a class="header-anchor" href="#源码解读reentrantlock" aria-hidden="true">#</a> 源码解读ReentrantLock</h5><ul><li>构造函数</li></ul><img src="'+p+'" alt="image-20230410162755052" style="zoom:80%;"><ul><li>公平锁与非公平锁区别</li></ul><figure><img src="'+u+'" alt="image-20230410170138619" tabindex="0" loading="lazy"><figcaption>image-20230410170138619</figcaption></figure><blockquote><p>hasQueuedPredecessors()方法的作用:</p><ul><li><em>判断当前线程需不需要排队,根据同步队列中是否已经有其他的线程在排队的情况来决定,如果有其他的线程在排队,就需要排队,没有,就不需要排队</em>。此方法返回true,代表当前线程需要排队,返回false,表示当前线程不用排队</li></ul></blockquote><h5 id="为什么默认非公平" tabindex="-1"><a class="header-anchor" href="#为什么默认非公平" aria-hidden="true">#</a> 为什么默认非公平?</h5><blockquote><ol><li>恢复挂起的线程到真正锁的获取还是有时间差的, 从开发人员看这个时间微乎其微, 但是从CPU的角度看来, 这个时间差存在的还是很明显的. 所以非公平锁能更充分的利用CPU的时间片, 尽量减少CPU空闲状态时间</li><li>使用多线程很重要的考量点是线程切换的开销, 当采用非公平锁时, 当1个线程请求锁获取同步状态, 然后释放同步状态, 因此不需要考虑是否还有前驱节点, 所以刚释放锁的线程此刻再次获取同步状态的概率就变得非常大, 所以就减少了<u>线程的开销</u>.</li></ol></blockquote><blockquote><p>锁饥饿:</p><ul><li>公平锁保证了排队的公平性, 非公平锁八七的忽视这个规则, 所以就有可能导致排队的长时间在排队, 也没有机会获取到锁, 就是传说的&#39;锁饥饿&#39;</li></ul></blockquote><blockquote><p>什么时候使用公平锁? 什么时候使用非公平锁?</p><ul><li></li></ul></blockquote><h2 id="synchronized相关问题" tabindex="-1"><a class="header-anchor" href="#synchronized相关问题" aria-hidden="true">#</a> Synchronized相关问题</h2><h4 id="_1-synchronized用过吗-其原理是什么" tabindex="-1"><a class="header-anchor" href="#_1-synchronized用过吗-其原理是什么" aria-hidden="true">#</a> 1. Synchronized用过吗？其原理是什么</h4><h4 id="_2-获取对象的锁-这个锁到底是什么-如何确定对象的锁" tabindex="-1"><a class="header-anchor" href="#_2-获取对象的锁-这个锁到底是什么-如何确定对象的锁" aria-hidden="true">#</a> 2. 获取对象的锁，这个锁到底是什么？如何确定对象的锁？</h4><h4 id="_3-jvm对java的原生锁做了哪些优化" tabindex="-1"><a class="header-anchor" href="#_3-jvm对java的原生锁做了哪些优化" aria-hidden="true">#</a> 3. JVM对java的原生锁做了哪些优化?</h4><h4 id="_4-什么是可重入性-为什么sysnchronized是可重入锁" tabindex="-1"><a class="header-anchor" href="#_4-什么是可重入性-为什么sysnchronized是可重入锁" aria-hidden="true">#</a> 4. 什么是可重入性，为什么sysnchronized是可重入锁？</h4><blockquote><p><strong>可重入锁</strong>：</p><ul><li>又名 递归锁: 指在同一个线程的外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁(前提，锁对象是同一个对象)，不会因为之前已经获取过还没有释放而阻塞</li><li>Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。</li></ul><p>小结：一个线程中的多个流程可以获取同一把锁，持有这把同步锁可以再次进入。自己可以获取自己的内部锁</p></blockquote><blockquote><p>可重入锁种类:</p><ul><li>隐式锁(synchronized关键字使用的锁)默认是可重入锁 <ul><li>可重入锁：可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁，这样的锁叫做可重入锁</li><li>在一个synchronized修饰的方法或者代码块内部，调用本类的其他synchronized修饰的方法或者代码时，是永远可以得到锁的</li></ul></li><li>synchronized的重入实现机理: <ul><li>每个锁对象都拥有一个锁计数器和一个指向持有该锁线程的指针 <ul><li>当执行monitorenter时，如果目标对象的计数器为0，那么说明没有被其他线程所持有，Java虚拟机会将该锁对象持有线程设置为当前线程，并且将计数器累加i。在目标锁对象的计数器不为零的情况下，如果锁对象的持有线程时当前线程，那么Java虚拟机可以将其计数器加1，否则需要等待，直至持有线程释放该锁，当执行monitorexit时，Java虚拟机则将锁对象的计数器减1。计数器为0代表锁已经被释放。</li></ul></li></ul></li><li>显示锁(Lock)中reentrantlock也是可重入锁</li></ul></blockquote><h4 id="_5-为什么说sysnchronized是非公平锁" tabindex="-1"><a class="header-anchor" href="#_5-为什么说sysnchronized是非公平锁" aria-hidden="true">#</a> 5. 为什么说sysnchronized是非公平锁</h4><h4 id="_6-什么是锁消除和锁粗化" tabindex="-1"><a class="header-anchor" href="#_6-什么是锁消除和锁粗化" aria-hidden="true">#</a> 6. 什么是锁消除和锁粗化？</h4><h4 id="_7-为什么说sysnchronized是悲观锁-乐观锁的实现原理是什么-什么是cas" tabindex="-1"><a class="header-anchor" href="#_7-为什么说sysnchronized是悲观锁-乐观锁的实现原理是什么-什么是cas" aria-hidden="true">#</a> 7. 为什么说sysnchronized是悲观锁？乐观锁的实现原理是什么？什么是CAS?</h4><h4 id="_8-乐观锁一定是好的吗" tabindex="-1"><a class="header-anchor" href="#_8-乐观锁一定是好的吗" aria-hidden="true">#</a> 8. 乐观锁一定是好的吗？</h4><h2 id="可重入锁reentrantlock及其他显式锁相关问题" tabindex="-1"><a class="header-anchor" href="#可重入锁reentrantlock及其他显式锁相关问题" aria-hidden="true">#</a> 可重入锁ReentrantLock及其他显式锁相关问题</h2><h4 id="_1-根sysnchronized相比-可重入锁reentrantlock其实现原理有什么不同" tabindex="-1"><a class="header-anchor" href="#_1-根sysnchronized相比-可重入锁reentrantlock其实现原理有什么不同" aria-hidden="true">#</a> 1. 根sysnchronized相比，可重入锁reentrantLock其实现原理有什么不同？</h4><h4 id="_2-请谈" tabindex="-1"><a class="header-anchor" href="#_2-请谈" aria-hidden="true">#</a> 2. 请谈</h4><h4 id="谈aqs框架是怎么回事" tabindex="-1"><a class="header-anchor" href="#谈aqs框架是怎么回事" aria-hidden="true">#</a> 谈AQS框架是怎么回事？</h4><blockquote><p>AbstractQueuedSynchronizer之AQS</p><ul><li><p>字面意思:</p><ul><li>抽象的队列同步器</li><li>在Java Util concurrent locks包下</li></ul></li><li><p>技术翻译:</p><ul><li>是用来构建锁或者其他同步器组件的重量级基础框架及整合juc体系的基石，通过内置的<strong>FIFO队列</strong>来完成资源获取线程的排队工作，并通过一个int类变量表示持有锁的状态</li></ul><figure><img src="'+r+'" alt="image-20230328141517507" tabindex="0" loading="lazy"><figcaption>image-20230328141517507</figcaption></figure></li></ul></blockquote><blockquote><p>AQS为什么是JUC内容中最重要的基石？</p><ul><li></li><li>进一步理解锁和同步器的关系 <ul><li>锁：面向锁的<u>使用者</u><ul><li>定义了程序员和锁交互的使用层API，隐藏了实现细节，你低调用即可</li></ul></li><li>同步器: 面向锁的<u>实现者</u><ul><li>比如Java并发大神Douglee，提出统一规范并简化锁的实现，屏蔽了同步状态管理、阻塞线程排队和通知、唤醒机制等</li></ul></li></ul></li></ul></blockquote><blockquote><p>AQS能干什么？</p><ul><li><p>加锁会导致阻塞</p><ul><li>有阻塞就需要排队，实现排队必然需要有某种形式的队列来管理</li></ul></li><li><p>解释说明:</p><ul><li><p>抢到资源的线程直接使用办理业务，抢占不到资源的线程必然涉及一种<u>排队等候机制</u>，抢占资源失败的线程继续去等待，仍然保留获取锁的可能且获取锁的流程仍在继续</p></li><li><p>排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？</p><ul><li>如果共享资源被占用，就需要一定的阻塞等待唤醒机制保证锁分配。这个机制就是用CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中，这个队列就是AQS的抽象表现。它将请求共享资源的线程封装成队列的节点(Node),通过CAS、自旋以及LockSuport.park()方式，维护state变量的状态，使得并发达到同步的效果</li></ul><figure><img src="'+d+'" alt="image-20230328143326619" tabindex="0" loading="lazy"><figcaption>image-20230328143326619</figcaption></figure></li></ul></li></ul></blockquote><blockquote><p>AQS初步</p><ul><li><p>AQS初识</p><ul><li>官网解释:</li></ul><figure><img src="'+k+'" alt="image-20230328143502439" tabindex="0" loading="lazy"><figcaption>image-20230328143502439</figcaption></figure><ul><li>有阻塞就需要有排队，实现排队必然需要队列</li></ul></li><li><p>AQS内部体系架构</p><ul><li><img src="'+h+'" alt="image-20230328144120247" tabindex="0" loading="lazy"><figcaption>image-20230328144120247</figcaption></li><li></li></ul></li></ul></blockquote><h4 id="_3-请尽可能详细对比下synchronized与reentrantlock的异同" tabindex="-1"><a class="header-anchor" href="#_3-请尽可能详细对比下synchronized与reentrantlock的异同" aria-hidden="true">#</a> 3. 请尽可能详细对比下synchronized与reentrantLock的异同</h4><h4 id="_4-reentrantlock是如何实现可重入性的" tabindex="-1"><a class="header-anchor" href="#_4-reentrantlock是如何实现可重入性的" aria-hidden="true">#</a> 4. ReentrantLock是如何实现可重入性的？</h4><h1 id="aqs" tabindex="-1"><a class="header-anchor" href="#aqs" aria-hidden="true">#</a> AQS</h1><blockquote><p>队列同步器AbstractQueuedSynchronizer，是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。</p><p><strong>同步器的主要使用方式</strong>：继承，子类通过继承同步器并实现它的抽象方法来管理同步状态，它<strong>独占式</strong>和<strong>共享式</strong>两种方式获取同步状态，多线程并发情况下通过CAS的方式修改同步状态。</p><p>同步器的设计基于<strong>模板方法模式</strong>：</p><ol><li>继承同步器并重写指定的方法</li><li>将同步器组合在自定义同步组件的实现中</li><li>调用同步器提供的模板方法</li><li>模板方法将会调用使用者重写的方法</li></ol></blockquote><h1 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a></h1>',70),v=[b];function g(y,f){return a(),s("div",null,v)}const q=n(m,[["render",g],["__file","juc.html.vue"]]);export{q as default};
