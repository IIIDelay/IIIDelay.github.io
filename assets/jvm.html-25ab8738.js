const l=JSON.parse(`{"key":"v-66c6d818","path":"/en/javabase/advance/jvm.html","title":"VM运行时数据区","lang":"en-US","frontmatter":{"icon":"edit","date":"2023-03-26T00:00:00.000Z","category":["JavaBase"],"tag":["vm","source","c|c++"],"description":"VM运行时数据区 运行时数据区内存结构图 JVM内存结构 线程共享方法区和堆, 独占虚拟机栈、本地方法栈和程序计数器。 程序计数器 程序计数器是一块较小的内存空间, 可以看做当前线程执行的字节码的行号指示器。 作用： 字节码解释器通过改变程序计数器来依次读取指令, 从而实现流程控制。如：顺序选择、选择、循环、异常处理。 在多线程的情况下, 程序计数器记录当前线程的执行位置, 以便线程切换回来可以得知上次的执行位置。(问题：线程为什么独占程序计数器的答案)","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/en/javabase/advance/jvm.html"}],["meta",{"property":"og:site_name","content":"IIIDelay's Blog"}],["meta",{"property":"og:title","content":"VM运行时数据区"}],["meta",{"property":"og:description","content":"VM运行时数据区 运行时数据区内存结构图 JVM内存结构 线程共享方法区和堆, 独占虚拟机栈、本地方法栈和程序计数器。 程序计数器 程序计数器是一块较小的内存空间, 可以看做当前线程执行的字节码的行号指示器。 作用： 字节码解释器通过改变程序计数器来依次读取指令, 从而实现流程控制。如：顺序选择、选择、循环、异常处理。 在多线程的情况下, 程序计数器记录当前线程的执行位置, 以便线程切换回来可以得知上次的执行位置。(问题：线程为什么独占程序计数器的答案)"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://mister-hope.github.io/"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"VM运行时数据区"}],["meta",{"property":"article:author","content":"Mr.IIIDelay"}],["meta",{"property":"article:tag","content":"vm"}],["meta",{"property":"article:tag","content":"source"}],["meta",{"property":"article:tag","content":"c|c++"}],["meta",{"property":"article:published_time","content":"2023-03-26T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"VM运行时数据区\\",\\"image\\":[\\"https://mister-hope.github.io/\\"],\\"datePublished\\":\\"2023-03-26T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.IIIDelay\\",\\"url\\":\\"https://mrhope.site\\"}]}"]]},"headers":[{"level":2,"title":"程序计数器","slug":"程序计数器","link":"#程序计数器","children":[]},{"level":2,"title":"虚拟机栈","slug":"虚拟机栈","link":"#虚拟机栈","children":[{"level":3,"title":"局部变量表：","slug":"局部变量表","link":"#局部变量表","children":[]}]},{"level":2,"title":"本地方法栈","slug":"本地方法栈","link":"#本地方法栈","children":[]},{"level":2,"title":"堆","slug":"堆","link":"#堆","children":[]},{"level":2,"title":"方法区","slug":"方法区","link":"#方法区","children":[{"level":3,"title":"运行时常量池","slug":"运行时常量池","link":"#运行时常量池","children":[]},{"level":3,"title":"常用参数","slug":"常用参数","link":"#常用参数","children":[]},{"level":3,"title":"为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?","slug":"为什么要将永久代-permgen-替换为元空间-metaspace-呢","link":"#为什么要将永久代-permgen-替换为元空间-metaspace-呢","children":[]}]},{"level":2,"title":"直接内存","slug":"直接内存","link":"#直接内存","children":[]},{"level":2,"title":"对象的创建过程","slug":"对象的创建过程","link":"#对象的创建过程","children":[{"level":3,"title":"Step1:类加载检查","slug":"step1-类加载检查","link":"#step1-类加载检查","children":[]},{"level":3,"title":"Step2:分配内存","slug":"step2-分配内存","link":"#step2-分配内存","children":[]},{"level":3,"title":"Step3:初始化零值","slug":"step3-初始化零值","link":"#step3-初始化零值","children":[]},{"level":3,"title":"Step4:设置对象头","slug":"step4-设置对象头","link":"#step4-设置对象头","children":[]},{"level":3,"title":"Step5:执行 init 方法","slug":"step5-执行-init-方法","link":"#step5-执行-init-方法","children":[]}]},{"level":2,"title":"对象的内存布局","slug":"对象的内存布局","link":"#对象的内存布局","children":[{"level":3,"title":"对象头","slug":"对象头","link":"#对象头","children":[]},{"level":3,"title":"实例数据","slug":"实例数据","link":"#实例数据","children":[]},{"level":3,"title":"对齐填充部分","slug":"对齐填充部分","link":"#对齐填充部分","children":[]},{"level":3,"title":"对象的访问定位","slug":"对象的访问定位","link":"#对象的访问定位","children":[]}]},{"level":2,"title":"Java堆溢出","slug":"java堆溢出","link":"#java堆溢出","children":[]},{"level":2,"title":"虚拟机栈和本地方法栈溢出","slug":"虚拟机栈和本地方法栈溢出","link":"#虚拟机栈和本地方法栈溢出","children":[]},{"level":2,"title":"方法区和运行时常量池溢出","slug":"方法区和运行时常量池溢出","link":"#方法区和运行时常量池溢出","children":[]},{"level":2,"title":"本机直接内存溢出","slug":"本机直接内存溢出","link":"#本机直接内存溢出","children":[]},{"level":2,"title":"内存溢出和内存泄露","slug":"内存溢出和内存泄露","link":"#内存溢出和内存泄露","children":[]},{"level":2,"title":"String 类和常量池","slug":"string-类和常量池","link":"#string-类和常量池","children":[]},{"level":2,"title":"String s1 = new String(\\"abc\\");这句话创建了几个字符串对象？","slug":"string-s1-new-string-abc-这句话创建了几个字符串对象","link":"#string-s1-new-string-abc-这句话创建了几个字符串对象","children":[]},{"level":2,"title":"8种基本类型的包装类和常量池","slug":"_8种基本类型的包装类和常量池","link":"#_8种基本类型的包装类和常量池","children":[]},{"level":2,"title":"为什么需要了解垃圾回收机制？","slug":"为什么需要了解垃圾回收机制","link":"#为什么需要了解垃圾回收机制","children":[]},{"level":2,"title":"哪些区域需要垃圾回收？","slug":"哪些区域需要垃圾回收","link":"#哪些区域需要垃圾回收","children":[]},{"level":2,"title":"如何判断对象需要被回收？","slug":"如何判断对象需要被回收","link":"#如何判断对象需要被回收","children":[{"level":3,"title":"引用计数算法","slug":"引用计数算法","link":"#引用计数算法","children":[]},{"level":3,"title":"可达性分析算法","slug":"可达性分析算法","link":"#可达性分析算法","children":[]},{"level":3,"title":"利用可达性分析算法, 如何判断一个对象死亡？","slug":"利用可达性分析算法-如何判断一个对象死亡","link":"#利用可达性分析算法-如何判断一个对象死亡","children":[]}]},{"level":2,"title":"Java中的引用","slug":"java中的引用","link":"#java中的引用","children":[]},{"level":2,"title":"方法区的回收","slug":"方法区的回收","link":"#方法区的回收","children":[]},{"level":2,"title":"垃圾回收算法","slug":"垃圾回收算法","link":"#垃圾回收算法","children":[{"level":3,"title":"分代收集理论","slug":"分代收集理论","link":"#分代收集理论","children":[]},{"level":3,"title":"垃圾回收类型","slug":"垃圾回收类型","link":"#垃圾回收类型","children":[]},{"level":3,"title":"标记-清除算法(Mark-Sweep)","slug":"标记-清除算法-mark-sweep","link":"#标记-清除算法-mark-sweep","children":[]},{"level":3,"title":"标记-复制算法(Mark-Copying)","slug":"标记-复制算法-mark-copying","link":"#标记-复制算法-mark-copying","children":[]},{"level":3,"title":"标记-整理算法(Mark-Compact)","slug":"标记-整理算法-mark-compact","link":"#标记-整理算法-mark-compact","children":[]}]},{"level":2,"title":"HotSpot实现垃圾回收的算法细节(了解)","slug":"hotspot实现垃圾回收的算法细节-了解","link":"#hotspot实现垃圾回收的算法细节-了解","children":[{"level":3,"title":"根节点枚举","slug":"根节点枚举","link":"#根节点枚举","children":[]},{"level":3,"title":"安全点","slug":"安全点","link":"#安全点","children":[]},{"level":3,"title":"安全区域","slug":"安全区域","link":"#安全区域","children":[]},{"level":3,"title":"记忆集与卡表","slug":"记忆集与卡表","link":"#记忆集与卡表","children":[]},{"level":3,"title":"写屏障","slug":"写屏障","link":"#写屏障","children":[]},{"level":3,"title":"并发的可达性分析","slug":"并发的可达性分析","link":"#并发的可达性分析","children":[]}]},{"level":2,"title":"Young GC 和 Full GC 在什么情况下触发？","slug":"young-gc-和-full-gc-在什么情况下触发","link":"#young-gc-和-full-gc-在什么情况下触发","children":[]},{"level":2,"title":"三色标记法","slug":"三色标记法","link":"#三色标记法","children":[{"level":3,"title":"三色标记原理","slug":"三色标记原理","link":"#三色标记原理","children":[]},{"level":3,"title":"多标——浮动垃圾","slug":"多标——浮动垃圾","link":"#多标——浮动垃圾","children":[]},{"level":3,"title":"漏标-读写屏障","slug":"漏标-读写屏障","link":"#漏标-读写屏障","children":[]},{"level":3,"title":"写屏障","slug":"写屏障-1","link":"#写屏障-1","children":[]},{"level":3,"title":"写屏障 + 增量更新","slug":"写屏障-增量更新","link":"#写屏障-增量更新","children":[]},{"level":3,"title":"读屏障","slug":"读屏障","link":"#读屏障","children":[]},{"level":3,"title":"三色标记法与现代垃圾回收器","slug":"三色标记法与现代垃圾回收器","link":"#三色标记法与现代垃圾回收器","children":[]}]},{"level":2,"title":"经典的垃圾收集器","slug":"经典的垃圾收集器","link":"#经典的垃圾收集器","children":[{"level":3,"title":"Serial收集器","slug":"serial收集器","link":"#serial收集器","children":[]},{"level":3,"title":"ParNew收集器","slug":"parnew收集器","link":"#parnew收集器","children":[]},{"level":3,"title":"Parallel Scavenge收集器","slug":"parallel-scavenge收集器","link":"#parallel-scavenge收集器","children":[]},{"level":3,"title":"Serial Old收集器","slug":"serial-old收集器","link":"#serial-old收集器","children":[]},{"level":3,"title":"Parallel Old收集器","slug":"parallel-old收集器","link":"#parallel-old收集器","children":[]},{"level":3,"title":"CMS收集器","slug":"cms收集器","link":"#cms收集器","children":[]},{"level":3,"title":"Garbage First收集器 (G1)","slug":"garbage-first收集器-g1","link":"#garbage-first收集器-g1","children":[]}]},{"level":2,"title":"*CMS和G1的区别","slug":"cms和g1的区别","link":"#cms和g1的区别","children":[{"level":3,"title":"区别","slug":"区别","link":"#区别","children":[]},{"level":3,"title":"G1的优劣势分析","slug":"g1的优劣势分析","link":"#g1的优劣势分析","children":[]}]},{"level":2,"title":"低延迟的垃圾收集器","slug":"低延迟的垃圾收集器","link":"#低延迟的垃圾收集器","children":[{"level":3,"title":"Shenandoah收集器","slug":"shenandoah收集器","link":"#shenandoah收集器","children":[]},{"level":3,"title":"ZGC收集器","slug":"zgc收集器","link":"#zgc收集器","children":[]}]},{"level":2,"title":"如何选择垃圾收集器？","slug":"如何选择垃圾收集器","link":"#如何选择垃圾收集器","children":[{"level":3,"title":"主要因素","slug":"主要因素","link":"#主要因素","children":[]},{"level":3,"title":"如何选择？","slug":"如何选择","link":"#如何选择","children":[]}]},{"level":2,"title":"加载","slug":"加载","link":"#加载","children":[]},{"level":2,"title":"连接","slug":"连接","link":"#连接","children":[]},{"level":2,"title":"初始化","slug":"初始化","link":"#初始化","children":[]},{"level":2,"title":"补充：卸载","slug":"补充-卸载","link":"#补充-卸载","children":[]},{"level":2,"title":"类加载器总结","slug":"类加载器总结","link":"#类加载器总结","children":[]},{"level":2,"title":"双亲委派模型","slug":"双亲委派模型","link":"#双亲委派模型","children":[{"level":3,"title":"双亲委派模型的工作过程","slug":"双亲委派模型的工作过程","link":"#双亲委派模型的工作过程","children":[]},{"level":3,"title":"好处","slug":"好处","link":"#好处","children":[]},{"level":3,"title":"如何破坏双亲委派模型？","slug":"如何破坏双亲委派模型","link":"#如何破坏双亲委派模型","children":[]},{"level":3,"title":"自定义类加载器","slug":"自定义类加载器","link":"#自定义类加载器","children":[]}]}],"git":{},"readingTime":{"minutes":97.6,"words":29279},"filePathRelative":"en/javabase/advance/jvm.md","localizedDate":"March 26, 2023","excerpt":"<h1> VM运行时数据区</h1>\\n<figure><figcaption>运行时数据区内存结构图</figcaption></figure>\\n<figure><figcaption>JVM内存结构</figcaption></figure>\\n<p>线程共享方法区和堆, 独占虚拟机栈、本地方法栈和程序计数器。</p>\\n<h2> 程序计数器</h2>\\n<p>程序计数器是一块较小的内存空间, 可以看做当前线程执行的字节码的行号指示器。</p>\\n<p><strong>作用：</strong></p>\\n<ol>\\n<li><strong>字节码解释器通过改变程序计数器来依次读取指令, 从而实现流程控制</strong>。如：顺序选择、选择、循环、异常处理。</li>\\n<li><strong>在多线程的情况下, 程序计数器记录当前线程的执行位置, 以便线程切换回来可以得知上次的执行位置</strong>。(问题：线程为什么独占程序计数器的答案)</li>\\n</ol>","copyright":{"author":"Mr.IIIDelay"},"autoDesc":true}`);export{l as data};
