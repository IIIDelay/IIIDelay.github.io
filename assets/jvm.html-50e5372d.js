import{_ as o,W as p,X as i,Y as n,Z as a,$ as e,a1 as t,C as l}from"./framework-b5ea9e64.js";const c="/assets/20210621153304-52ab334d.png",r="/assets/20210810171112-bdd48b0c.png",u="/assets/20210621161216-663e9c2a.png",d="/assets/20210621161720-61a08cc1.png",k="/assets/202109242103520-44fef798.png",g="/assets/20210621162654-8d60dbeb.png",v="/assets/20210621162734-d1c88786.png",h="/assets/20210621103925-991c993a.png",m="/assets/20210621104016-614b0b37.png",b="/assets/Java四种引用的结构20210622164831-97e69702.png",f="/assets/202112292135030-733bd788.gif",S="/assets/202112292142247-91117b7a.png",q="/assets/202112292143458-c4fee9a0.png",C="/assets/垃圾收集器总结-49e3179d.png",x="/assets/202110021731339-c7102274.png",G="/assets/202110021732241-c7ae49cd.png",M="/assets/202110021732331-29ce1669.png",y="/assets/202110021739818-d00a4878.png",J="/assets/202110021758946-68dbf19b.png",w="/assets/202110021813564-419000a1.png",_="/assets/20210701103844-728d61bd.png",O="/assets/20210701154740-c6736678.png",j={},R=t('<h1 id="vm运行时数据区" tabindex="-1"><a class="header-anchor" href="#vm运行时数据区" aria-hidden="true">#</a> VM运行时数据区</h1><figure><img src="'+c+'" alt="运行时数据区内存结构图" tabindex="0" loading="lazy"><figcaption>运行时数据区内存结构图</figcaption></figure><figure><img src="'+r+`" alt="JVM内存结构" tabindex="0" loading="lazy"><figcaption>JVM内存结构</figcaption></figure><p>线程共享方法区和堆, 独占虚拟机栈、本地方法栈和程序计数器。</p><h2 id="程序计数器" tabindex="-1"><a class="header-anchor" href="#程序计数器" aria-hidden="true">#</a> 程序计数器</h2><p>程序计数器是一块较小的内存空间, 可以看做当前线程执行的字节码的行号指示器。</p><p><strong>作用：</strong></p><ol><li><strong>字节码解释器通过改变程序计数器来依次读取指令, 从而实现流程控制</strong>。如：顺序选择、选择、循环、异常处理。</li><li><strong>在多线程的情况下, 程序计数器记录当前线程的执行位置, 以便线程切换回来可以得知上次的执行位置</strong>。(问题：线程为什么独占程序计数器的答案)</li></ol><p><strong>注意：</strong></p><ul><li><strong>程序计数器是唯一一个在《Java虚拟机规范》中没有规定任何<code>OutOfMemoryError</code>情况的区域, 它的生命周期随着线程的创建而创建, 随着线程的结束而死亡。</strong></li><li>如果正在执行的是Java方法, 记录的是正在执行的虚拟机字节码指令地址；如果正在执行的是<strong>本地(Native)方法</strong>, 这个<strong>计数器值则应为空(<code>Undefined</code>)</strong>。</li></ul><h2 id="虚拟机栈" tabindex="-1"><a class="header-anchor" href="#虚拟机栈" aria-hidden="true">#</a> 虚拟机栈</h2><p>描述的是Java方法执行的线程内存模型, 每个方法会创建一个<strong>栈帧</strong>, 栈帧中存放<strong>局部变量表、操作数栈、动态链接、方法出口</strong>等信息。</p><p><strong>方法/函数如何调用？</strong></p><p>Java 栈可用类比数据结构中栈, Java 栈中保存的主要内容是栈帧, 每一次函数调用都会有一个对应的栈帧被压入 Java 栈, 每一个函数调用结束后, 都会有一个栈帧被弹出。</p><p>Java 方法有两种返回方式：</p><ol><li>return 语句。</li><li>抛出异常。</li></ol><p>不管哪种返回方式都会导致栈帧被弹出。</p><p>每个方法被调用直至执行完毕的过程, 对应一个栈帧在虚拟机栈入栈和出栈的过程。</p><p><em>(栈内存一般指局部变量表)</em></p><h3 id="局部变量表" tabindex="-1"><a class="header-anchor" href="#局部变量表" aria-hidden="true">#</a> <strong>局部变量表</strong>：</h3><p>局部变量表存放了编译期中各种的<strong>基本数据类型</strong>、<strong>对象引用</strong>(并不是对象本身, 可能是指向对象起始地址的一个引用指针, 也可能是指向一个代表对象的句柄或其他与此对象相关的位置信息)和<strong>returnAddress类型</strong>(指向一条字节码指令的地址)。</p><ul><li>64位的long和double类型的数据会占用2个局部变量空间, 其余的数据类型只占用1个</li><li>局部变量表所需内存编译期完成分配, 进入一个方法后, 栈分配多少内存是固定的, 运行期间不会改变。</li></ul><p>OOM</p><p>《Java虚拟机规范》规定,</p><p>1)如果线程请求的栈深度大于虚拟机所允许的最大深度, 将抛出<code>StackOverflowError</code>异常。 2)如果虚拟机的栈内存允许动态扩展, 当扩展栈容量无法申请到足够的内存时, 将抛出<code>OutOfMemoryError</code>异常。</p><p>但是HotSpot虚拟机的选择是不支持扩展, 所以除非在创建线程申请内存时就因无法获得足够内存而出现 <code>OutOfMemoryError</code>异常, 否则在线程运行时是不会因为扩展而导致内存溢出的, 只会因为栈容量无法容纳新的栈帧而导致<code>StackOverflowError</code>异常。</p><h2 id="本地方法栈" tabindex="-1"><a class="header-anchor" href="#本地方法栈" aria-hidden="true">#</a> 本地方法栈</h2><ul><li><p>和虚拟机栈类似, 两者的区别就是<strong>虚拟机栈是为虚拟机执行java方法服务</strong>, <strong>本地方法栈为虚拟机执行native方法服务</strong>。</p></li><li><p><strong>HotSpot虚拟机不区分虚拟机栈和本地方法栈</strong>(合二为一)。</p></li></ul><h2 id="堆" tabindex="-1"><a class="header-anchor" href="#堆" aria-hidden="true">#</a> 堆</h2><ul><li><p>Java 虚拟机所管理的内存中最大的一块, Java 堆是<strong>所有线程共享的一块内存区域</strong>, 在虚拟机启动时创建。</p></li><li><p><strong>此内存区域的唯一目的就是存放对象实例, 几乎所有的对象实例以及数组都在这里分配内存。</strong></p></li><li><p>堆是垃圾收集器管理的主要区域, 因此也被称为&quot;GC堆&quot;</p></li><li><p>JAVA堆可以处于物理上不连续的内存空间中, 只要逻辑上是连续的即可。</p></li><li><p>可通过参数 -Xmx -Xms 来指定运行时堆内存的大小, 在Java堆中没有内存完成实例分配, 并且也无法扩展时, 会抛<code>OutOfMemoryError</code>异常。</p></li></ul><h2 id="方法区" tabindex="-1"><a class="header-anchor" href="#方法区" aria-hidden="true">#</a> 方法区</h2><ul><li>方法区也是线程共享区, 用于存储【虚拟机加载的<strong>类信息</strong>(类的版本、字段、方法、接口), <strong>常量</strong>, <strong>静态变量</strong>, <strong>即时编译器编译后的代码缓存</strong>等数据】</li></ul><p><strong>方法区和永久代的关系</strong>：</p><blockquote><p>《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用, 并没有规定如何去实现它。那么, 在不同的 JVM 上方法区的实现肯定是不同的了。 <strong>方法区和永久代的关系很像 Java 中接口和类的关系, 类实现了接口, 而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。</strong> 也就是说, 永久代是 HotSpot 的概念, 方法区是 Java 虚拟机规范中的定义, 是一种规范, 而永久代是一种实现, 一个是标准一个是实现, 其他的虚拟机实现并没有永久代这一说法。</p></blockquote><p><strong>JDK8移除了永久代, 改为元空间代替。为什么？</strong></p><p>因为永久代有上限, 导致Java应用更容易遇到内存溢出问题。</p><p>内存回收的目标主要针对 常量池的回收 和 类型的卸载。</p><h3 id="运行时常量池" tabindex="-1"><a class="header-anchor" href="#运行时常量池" aria-hidden="true">#</a> 运行时常量池</h3><p>运行时常量池(Runtime Constant Pool)是方法区的一部分, 用于<strong>存放编译期生成的各种字面量与符号引用</strong>(属于类信息的一部分)。</p><p>《Java虚拟机规范》并没有做任何细节要求, 可以由供应商自己实现。</p><p>运行时常量池与Class文件常量池对比 最大特征是<strong>具备动态性</strong>。运行时可以将新的常量放入池中, 典型的有<code>String</code>类的<code>intern()</code>方法。</p><blockquote><p><code>String</code>类的<code>intern()</code>方法：返回字符串对象的规范化表示形式。</p><p>一个初始时为空的字符串池, 它由类 String 私有地维护。</p><p><strong>当调用 intern 方法时, 如果池已经包含一个等于此 String 对象的字符串(该对象由 <code>equals(Object)</code> 方法确定), 则返回池中的字符串。否则, 将此 String 对象添加到池中, 并且返回此 String 对象的引用。</strong></p><p>它遵循对于任何两个字符串 s 和 t, 当且仅当 <code>s.equals(t)</code> 为 <code>true</code> 时, <code>s.intern() == t.intern() </code>才为 <code>true</code>。</p></blockquote><h3 id="常用参数" tabindex="-1"><a class="header-anchor" href="#常用参数" aria-hidden="true">#</a> 常用参数</h3><p>JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token class-name">PermSize</span><span class="token operator">=</span><span class="token class-name">N</span> <span class="token comment">//方法区 (永久代) 初始大小</span>
<span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token class-name">MaxPermSize</span><span class="token operator">=</span><span class="token class-name">N</span> <span class="token comment">//方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGenCopy to clipboardErrorCopied</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>相对而言, 垃圾收集行为在这个区域是比较少出现的, 但并非数据进入方法区后就&quot;永久存在&quot;了。</p><p>JDK 1.8 的时候, 方法区(HotSpot 的永久代)被彻底移除了(JDK1.7 就已经开始了), 取而代之是元空间, 元空间使用的是直接内存。</p><p>下面是一些常用参数：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token class-name">MetaspaceSize</span><span class="token operator">=</span><span class="token class-name">N</span> <span class="token comment">//设置 Metaspace 的初始(和最小大小)</span>
<span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token class-name">MaxMetaspaceSize</span><span class="token operator">=</span><span class="token class-name">N</span> <span class="token comment">//设置 Metaspace 的最大大小Copy to clipboardErrorCopied</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>与永久代很大的不同就是, 如果不指定大小的话, 随着更多类的创建, 虚拟机会耗尽所有可用的系统内存。</p><h3 id="为什么要将永久代-permgen-替换为元空间-metaspace-呢" tabindex="-1"><a class="header-anchor" href="#为什么要将永久代-permgen-替换为元空间-metaspace-呢" aria-hidden="true">#</a> 为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</h3><blockquote><p>考虑到HotSpot未来的发展, 在JDK 6的时候HotSpot开发团队就有放弃永久代, 逐步改为采用本地内存(Native Memory)来实现方法区的计划了[1], 到了JDK 7的HotSpot, 已经把原本放在永久代的字符串常量池、静态变量等移出, 而到了JDK 8, 终于完全废弃了永久代的概念, 改用与JRockit、J9一样在本地内存中实现的元空间(Meta-space)来代替, 把JDK 7中永久代还剩余的内容(主要是类型信息)全部移到元空间中。</p></blockquote><ol><li><p>整个永久代有一个 JVM 本身设置的固定大小上限, 无法进行调整, 而元空间使用的是直接内存, 受本机可用内存的限制, 虽然元空间仍旧可能溢出, 但是比原来出现的几率会更小。</p><blockquote><p>当元空间溢出时会得到如下错误： <code>java.lang.OutOfMemoryError: MetaSpace</code></p></blockquote><p>你可以使用 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小, 默认值为 unlimited, 这意味着它只受系统内存的限制。<code>-XX：MetaspaceSize</code> 调整标志定义元空间的初始大小如果未指定此标志, 则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</p></li><li><p>元空间里面存放的是类的元数据, 这样加载多少类的元数据就不由 <code>MaxPermSize</code> 控制了, 而由系统的实际可用空间来控制, 这样能加载的类就更多了。</p></li><li><p>在 JDK8, 合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。</p></li></ol><h2 id="直接内存" tabindex="-1"><a class="header-anchor" href="#直接内存" aria-hidden="true">#</a> 直接内存</h2><p><strong>直接内存并不是虚拟机运行时数据区的一部分, 也不是虚拟机规范中定义的内存区域, 但是这部分内存也被频繁地使用。而且也可能导致 <code>OutOfMemoryError</code> 异常出现</strong>。</p><p>本机直接内存的分配不会受到 Java 堆的限制, 但是, 既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p><p>一般配置虚拟机参数时会根据实际内存去设置-Xmx等信息, 但经常忽略直接内存, 导致总内存大于物理内存限制, 动态扩容时出现<code>OutOfMemoryError</code> 异常。</p><blockquote><p>JDK1.4 中新加入的 <strong>NIO(New Input/Output) 类</strong>, 引入了一种基于<strong>通道(Channel)</strong> 与<strong>缓存区(Buffer)</strong> 的 I/O 方式, 它可以直接使用 Native 函数库直接分配堆外内存, 然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能, 因为<strong>避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</p></blockquote><h1 id="hotspot虚拟机" tabindex="-1"><a class="header-anchor" href="#hotspot虚拟机" aria-hidden="true">#</a> HotSpot虚拟机</h1><p>总结HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程。</p><h2 id="对象的创建过程" tabindex="-1"><a class="header-anchor" href="#对象的创建过程" aria-hidden="true">#</a> 对象的创建过程</h2><figure><img src="`+u+'" alt="Java创建对象的过程" tabindex="0" loading="lazy"><figcaption>Java创建对象的过程</figcaption></figure><h3 id="step1-类加载检查" tabindex="-1"><a class="header-anchor" href="#step1-类加载检查" aria-hidden="true">#</a> Step1:类加载检查</h3><p>虚拟机遇到一条 new 指令时, 首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用, 并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有, 那必须先执行相应的类加载过程。</p><h3 id="step2-分配内存" tabindex="-1"><a class="header-anchor" href="#step2-分配内存" aria-hidden="true">#</a> Step2:分配内存</h3><p>在<strong>类加载检查</strong>通过后, 接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定, 为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>&quot;指针碰撞&quot;</strong> 和 <strong>&quot;空闲列表&quot;</strong> 两种, <strong>选择哪种分配方式由 Java 堆是否规整决定, 而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p><p><strong>内存分配的两种方式：</strong></p><p>选择以上两种方式中的哪一种, 取决于 Java 堆内存是否规整。而 Java 堆内存是否规整, 取决于 GC 收集器的算法是&quot;标记-清除&quot;, 还是&quot;标记-整理&quot;(也称作&quot;标记-压缩&quot;), 值得注意的是, 复制算法内存也是规整的。</p><figure><img src="'+d+'" alt="image-20210621161720591" tabindex="0" loading="lazy"><figcaption>image-20210621161720591</figcaption></figure><p><strong>内存分配并发问题：</strong></p><p>在创建对象的时候有一个很重要的问题, 就是线程安全, 因为在实际开发过程中, 创建对象是很频繁的事情, 作为虚拟机来说, 必须要保证线程是安全的, 通常来讲, 虚拟机采用两种方式来保证线程安全：</p><ul><li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是, 每次不加锁而是假设没有冲突而去完成某项操作, 如果因为冲突失败就重试, 直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li><li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存, JVM 在给线程中的对象分配内存时, 首先在 TLAB 分配, 当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时, 再采用上述的 CAS 进行内存分配</li></ul><h3 id="step3-初始化零值" tabindex="-1"><a class="header-anchor" href="#step3-初始化零值" aria-hidden="true">#</a> Step3:初始化零值</h3><p>内存分配完成后, 虚拟机需要将分配到的内存空间都<strong>初始化为零值(不包括对象头)</strong>, 这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用, 程序能访问到这些字段的数据类型所对应的零值。</p><h3 id="step4-设置对象头" tabindex="-1"><a class="header-anchor" href="#step4-设置对象头" aria-hidden="true">#</a> Step4:设置对象头</h3><p>初始化零值完成之后, <strong>虚拟机要对对象进行必要的设置</strong>, 例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在<strong>对象头</strong>中。 另外, 根据虚拟机当前运行状态的不同, 如是否启用偏向锁等, 对象头会有不同的设置方式。</p><h3 id="step5-执行-init-方法" tabindex="-1"><a class="header-anchor" href="#step5-执行-init-方法" aria-hidden="true">#</a> Step5:执行 init 方法</h3><p>在上面工作都完成之后, 从虚拟机的视角来看, 一个新的对象已经产生了, 但从 Java 程序的视角来看, 对象创建才刚开始, <code>&lt;init&gt;</code> 方法还没有执行, 所有的字段都还为零。所以一般来说, 执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法, 把对象按照程序员的意愿进行初始化, 这样一个真正可用的对象才算完全产生出来。</p><h2 id="对象的内存布局" tabindex="-1"><a class="header-anchor" href="#对象的内存布局" aria-hidden="true">#</a> 对象的内存布局</h2><p>在 Hotspot 虚拟机中, 对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p><h3 id="对象头" tabindex="-1"><a class="header-anchor" href="#对象头" aria-hidden="true">#</a> 对象头</h3><p><strong>Hotspot 虚拟机的对象头包括两部分信息</strong>：</p><ol><li>用于存储<strong>对象自身的运行时数据</strong>(哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等)。官方称这部分为&quot;Mark Word&quot;。</li><li><strong>类型指针</strong>, 即对象指向它的类元数据的指针, 虚拟机通过这个指针来确定这个对象是那个类的实例。</li><li>特殊情况：如果对象是一个Java数组, 那在对象头中还必须有一块用于记录数组长度的数据, 因为虚拟机可以通过普通 Java对象的元数据信息确定Java对象的大小, 但是如果数组的长度是不确定的, 将无法通过元数据中的 信息推断出数组的大小。</li></ol><figure><img src="'+k+'" alt="HotSpot虚拟机对象头Mark Word" tabindex="0" loading="lazy"><figcaption>HotSpot虚拟机对象头Mark Word</figcaption></figure><h3 id="实例数据" tabindex="-1"><a class="header-anchor" href="#实例数据" aria-hidden="true">#</a> 实例数据</h3><p><strong>实例数据部分是对象真正存储的有效信息</strong>, 也是在程序中所定义的各种类型的字段内容。</p><h3 id="对齐填充部分" tabindex="-1"><a class="header-anchor" href="#对齐填充部分" aria-hidden="true">#</a> 对齐填充部分</h3><p><strong>对齐填充部分不是必然存在的, 也没有什么特别的含义, 仅仅起占位作用。</strong></p><p>因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍, 换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数(1 倍或 2 倍), 因此, 当对象实例数据部分没有对齐时, 就需要通过对齐填充来补全。</p><h3 id="对象的访问定位" tabindex="-1"><a class="header-anchor" href="#对象的访问定位" aria-hidden="true">#</a> 对象的访问定位</h3><p>建立对象就是为了使用对象, 我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定, 目前主流的访问方式有<strong>① 使用句柄</strong>和<strong>② 直接指针</strong>两种：</p><p><strong>句柄访问：</strong> 如果使用句柄的话, 那么 Java 堆中将会划分出一块内存来作为句柄池, reference 中存储的就是对象的句柄地址, 而句柄中包含了对象实例数据与类型数据各自的具体地址信息；</p><p>优点：reference中存储的是稳定句柄地址, 在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针, 而reference本身不需要被修改。</p><figure><img src="'+g+'" alt="通过句柄访问对象" tabindex="0" loading="lazy"><figcaption>通过句柄访问对象</figcaption></figure><p><strong>直接指针访问</strong>： 如果使用直接指针访问, 那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息, 而 reference 中存储的直接就是对象的地址。</p><p>优点：速度更快, 它节省了一次指针定位的时间开销, 由于对象访问在Java中非常频繁, 因此这类开销积少成多也是一项极为可观的执行成本。</p><figure><img src="'+v+`" alt="通过直接指针访问对象" tabindex="0" loading="lazy"><figcaption>通过直接指针访问对象</figcaption></figure><p>HotSpot而言, 它主要使用<strong>直接指针访问方式</strong>进行对象访问(有例外情况, 如果使用了Shenandoah收集器的话也会有一次额外的转发)</p><h1 id="outofmemoryerror异常" tabindex="-1"><a class="header-anchor" href="#outofmemoryerror异常" aria-hidden="true">#</a> OutOfMemoryError异常</h1><h2 id="java堆溢出" tabindex="-1"><a class="header-anchor" href="#java堆溢出" aria-hidden="true">#</a> Java堆溢出</h2><p>Java堆用来不断创建对象实例, 只要不断创建对象, 并且避免垃圾回收机制清除这些对象(<strong>保证GC Roots到对象之间有可达路径</strong><strong>来避免垃圾回收机制清除这些对象</strong>), 那么随着对象数量增加, 超出总容量及最大容量限制后就会产生内存溢出异常。</p><p>限制Java堆的大小为20MB, 不可扩展(将堆的最小值-Xms参数与最大值-Xmx参数设置为一样即可避免堆自动扩展), 通过参数<code>-XX：+HeapDumpOnOutOfMemoryError</code>可以让虚拟机在出现内存溢出异常的时候Dump出当前的内存堆转储快照以便进行事后分析。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * description:Java堆内存溢出异常测试
 * VM Args：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError
 *
 * <span class="token keyword">@author</span> RenShiWei
 * Date: 2021/6/20 17:26
 **/</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeapOOM</span> <span class="token punctuation">{</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">OOMObject</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">OOMObject</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OOMObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果： ![image-20210620173433707](./images/jvm/ Java堆溢出结果.png)</p><p>Java堆内存的<code>OutOfMemoryError</code>异常是实际应用中最常见的内存溢出异常情况。出现Java堆内存溢出时, 异常堆栈信息&quot;<code>java.lang.OutOfMemoryError</code>&quot;会跟随进一步提示&quot;<code>Java heap space</code>&quot;。</p><p><strong>解决</strong>：</p><p>解决这个异常, 需要通过<strong>内存映像分析工具</strong>对Dump出来的堆转储快照进行分析。</p><p>第一步确定导致内存OMM的对象是否必要, 即确定到底是<strong>内存泄漏</strong>, 还是<strong>内存溢出</strong>。</p><p>如果是<strong>内存泄漏</strong>, 可进一步通过工具<strong>查看泄漏对象到GC Roots的引用链</strong>, 找到泄漏对象是通过怎样的引用路径、与哪些GC Roots相关联, 才导致垃圾收集器无法回收它们, 根据泄漏对象的类型信息以及它到GC Roots引用链的信息, 一般可以比较准确地定位到这些对象创建的位置, 进而找出产生内存泄漏的代码的具体位置。</p><p>如果是<strong>内存溢出</strong>, 换句话说就是<strong>内存中的对象确实都是必须存活的</strong>, 那就应当<strong>检查Java虚拟机的堆参数(-Xmx与-Xms)设置</strong>, 与机器的内存对比, 看看是否还有向上调整的空间。再<strong>从代码上检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况, 尽量减少程序运行期的内存消耗</strong>。</p><h2 id="虚拟机栈和本地方法栈溢出" tabindex="-1"><a class="header-anchor" href="#虚拟机栈和本地方法栈溢出" aria-hidden="true">#</a> 虚拟机栈和本地方法栈溢出</h2><p>由于HotSpot虚拟机中并不区分虚拟机栈和本地方法栈, 因此对于HotSpot来说, -Xoss参数(设置本地方法栈大小)虽然存在, 但实际上是没有任何效果的, 栈容量只能由<code>-Xss</code>参数来设定。关于虚拟机栈和本地方法栈, 在《Java虚拟机规范》中描述了两种异常：</p><p>1)<strong>如果线程请求的栈深度大于虚拟机所允许的最大深度, 将抛出<code>StackOverflowError</code>异常</strong>。</p><p>2)<strong>如果虚拟机的栈内存允许动态扩展, 当扩展栈容量无法申请到足够的内存时, 将抛出<code>OutOfMemoryError</code>异常</strong>。</p><blockquote><p>《Java虚拟机规范》明确允许Java虚拟机实现自行选择是否支持栈的动态扩展, 而HotSpot虚拟机的选择是不支持扩展, 所以除非在创建线程申请内存时就因无法获得足够内存而出现<code>OutOfMemoryError</code>异常, 否则在线程运行时是不会因为扩展而导致内存溢出的, 只会因为栈容量无法容纳新的栈帧而导致<code>StackOverflowError</code>异常。</p></blockquote><p>为了验证这点, 我们可以做两个实验, 先将实验范围限制在单线程中操作, 尝试下面两种行为是否能让HotSpot虚拟机产生OutOfMemoryError异常：</p><p><strong>实例一：使用<code>-Xss</code>参数减少栈内存容量。</strong> 结果：抛出<code>StackOverflowError</code>异常, 异常出现时输出的堆栈深度相应缩小</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * description:VM Args：-Xss128k
 * 减少内存容量, 测试虚拟机栈和本地方法栈溢出
 *
 * <span class="token keyword">@author</span> RenShiWei
 * Date: 2021/6/21 10:27
 **/</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StackSOF</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> stackLength <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token doc-comment comment">/**
     * 无限递归压栈, 出现栈溢出现象
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">stackLeak</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        stackLength<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token function">stackLeak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>
        <span class="token class-name">StackSOF</span> oom <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StackSOF</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            oom<span class="token punctuation">.</span><span class="token function">stackLeak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;stack length:&quot;</span> <span class="token operator">+</span> oom<span class="token punctuation">.</span>stackLength<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">throw</span> e<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果：</p><figure><img src="`+h+`" alt="image-20210621103925493" tabindex="0" loading="lazy"><figcaption>image-20210621103925493</figcaption></figure><p><strong>实例二：定义了大量的本地变量, 增大此方法帧中本地变量表的长度。</strong> 结果：抛出<code>StackOverflowError</code>异常, 异常出现时输出的堆栈深度相应缩小。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * description:定义了大量的本地变量, 增大此方法帧中本地变量表的长度, 测试虚拟机栈和本地方法栈的溢出
 *
 * <span class="token keyword">@author</span> RenShiWei
 * Date: 2021/6/21 10:37
 **/</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StackSOF2</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> stackLength <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token doc-comment comment">/**
     * 定义大量的变量, 并且赋值
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">long</span> unused1<span class="token punctuation">,</span> unused2<span class="token punctuation">,</span> unused3<span class="token punctuation">,</span> unused4<span class="token punctuation">,</span> unused5<span class="token punctuation">,</span>
                unused6<span class="token punctuation">,</span> unused7<span class="token punctuation">,</span> unused8<span class="token punctuation">,</span> unused9<span class="token punctuation">,</span> unused10<span class="token punctuation">,</span>
                unused11<span class="token punctuation">,</span> unused12<span class="token punctuation">,</span> unused13<span class="token punctuation">,</span> unused14<span class="token punctuation">,</span> unused15<span class="token punctuation">,</span>
                unused16<span class="token punctuation">,</span> unused17<span class="token punctuation">,</span> unused18<span class="token punctuation">,</span> unused19<span class="token punctuation">,</span> unused20<span class="token punctuation">,</span>
                unused21<span class="token punctuation">,</span> unused22<span class="token punctuation">,</span> unused23<span class="token punctuation">,</span> unused24<span class="token punctuation">,</span> unused25<span class="token punctuation">,</span>
                unused26<span class="token punctuation">,</span> unused27<span class="token punctuation">,</span> unused28<span class="token punctuation">,</span> unused29<span class="token punctuation">,</span> unused30<span class="token punctuation">,</span>
                unused31<span class="token punctuation">,</span> unused32<span class="token punctuation">,</span> unused33<span class="token punctuation">,</span> unused34<span class="token punctuation">,</span> unused35<span class="token punctuation">,</span>
                unused36<span class="token punctuation">,</span> unused37<span class="token punctuation">,</span> unused38<span class="token punctuation">,</span> unused39<span class="token punctuation">,</span> unused40<span class="token punctuation">,</span>
                unused41<span class="token punctuation">,</span> unused42<span class="token punctuation">,</span> unused43<span class="token punctuation">,</span> unused44<span class="token punctuation">,</span> unused45<span class="token punctuation">,</span>
                unused46<span class="token punctuation">,</span> unused47<span class="token punctuation">,</span> unused48<span class="token punctuation">,</span> unused49<span class="token punctuation">,</span> unused50<span class="token punctuation">,</span>
                unused51<span class="token punctuation">,</span> unused52<span class="token punctuation">,</span> unused53<span class="token punctuation">,</span> unused54<span class="token punctuation">,</span> unused55<span class="token punctuation">,</span>
                unused56<span class="token punctuation">,</span> unused57<span class="token punctuation">,</span> unused58<span class="token punctuation">,</span> unused59<span class="token punctuation">,</span> unused60<span class="token punctuation">,</span>
                unused61<span class="token punctuation">,</span> unused62<span class="token punctuation">,</span> unused63<span class="token punctuation">,</span> unused64<span class="token punctuation">,</span> unused65<span class="token punctuation">,</span>
                unused66<span class="token punctuation">,</span> unused67<span class="token punctuation">,</span> unused68<span class="token punctuation">,</span> unused69<span class="token punctuation">,</span> unused70<span class="token punctuation">,</span>
                unused71<span class="token punctuation">,</span> unused72<span class="token punctuation">,</span> unused73<span class="token punctuation">,</span> unused74<span class="token punctuation">,</span> unused75<span class="token punctuation">,</span>
                unused76<span class="token punctuation">,</span> unused77<span class="token punctuation">,</span> unused78<span class="token punctuation">,</span> unused79<span class="token punctuation">,</span> unused80<span class="token punctuation">,</span>
                unused81<span class="token punctuation">,</span> unused82<span class="token punctuation">,</span> unused83<span class="token punctuation">,</span> unused84<span class="token punctuation">,</span> unused85<span class="token punctuation">,</span>
                unused86<span class="token punctuation">,</span> unused87<span class="token punctuation">,</span> unused88<span class="token punctuation">,</span> unused89<span class="token punctuation">,</span> unused90<span class="token punctuation">,</span>
                unused91<span class="token punctuation">,</span> unused92<span class="token punctuation">,</span> unused93<span class="token punctuation">,</span> unused94<span class="token punctuation">,</span> unused95<span class="token punctuation">,</span>
                unused96<span class="token punctuation">,</span> unused97<span class="token punctuation">,</span> unused98<span class="token punctuation">,</span> unused99<span class="token punctuation">,</span> unused100<span class="token punctuation">;</span>

        stackLength<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        unused1 <span class="token operator">=</span> unused2 <span class="token operator">=</span> unused3 <span class="token operator">=</span> unused4 <span class="token operator">=</span> unused5 <span class="token operator">=</span>
                unused6 <span class="token operator">=</span> unused7 <span class="token operator">=</span> unused8 <span class="token operator">=</span> unused9 <span class="token operator">=</span> unused10 <span class="token operator">=</span>
                        unused11 <span class="token operator">=</span> unused12 <span class="token operator">=</span> unused13 <span class="token operator">=</span> unused14 <span class="token operator">=</span> unused15 <span class="token operator">=</span>
                                unused16 <span class="token operator">=</span> unused17 <span class="token operator">=</span> unused18 <span class="token operator">=</span> unused19 <span class="token operator">=</span> unused20 <span class="token operator">=</span>
                                        unused21 <span class="token operator">=</span> unused22 <span class="token operator">=</span> unused23 <span class="token operator">=</span> unused24 <span class="token operator">=</span> unused25 <span class="token operator">=</span>
                                                unused26 <span class="token operator">=</span> unused27 <span class="token operator">=</span> unused28 <span class="token operator">=</span> unused29 <span class="token operator">=</span> unused30 <span class="token operator">=</span>
                                                        unused31 <span class="token operator">=</span> unused32 <span class="token operator">=</span> unused33 <span class="token operator">=</span> unused34 <span class="token operator">=</span> unused35 <span class="token operator">=</span>
                                                                unused36 <span class="token operator">=</span> unused37 <span class="token operator">=</span> unused38 <span class="token operator">=</span> unused39 <span class="token operator">=</span> unused40 <span class="token operator">=</span>
                                                                        unused41 <span class="token operator">=</span> unused42 <span class="token operator">=</span> unused43 <span class="token operator">=</span> unused44 <span class="token operator">=</span>
                                                                                unused45 <span class="token operator">=</span>
                                                                                        unused46 <span class="token operator">=</span> unused47 <span class="token operator">=</span> unused48 <span class="token operator">=</span>
                                                                                                unused49 <span class="token operator">=</span> unused50 <span class="token operator">=</span>
                                                                                                        unused51 <span class="token operator">=</span>
                                                                                                                unused52 <span class="token operator">=</span>
                                                                                                                        unused53 <span class="token operator">=</span> unused54 <span class="token operator">=</span>
                                                                                                                                unused55 <span class="token operator">=</span>
                                                                                                                                        unused56 <span class="token operator">=</span> unused57 <span class="token operator">=</span>
                                                                                                                                                unused58 <span class="token operator">=</span>
                                                                                                                                                        unused59 <span class="token operator">=</span> unused60 <span class="token operator">=</span>
                                                                                                                                                                unused61 <span class="token operator">=</span>
                                                                                                                                                                        unused62 <span class="token operator">=</span> unused63 <span class="token operator">=</span> unused64 <span class="token operator">=</span> unused65 <span class="token operator">=</span>
                                                                                                                                                                                unused66 <span class="token operator">=</span> unused67 <span class="token operator">=</span> unused68 <span class="token operator">=</span> unused69 <span class="token operator">=</span> unused70 <span class="token operator">=</span>
                                                                                                                                                                                        unused71 <span class="token operator">=</span> unused72 <span class="token operator">=</span> unused73 <span class="token operator">=</span> unused74 <span class="token operator">=</span> unused75 <span class="token operator">=</span>
                                                                                                                                                                                                unused76 <span class="token operator">=</span> unused77 <span class="token operator">=</span> unused78 <span class="token operator">=</span> unused79 <span class="token operator">=</span> unused80 <span class="token operator">=</span>
                                                                                                                                                                                                        unused81 <span class="token operator">=</span> unused82 <span class="token operator">=</span> unused83 <span class="token operator">=</span> unused84 <span class="token operator">=</span> unused85 <span class="token operator">=</span>
                                                                                                                                                                                                                unused86 <span class="token operator">=</span> unused87 <span class="token operator">=</span> unused88 <span class="token operator">=</span> unused89 <span class="token operator">=</span> unused90 <span class="token operator">=</span>
                                                                                                                                                                                                                        unused91 <span class="token operator">=</span> unused92 <span class="token operator">=</span> unused93 <span class="token operator">=</span> unused94 <span class="token operator">=</span> unused95 <span class="token operator">=</span>
                                                                                                                                                                                                                                unused96 <span class="token operator">=</span> unused97 <span class="token operator">=</span> unused98 <span class="token operator">=</span> unused99 <span class="token operator">=</span> unused100 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Error</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;stack length:&quot;</span> <span class="token operator">+</span> stackLength<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">throw</span> e<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+m+`" alt="image-20210621104016532" tabindex="0" loading="lazy"><figcaption>image-20210621104016532</figcaption></figure><p>如果是远古时代的Classic虚拟机, 这款虚拟机可以支持动态扩展栈内存的容量, 定义大量的本地变量会产生OutOfMemoryError而不是StackOverflowError异常。</p><p>结果表明：<strong>无论是由于栈帧太大还是虚拟机栈容量太小, 当新的栈帧内存无法分配的时候, HotSpot虚拟机抛出的都是StackOverflowError异常</strong>。</p><h2 id="方法区和运行时常量池溢出" tabindex="-1"><a class="header-anchor" href="#方法区和运行时常量池溢出" aria-hidden="true">#</a> 方法区和运行时常量池溢出</h2><p>方法区的主要职责是用于存放类型的相关信息, 如类名、访问修饰符、常量池、字段描述、方法描述等。对于这部分区域的测试, 基本的思路是运行时产大量的类去填满方法区, 直到溢出为止。</p><p>直接使用Java SE API也可以动态产生类(如反射时的GeneratedConstructorAccessor和动态代理等)</p><p>借助CGLib使得方法区出现内存溢出异常：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * VM Args：-XX:PermSize=10M -XX:MaxPermSize=10M
 * <span class="token keyword">@author</span> zzm
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JavaMethodAreaOOM</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Enhancer</span> enhancer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Enhancer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            enhancer<span class="token punctuation">.</span><span class="token function">setSuperclass</span><span class="token punctuation">(</span><span class="token class-name">OOMObject</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            enhancer<span class="token punctuation">.</span><span class="token function">setUseCache</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            enhancer<span class="token punctuation">.</span><span class="token function">setCallback</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MethodInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">intercept</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">,</span> <span class="token class-name">MethodProxy</span> proxy<span class="token punctuation">)</span> <span class="token keyword">throws</span>
                    <span class="token keyword">return</span> proxy<span class="token punctuation">.</span><span class="token function">invokeSuper</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            enhancer<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">OOMObject</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>在JDK7的环境中测试</strong>：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Caused</span> by<span class="token operator">:</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>OutOfMemoryError</span><span class="token operator">:</span> <span class="token class-name">PermGen</span> space
    at <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>ClassLoader</span><span class="token punctuation">.</span><span class="token function">defineClass1</span><span class="token punctuation">(</span><span class="token class-name">Native</span> <span class="token class-name">Method</span><span class="token punctuation">)</span>
    at <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>ClassLoader</span><span class="token punctuation">.</span><span class="token function">defineClassCond</span><span class="token punctuation">(</span><span class="token class-name">ClassLoader</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">632</span><span class="token punctuation">)</span>
    at <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>ClassLoader</span><span class="token punctuation">.</span><span class="token function">defineClass</span><span class="token punctuation">(</span><span class="token class-name">ClassLoader</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">616</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token number">8</span> more
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方法区溢出也是一种常见的内存溢出异常, 一个类如果要被垃圾收集器回收, 要达成的条件是比较苛刻的</strong>。</p><p>在经常运行时生成大量动态类的应用场景里, 就应该特别关注这些类的回收状况。这类场景除了之前提到的程序使用了<strong>CGLib字节码增强</strong>和动态语言外, 常见的还有：**大量JSP或动态产生JSP文件的应用(JSP第一次运行时需要编译为Java类)**等。</p><p><strong>在JDK 8以后, 元空间替代永久代。在默认设置下, 很难再迫使虚拟机产生方法区的溢出异常了</strong>。不过HotSpot还是提供了一些参数作为元空间的防御措施, 主要包括：</p><ul><li><code>-XX：MaxMetaspaceSize</code>：设置元空间最大值, 默认是-1, 即不限制, 或者说只受限于本地内存大小。</li><li><code>-XX：MetaspaceSize</code>：指定元空间的初始空间大小, 以字节为单位, 达到该值就会触发垃圾收集进行类型卸载, 同时收集器会对该值进行调整：如果释放了大量的空间, 就适当降低该值；如果释放了很少的空间, 那么在不超过-XX：MaxMetaspaceSize(如果设置了的话)的情况下, 适当提高该值。</li><li><code>-XX：MinMetaspaceFreeRatio</code>：作用是在垃圾收集之后控制最小的元空间剩余容量的百分比, 可减少因为元空间不足导致的垃圾收集的频率。类似的还有<code>-XX：Max-MetaspaceFreeRatio</code>, 用于控制最大的元空间剩余容量的百分比。</li></ul><h2 id="本机直接内存溢出" tabindex="-1"><a class="header-anchor" href="#本机直接内存溢出" aria-hidden="true">#</a> 本机直接内存溢出</h2><p>直接内存(Direct Memory)的容量大小可通过<code>-XX：MaxDirectMemorySize</code>参数来指定, 如果不去指定, 则默认与Java堆最大值(由-Xmx指定)一致。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Exception</span> in thread <span class="token string">&quot;main&quot;</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>OutOfMemoryError</span>
    at <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>Unsafe</span><span class="token punctuation">.</span><span class="token function">allocateMemory</span><span class="token punctuation">(</span><span class="token class-name">Native</span> <span class="token class-name">Method</span><span class="token punctuation">)</span>
    at org<span class="token punctuation">.</span>fenixsoft<span class="token punctuation">.</span>oom<span class="token punctuation">.</span><span class="token constant">DMOOM</span><span class="token punctuation">.</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token constant">DMOOM</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">20</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由直接内存导致的内存溢出, 一个明显的特征是在Heap Dump文件中不会看见有什么明显的异常情况, 如果读者发现内存溢出之后产生的Dump文件很小, 而程序中又直接或间接使用了DirectMemory(典型的间接使用就是NIO), 那就可以考虑重点检查一下直接内存方面的原因了</p><h2 id="内存溢出和内存泄露" tabindex="-1"><a class="header-anchor" href="#内存溢出和内存泄露" aria-hidden="true">#</a> 内存溢出和内存泄露</h2><p>1、内存泄漏memory leak :</p><p>是指程序在申请内存后, 无法释放已申请的内存空间, 一次内存泄漏似乎不会有大的影响, 但内存泄漏堆积后的后果就是内存溢出。</p><p>2、内存溢出 out of memory :</p><p>指程序申请内存时, 没有足够的内存供申请者使用, 或者说, 给了你一块存储int类型数据的存储空间, 但是你却存储long类型的数据, 那么结果就是内存不够用, 此时就会报错OOM, 即所谓的内存溢出。</p>`,145),E={href:"https://www.php.cn/java/base/482400.html",target:"_blank",rel:"noopener noreferrer"},P=t(`<h1 id="string类和常量池" tabindex="-1"><a class="header-anchor" href="#string类和常量池" aria-hidden="true">#</a> String类和常量池</h1><h2 id="string-类和常量池" tabindex="-1"><a class="header-anchor" href="#string-类和常量池" aria-hidden="true">#</a> String 类和常量池</h2><p><strong>String 对象的两种创建方式：</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">String</span> str1 <span class="token operator">=</span> <span class="token string">&quot;abcd&quot;</span><span class="token punctuation">;</span><span class="token comment">//先检查字符串常量池中有没有&quot;abcd&quot;, 如果字符串常量池中没有, 则创建一个, 然后 str1 指向字符串常量池中的对象, 如果有, 则直接将 str1 指向&quot;abcd&quot;&quot;；</span>
<span class="token class-name">String</span> str2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;abcd&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//堆中创建一个新的对象</span>
<span class="token class-name">String</span> str3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;abcd&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//堆中创建一个新的对象</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1<span class="token operator">==</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//false</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str2<span class="token operator">==</span>str3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//false</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这两种不同的创建方法是有差别的。</p><ul><li>第一种方式是在常量池中拿对象；</li><li>第二种方式是直接在堆内存空间创建一个新的对象。</li></ul><p>记住一点：<strong>只要使用 new 方法, 便需要创建新的对象。</strong></p><figure><img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java内存区域/2019-3String-Pool-Java1-450x249.png" alt="String-Pool-Java" tabindex="0" loading="lazy"><figcaption>String-Pool-Java</figcaption></figure><p><strong>String 类型的常量池比较特殊。它的主要使用方法有两种：</strong></p><ol><li>直接使用双引号声明出来的 String 对象会直接存储在常量池中。</li><li>如果不是用双引号声明的 String 对象, 可以使用 String 提供的 <code>intern()</code> 方法。<code>String.intern()</code> 是一个 Native 方法, 它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串, 则返回常量池中该字符串的引用；如果没有, JDK1.7 之前(不包含 1.7)的处理方式是在常量池中创建与此 String 内容相同的字符串, 并返回常量池中创建的字符串的引用, JDK1.7 以及之后的处理方式是在常量池中记录此字符串的引用, 并返回该引用。</li></ol><blockquote><p>在JDK 6中, intern()方法会把首次遇到的字符串实例复制到永久代的字符串常量池中存储, 返回的也是永久代里面这个字符串实例的引用。</p><p>JDK 7(以及部分其他虚拟机, 例如JRockit)的intern()方法实现就不需要再拷贝字符串的实例到永久代了, 既然字符串常量池已经移到Java堆中, 那只需要在常量池里记录一下首次出现的实例引用即可。</p></blockquote><p>JDK8 :</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token string">&quot;计算机&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> s3 <span class="token operator">=</span> <span class="token string">&quot;计算机&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//计算机</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//true</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s3 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//true, 因为两个都是常量池中的 String 对象</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>字符串拼接:</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">String</span> str1 <span class="token operator">=</span> <span class="token string">&quot;str&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> str2 <span class="token operator">=</span> <span class="token string">&quot;ing&quot;</span><span class="token punctuation">;</span>

<span class="token class-name">String</span> str3 <span class="token operator">=</span> <span class="token string">&quot;str&quot;</span> <span class="token operator">+</span> <span class="token string">&quot;ing&quot;</span><span class="token punctuation">;</span><span class="token comment">//常量池中的对象</span>
<span class="token class-name">String</span> str4 <span class="token operator">=</span> str1 <span class="token operator">+</span> str2<span class="token punctuation">;</span> <span class="token comment">//在堆上创建的新的对象</span>
<span class="token class-name">String</span> str5 <span class="token operator">=</span> <span class="token string">&quot;string&quot;</span><span class="token punctuation">;</span><span class="token comment">//常量池中的对象</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str3 <span class="token operator">==</span> str4<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//false</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str3 <span class="token operator">==</span> str5<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//true</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str4 <span class="token operator">==</span> str5<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//false</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java内存区域/字符串拼接-常量池2.png" alt="字符串拼接" tabindex="0" loading="lazy"><figcaption>字符串拼接</figcaption></figure><p>尽量避免多个字符串拼接, 因为这样会重新创建对象。如果需要改变字符串的话, 可以使用 StringBuilder 或者 StringBuffer。</p><h2 id="string-s1-new-string-abc-这句话创建了几个字符串对象" tabindex="-1"><a class="header-anchor" href="#string-s1-new-string-abc-这句话创建了几个字符串对象" aria-hidden="true">#</a> <code>String s1 = new String(&quot;abc&quot;);</code>这句话创建了几个字符串对象？</h2><p><strong>将创建 1 或 2 个字符串。如果池中已存在字符串常量&quot;abc&quot;, 则只会在堆空间创建一个字符串常量&quot;abc&quot;。如果池中没有字符串常量&quot;abc&quot;, 那么它将首先在池中创建, 然后在堆空间中创建, 因此将创建总共 2 个字符串对象。</strong></p><p><strong>验证：</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;abc&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 堆内存的地址值</span>
<span class="token class-name">String</span> s2 <span class="token operator">=</span> <span class="token string">&quot;abc&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 输出 false,因为一个是堆内存, 一个是常量池的内存, 故两者是不同的。</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 输出 true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>结果：</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>false
true
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_8种基本类型的包装类和常量池" tabindex="-1"><a class="header-anchor" href="#_8种基本类型的包装类和常量池" aria-hidden="true">#</a> 8种基本类型的包装类和常量池</h2>`,24),X=n("strong",null,"Java 基本类型的包装类的大部分都实现了常量池技术, 即 Byte,Short,Integer,Long,Character,Boolean；前面 4 种包装类默认创建了数值[-128, 127] 的相应类型的缓存数据, Character 创建了数值在[0,127]范围的缓存数据, Boolean 直接返回 True Or False。如果超出对应范围仍然会去创建新的对象。",-1),D={href:"https://github.com/Snailclimb/JavaGuide/issues/461",target:"_blank",rel:"noopener noreferrer"},I=t(`<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Boolean</span> <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>b <span class="token operator">?</span> <span class="token constant">TRUE</span> <span class="token operator">:</span> <span class="token constant">FALSE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">CharacterCache</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">CharacterCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Character</span> cache<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Character</span><span class="token punctuation">[</span><span class="token number">127</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cache<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            cache<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Character</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Integer</span> i1 <span class="token operator">=</span> <span class="token number">33</span><span class="token punctuation">;</span>
<span class="token class-name">Integer</span> i2 <span class="token operator">=</span> <span class="token number">33</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i1 <span class="token operator">==</span> i2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 输出 true</span>
<span class="token class-name">Integer</span> i11 <span class="token operator">=</span> <span class="token number">333</span><span class="token punctuation">;</span>
<span class="token class-name">Integer</span> i22 <span class="token operator">=</span> <span class="token number">333</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i11 <span class="token operator">==</span> i22<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 输出 false</span>
<span class="token class-name">Double</span> i3 <span class="token operator">=</span> <span class="token number">1.2</span><span class="token punctuation">;</span>
<span class="token class-name">Double</span> i4 <span class="token operator">=</span> <span class="token number">1.2</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i3 <span class="token operator">==</span> i4<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 输出 false</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Integer 缓存源代码：</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
*此方法将始终缓存-128 到 127(包括端点)范围内的值, 并可以缓存此范围之外的其他值。
*/</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Integer</span> <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;=</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>low <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;=</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>high<span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>cache<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>low<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>应用场景：</strong></p><ol><li><code>Integer i1=40</code>；Java 在编译的时候会直接将代码封装成 <code>Integer i1=Integer.valueOf(40);</code>, 从而使用常量池中的对象。</li><li><code>Integer i1 = new Integer(40);</code>这种情况下会创建新的对象。</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>  <span class="token class-name">Integer</span> i1 <span class="token operator">=</span> <span class="token number">40</span><span class="token punctuation">;</span>
  <span class="token class-name">Integer</span> i2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i1<span class="token operator">==</span>i2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//输出 false</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Integer 比较更丰富的一个例子:</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>  <span class="token class-name">Integer</span> i1 <span class="token operator">=</span> <span class="token number">40</span><span class="token punctuation">;</span>
  <span class="token class-name">Integer</span> i2 <span class="token operator">=</span> <span class="token number">40</span><span class="token punctuation">;</span>
  <span class="token class-name">Integer</span> i3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token class-name">Integer</span> i4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">Integer</span> i5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">Integer</span> i6 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;i1=i2   &quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i1 <span class="token operator">==</span> i2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;i1=i2+i3   &quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i1 <span class="token operator">==</span> i2 <span class="token operator">+</span> i3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;i1=i4   &quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i1 <span class="token operator">==</span> i4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;i4=i5   &quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i4 <span class="token operator">==</span> i5<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;i4=i5+i6   &quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i4 <span class="token operator">==</span> i5 <span class="token operator">+</span> i6<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;40=i5+i6   &quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">40</span> <span class="token operator">==</span> i5 <span class="token operator">+</span> i6<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>i1=i2   true
i1=i2+i3   true
i1=i4   false
i4=i5   false
i4=i5+i6   true
40=i5+i6   true
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解释：</p><p>语句 <code>i4 == i5 + i6</code>, 因为+这个操作符不适用于 Integer 对象, 首先 i5 和 i6 进行自动拆箱操作, 进行数值相加, 即 i4 == 40。然后 Integer 对象无法与数值进行直接比较, 所以 i4 自动拆箱转为 int 值 40, 最终这条语句转为 40 == 40 进行数值比较。</p><h1 id="垃圾回收机制" tabindex="-1"><a class="header-anchor" href="#垃圾回收机制" aria-hidden="true">#</a> 垃圾回收机制</h1><h2 id="为什么需要了解垃圾回收机制" tabindex="-1"><a class="header-anchor" href="#为什么需要了解垃圾回收机制" aria-hidden="true">#</a> <strong>为什么需要了解垃圾回收机制</strong>？</h2><p>当需要排查各种内存溢出、内存泄漏问题时, 当垃圾收集成为系统达到更高并发量的瓶颈时, 我们就必须对这些&quot;自动化&quot;的技术实施必要的监控和调节。</p><h2 id="哪些区域需要垃圾回收" tabindex="-1"><a class="header-anchor" href="#哪些区域需要垃圾回收" aria-hidden="true">#</a> <strong>哪些区域需要垃圾回收</strong>？</h2><p>程序计数器、虚拟机栈和本地方法栈同线程生命周期一致, 方法/线程技结束, 内存直接回收, 无需过多考虑。</p><p><strong>堆和方法区有着不确定性</strong>：一个接口多个实现类所需内存不一样, 一个方法不同的条件和分支所需内存也可能不一样。只有在运行期间才知道程序会创建哪些对象、多少个对象。这部分内存分配和回收是动态, 所以需要关注内存的分配与回收。</p><h2 id="如何判断对象需要被回收" tabindex="-1"><a class="header-anchor" href="#如何判断对象需要被回收" aria-hidden="true">#</a> 如何判断对象需要被回收？</h2><h3 id="引用计数算法" tabindex="-1"><a class="header-anchor" href="#引用计数算法" aria-hidden="true">#</a> 引用计数算法</h3><blockquote><p>给对象中添加一个引用计数器, 每当有一个地方引用它, 计数器就加 1；当引用失效, 计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。</p></blockquote><p><strong>这个方法实现简单, 效率高, 但是目前主流的虚拟机中并没有选择这个算法来管理内存, 其最主要的原因是它很难解决对象之间相互循环引用的问题。</strong></p><blockquote><p>对象objA和objB都有字段<code>instance</code>, 赋值令 <code>objA.instance=objB</code> 及 <code>objB.instance=objA</code> , 除此之外, 这两个对象再无任何引用, 实际上这两个对象已经不可能再被访问, 但是它们因为互相引用着对方, 导致它们的引用计数都不为零, 引用计数算法也就无法回收它们。</p></blockquote><h3 id="可达性分析算法" tabindex="-1"><a class="header-anchor" href="#可达性分析算法" aria-hidden="true">#</a> 可达性分析算法</h3><blockquote><p>通过一系列的称为 <strong>&quot;GC Roots&quot;</strong> 的对象作为起点, 从这些节点开始向下搜索, 节点所走过的路径称为引用链, 当一个对象到 GC Roots 没有任何引用链相连的话, 则证明此对象是不可用的。</p></blockquote><p>![image-20210622161600979](./images/jvm/ 可达性分析算法20210622161601.png)</p><p><strong>可作为 GC Roots 的对象</strong>：</p><ul><li><strong>在虚拟机栈(栈帧中的本地变量表)中引用的对象</strong>, 譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</li><li><strong>在方法区中类静态属性引用的对象</strong>, 譬如Java类的引用类型静态变量。</li><li><strong>在方法区中常量引用的对象</strong>, 譬如字符串常量池(String Table)里的引用。</li><li><strong>在本地方法栈中JNI(即通常所说的Native方法)引用的对象</strong>。</li><li><strong>Java虚拟机内部的引用</strong>, 如基本数据类型对应的Class对象, 一些常驻的异常对象(比如NullPointExcepiton、OutOfMemoryError)等, 还有系统类加载器。</li><li><strong>所有被同步锁(synchronized关键字)持有的对象</strong>。</li><li><strong>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</strong>。</li></ul><h3 id="利用可达性分析算法-如何判断一个对象死亡" tabindex="-1"><a class="header-anchor" href="#利用可达性分析算法-如何判断一个对象死亡" aria-hidden="true">#</a> <strong>利用可达性分析算法, 如何判断一个对象死亡</strong>？</h3><p>即使在可达性分析算法中判定为不可达的对象, 也不是&quot;非死不可&quot;的, 这时候它们暂时还处于**&quot;缓刑&quot;阶段**, 要真正宣告一个对象死亡, 至少要经历两次标记过程。</p><p>第一次标记：对象没有与<code>GC Roots</code>相连时, 判断该对象的<code>finalize</code>方法有没有被覆盖过, 或者有没有被虚拟机执行过。如果没有, 则直接被回收；如果执行过, 对象被放置进<code>F-Queue</code>队列中, 进行第二次标记。</p><p>第二次标记：如果对象在<code>finalize</code>关联上了<code>GC Roots</code>, 在队列中移除(只能关联一次)；如果没有, 被回收。</p><h2 id="java中的引用" tabindex="-1"><a class="header-anchor" href="#java中的引用" aria-hidden="true">#</a> Java中的引用</h2><p>JDK1.2 之前, Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址, 就称这块内存代表一个引用。</p><p>JDK1.2 以后, Java 对引用的概念进行了扩充, 将引用分为强引用、软引用、弱引用、虚引用四种(引用强度逐渐减弱)。</p><figure><img src="`+b+'" alt="Java四种引用的结构" tabindex="0" loading="lazy"><figcaption>Java四种引用的结构</figcaption></figure><p><strong>1、强引用</strong></p><p>强引用是最传统的&quot;引用&quot;的定义, 是指在程序代码之中普遍存在的引用赋值, 即类似<code>Objectobj=new Object()</code>这种引用关系。</p><p><strong>只要强引用还存在, 垃圾收集器永远不会回收掉被引用的对象。</strong></p><p><strong>2、软引用</strong>(<code>SoftReference</code>)</p><p>描述有些<strong>还有用但并非必需的对象</strong>。</p><p><strong>在系统将要发生内存溢出异常之前, 将会把这些对象列进回收范围进行二次回收</strong>。如果这次回收还没有足够的内存, 才会抛出内存溢出异常。</p><p><strong>3、弱引用</strong>(<code>WeakReference</code>)</p><p>描述非必需对象。<strong>被弱引用关联的对象只能生存到下一次垃圾回收之前</strong>, 垃圾收集器工作之后, 无论当前内存是否足够, 都会回收掉只被弱引用关联的对象。</p><p><strong>4、虚引用</strong>(<code>PhantomReference</code>)</p><p>这个引用存在的<strong>唯一目的就是在这个对象被收集器回收时收到一个系统通知</strong>, <strong>被虚引用关联的对象, 和其生存时间完全没关系</strong>。</p>',48),H={href:"https://blog.csdn.net/TJtulong/article/details/104879688",target:"_blank",rel:"noopener noreferrer"},T=n("p",null,[a("提到Java引用及垃圾回收机制, 当我联想到了以前的一个说法, "),n("strong",null,"在链表删除一个节点的时候, 将这个节点置为null, 以方便下次垃圾回收机制删除"),a(", 这个操作是否有意义？")],-1),A=n("p",null,"通常情况下没有什么意义, 除非在特定的一些情况下：",-1),B=n("p",null,"1 同一个方法中 2 定义了一个大对象(小对象没有意义) 3 之后跟着一个非常耗时的操作. 4 没有满足JIT编译条件",-1),L=n("p",null,"上面4个条件缺一不可,把obj显式设置成null才是有意义的。",-1),N=n("p",null,"参考：",-1),z={href:"https://www.itranslater.com/qa/details/2126692746223158272",target:"_blank",rel:"noopener noreferrer"},K={href:"https://blog.csdn.net/qq_42945742/article/details/84107531",target:"_blank",rel:"noopener noreferrer"},F=t('<h2 id="方法区的回收" tabindex="-1"><a class="header-anchor" href="#方法区的回收" aria-hidden="true">#</a> 方法区的回收</h2><p>《Java虚拟机规范》中提到过可以不要求虚拟机在方法区中实现垃圾收集。</p><p>方法区垃圾收集的&quot;性价比&quot;通常也是比较低的：在Java堆中, 尤其是在新生代中, 对常规应用进行一次垃圾收集通常可以回收70%至99%的内存空间, 相比之下, 方法区回收囿于苛刻的判定条件, 其区域垃圾收集的回收成果往往远低于此。</p><p><strong>方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型</strong>。</p><blockquote><p>举个常量池中字面量回收的例子, 假如一个字符串&quot;java&quot;曾经进入常量池中, 但是当前系统又没有任何一个字符串对象的值是&quot;java&quot;, 换句话说, 已经没有任何字符串对象引用常量池中的&quot;java&quot;常量, 且虚拟机中也没有其他地方引用这个字面量。如果在这时发生内存回收, 而且 垃圾收集器判断确有必要的话, 这个&quot;java&quot;常量就将会被系统清理出常量池。常量池中其他类(接口)、方法、字段的符号引用也与此似。</p></blockquote><p>判定一个常量是否&quot;废弃&quot;还是相对简单, 而要判定一个类型是否属于&quot;不再被使用的类&quot;的条件就比较苛刻了。需要同时满足下面三个条件：</p><ul><li>该类所有的实例都已经被回收, 也就是Java堆中不存在该类及其任何派生子类的实例。</li><li>加载该类的类加载器已经被回收, 这个条件除非是经过精心设计的可替换类加载器的场景, 如OSGi、JSP的重加载等, 否则通常是很难达成的。</li><li>·该类对应的java.lang.Class对象没有在任何地方被引用, 无法在任何地方通过反射访问该类的方法。</li></ul><p><strong>在大量使用反射、动态代理、CGLib等字节码框架, 动态生成JSP以及OSGi这类频繁自定义类加载器的场景中, 通常都需要Java虚拟机具备类型卸载的能力, 以保证不会对方法区造成过大的内存压力</strong>。</p><h2 id="垃圾回收算法" tabindex="-1"><a class="header-anchor" href="#垃圾回收算法" aria-hidden="true">#</a> 垃圾回收算法</h2><h3 id="分代收集理论" tabindex="-1"><a class="header-anchor" href="#分代收集理论" aria-hidden="true">#</a> 分代收集理论</h3><p>建立在两个分代假说之上：</p><p>1)<strong>弱分代假说(Weak Generational Hypothesis)：绝大多数对象都是朝生夕灭的</strong>。</p><p>2)<strong>强分代假说(Strong Generational Hypothesis)：熬过越多次垃圾收集过程的对象就越难以消亡</strong>。</p><p>收集器应该将Java堆划分出不同的区域, 然后将回收对象依据其年龄(年龄即对象熬过垃圾收集过程的次数)分配到不同的区域之中存储。</p><p>因为对象之间会存在跨代引用, 进行一次Minor GC, 但新生代对象可能被老年代引用, 不得不在GC Roots之外再遍历老年代确保可达性分析的正确性, 反之一样。可能会给内存回收带来很大的性能负担。</p><p><strong>跨代引用假说(Intergenerational Reference Hypothesis)：跨代引用相对于同代引用来说仅占极少数</strong>。隐含推论：存在互相引用关系的两个对象, 是应该倾向于同时生存或者同时消亡的。</p><p>需在新生代上建立一个全局的数据结构, 把老年代划分成若干小块, 标识出老年代的哪一块内存会存在跨代引用, 可以缩小扫描范围。</p><h3 id="垃圾回收类型" tabindex="-1"><a class="header-anchor" href="#垃圾回收类型" aria-hidden="true">#</a> 垃圾回收类型</h3><ul><li>部分收集(Partial GC)：指目标不是完整收集整个Java堆的垃圾收集, 其中又分为： <ul><li>新生代收集(Minor GC/Young GC)：指目标只是新生代的垃圾收集。</li><li>老年代收集(Major GC/Old GC)：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。另外请注意&quot;Major GC&quot;这个说法现在有点混淆, 在不同资料上常有不同所指, 读者需按上下文区分到底是指老年代的收集还是整堆收集。</li><li>混合收集(Mixed GC)：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。</li></ul></li><li>整堆收集(Full GC)：收集整个Java堆和方法区的垃圾收集。</li></ul><h3 id="标记-清除算法-mark-sweep" tabindex="-1"><a class="header-anchor" href="#标记-清除算法-mark-sweep" aria-hidden="true">#</a> 标记-清除算法(Mark-Sweep)</h3><p><strong>标记需回收/存活对象, 统一清除标记的对象</strong>。</p><p><strong>在CMS回收器中用于老年代</strong>。</p><p><strong>缺点</strong>：</p><ul><li><strong>执行效率不稳定</strong>。对象越多, 效率越低。</li><li><strong>内存空间的碎片化问题</strong>。</li></ul><h3 id="标记-复制算法-mark-copying" tabindex="-1"><a class="header-anchor" href="#标记-复制算法-mark-copying" aria-hidden="true">#</a> 标记-复制算法(Mark-Copying)</h3><p><strong>&quot;半区复制&quot;, 每次只用一块内存, 存活对象复制到另一块, 已经使用的那一块直接清除</strong>。</p><p>一般用于<strong>新生代</strong></p><p>优点：无内存碎片化问题。</p><p>缺点：对象存活率高时, 大量复制, 效率低。</p><h4 id="新生代eden和survivor比例问题" tabindex="-1"><a class="header-anchor" href="#新生代eden和survivor比例问题" aria-hidden="true">#</a> 新生代Eden和Survivor比例问题</h4><blockquote><p>现在的商用Java虚拟机大多都优先采用了这种收集算法去回收新生代, IBM公司曾有一项专门研究对新生代&quot;朝生夕灭&quot;的特点做了更量化的诠释——<strong>新生代中的对象有98%熬不过第一轮收集</strong>。因此并不需要按照1∶1的比例来划分新生代的内存空间。</p><p><strong>&quot;Appel式回收&quot;</strong>：Appel式回收的具体做法是把新生代分为一块较大的Eden空间和两块较小的Survivor空间, 每次分配内存只使用Eden和其中一块Survivor。<strong>发生垃圾搜集时, 将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上, 然后直接清理掉Eden和已用过的那块Survivor空间</strong>。</p></blockquote><p>Eden区是一块, Survivor区是两块。Eden区和Survivor区的比例是8：1：1。</p><p>98%的对象可被回收仅仅是&quot;普通场景&quot;下测得的数据, 任何人都没有办法百分百保证每次回收都只有不多于10%的对象存活, 因此Appel式回收还有一个充当罕见情况的&quot;逃生门&quot;的安全设计。当Survivor空间不足以容纳一次Minor GC之后存活的对象时, 就需要依赖其他内存区域(实际上大多就是老年代)进行<strong>分配担保(Handle Promotion)</strong>。</p><p><strong>如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象, 这些对象便将通过分配担保机制直接进入老年代</strong>。</p>',34),V={href:"https://blog.csdn.net/lojze_ly/article/details/49456255",target:"_blank",rel:"noopener noreferrer"},W=t('<h3 id="标记-整理算法-mark-compact" tabindex="-1"><a class="header-anchor" href="#标记-整理算法-mark-compact" aria-hidden="true">#</a> 标记-整理算法(Mark-Compact)</h3><p>标记存活对象, 让所有存活对象移动到一端, 然后清理所有的边界以外的内存。</p><p>一般用于<strong>老年代</strong>。</p><p><strong>是否移动对象都有弊端, 移动内存回收比较复杂, 不移动内存分配比较复杂(空间碎片化)</strong>。</p><p>一种方案：<strong>虚拟机平时采用标记-清除算法, 暂时容忍碎片存在, 直到碎片影响大到内存分配时, 在进行标记-整理算法, 可获得规整的内存空间</strong>。</p>',5),U=n("strong",null,"标记-整理算法的可回收对象与存活对象如何移动？",-1),Z={href:"https://blog.csdn.net/luliuliu1234/article/details/104058259",target:"_blank",rel:"noopener noreferrer"},Y=t('<h2 id="hotspot实现垃圾回收的算法细节-了解" tabindex="-1"><a class="header-anchor" href="#hotspot实现垃圾回收的算法细节-了解" aria-hidden="true">#</a> HotSpot实现垃圾回收的算法细节(了解)</h2><blockquote><p>了解这部分内容是很好理解垃圾回收器工作原理的前提, 但是这部分内容往往比较难以理解, 需要结合垃圾收集器反复推敲。</p><p>这部分主要讲解垃圾收集中遇到的哪些问题, 以及如何解决的？</p><p><em>简单总结, 详细内容参看：《深入理解Java虚拟机(第三版)》</em></p></blockquote><h3 id="根节点枚举" tabindex="-1"><a class="header-anchor" href="#根节点枚举" aria-hidden="true">#</a> 根节点枚举</h3><p>固定可作为GC Roots的节点主要在全局性的引用(例如常量或类静态属性)与执行上下文(例如栈帧中的本地变量表)中, 尽管目标明确, 但查找过程要做到高效并非一件容易的事情, 现在Java应用越做越庞大, 光是方法区的大小就常有数百上千兆, 里面的类、常量等更是恒河沙数, 若要逐个检查以这里为起源的引用肯定得消耗不少时间。</p><p>迄今为止, <strong>所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的</strong>, 因此毫无疑问根节点枚举与之前提及的整理内存碎片一样会面临相似的&quot;Stop The World&quot;的困扰。</p><p><strong>垃圾收集过程必须停顿所有用户线程的其中一个重要原因</strong>：</p><p>现在可达性分析算法耗时最长的查找引用链的过程已经可以做到与用户线程一起并发, 但根节点枚举始终还是必须在一个能保障一致性的快照中才得以进行——这里**&quot;一致性&quot;的意思是整个枚举期间执行子系统看起来就像被冻结在某个时间点上, 不会出现分析过程中, 根节点集合的对象引用关系还在不断变化的情况**, 若这点不能满足的话, 分析结果准确性也就无法保证。</p><p>由于目前主流Java虚拟机使用的都是<strong>准确式垃圾收集</strong>, 所以<strong>当用户线程停顿下来之后, 其实并不需要一个不漏地检查完所有执行上下文和全局的引用位置, 虚拟机应当是有办法直接得到哪些地方存放着对象引用的</strong>。</p><blockquote><p>在HotSpot的解决方案里, 使用OopMap的数据结构来达到这个目的。一旦类加载动作完成的时候, HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来, 在即时编译过程中, 也会在特定的位置记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得知这些信息了, 并不需要真正一个不漏地从方法区等GC Roots开始查找。</p></blockquote><p>总结：</p><ol><li><strong>所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的</strong></li><li><strong>在HotSpot中, 使用OopMap的数据结构可以, 当用户线程停顿下来之后, 使虚拟机直接得到哪些地方存放着对象引用, 而不需要一个不漏地检查完所有执行上下文和全局的引用位置。</strong></li><li>OopMap的目的：<strong>使HotSpot可以快速准确地完成GC Roots枚举</strong></li></ol><h3 id="安全点" tabindex="-1"><a class="header-anchor" href="#安全点" aria-hidden="true">#</a> 安全点</h3><p>在OopMap的协助下, HotSpot可以快速准确地完成GC Roots枚举, <strong>但是可能导致引用关系变化, 或者说导致OopMap内容变化的指令非常多, 如果为每一条指令都生成对应的OopMap, 那将会需要大量的额外存储空间, 成本高昂</strong>。</p><p>在&quot;特定的位置&quot;记录了这些信息, 这些位置被称为安全点(Safepoint), 有了安全点的设定, 也就决定了用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集, 而是<strong>强制要求必须执行到达安全点后才能够暂停</strong>。</p><p><strong>安全点的选定既不能太少以至于让收集器等待时间过长, 也不能太过频繁以至于过分增大运行时的内存负荷</strong>。安全点位置的选取基本上是以&quot;<strong>是否具有让程序长时间执行的特征</strong>&quot;为标准进行选定的, 因为每条指令执行的时间都非常短暂, 程序不太可能因为指令流长度太长这样的原因而长时间执行, &quot;长时间执行&quot;的最明显特征就是<strong>指令序列的复用</strong>, 例如方法调用、循环跳转、异常跳转等功能的指令才会产生安全点。</p><p>另外一个问题：<strong>如何在垃圾收集发生时让所有线程(这里其实不包括执行JNI调用的线程)都跑到最近的安全点, 然后停顿下来？</strong></p><p>这里有两种方案可供选择：抢先式中断(Preemptive Suspension)和<strong>主动式中断</strong>(Voluntary Suspension, 一般采用的方案)。</p><blockquote><p><strong>主动式中断</strong>的思想是当垃圾收集需要中断线程的时候, 不直接对线程操作, 仅仅简单地设置一个标志位, 各个线程执行过程时会不停地主动去轮询这个标志, 一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。轮询标志的地方和安全点是重合的, 另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方, 这是为了检查是否即将要发生垃圾收集, 避免没有足够内存分配新对象。</p></blockquote><p>总结：</p><ol><li>安全点的目的：<strong>在&quot;特定的位置&quot;记录OopMap需要记录的信息, 解决每一个指令生成对应OopMap的高昂存储空间问题</strong>。即<strong>解决如何停顿用户线程, 让虚拟机进入垃圾回收状态的问题</strong>。</li><li>如何选取安全点位置：以&quot;<strong>是否具有让程序长时间执行的特征</strong>&quot;为标准(即指令复用), 例如方法调用、循环跳转、异常跳转等功能的指令才会产生安全点。</li><li>如何使垃圾收集时线程跑到最近的安全点：<strong>主动式中断</strong>。</li></ol><h3 id="安全区域" tabindex="-1"><a class="header-anchor" href="#安全区域" aria-hidden="true">#</a> 安全区域</h3><p>使用安全点的设计似乎已经完美解决如何停顿用户线程, 让虚拟机进入垃圾回收状态的问题了。安全点机制保证了程序执行时, 在不太长的时间内就会遇到可进入垃圾收集过程的安全点。但是, <strong>程序&quot;不执行&quot;的时候呢？<strong>所谓的程序不执行就是</strong>没有分配处理器时间</strong>, 典型的场景便是<em><strong>用户线程处于Sleep状态或者Blocked状态, 这时候线程无法响应虚拟机的中断请求, 不能再走到安全的地方去中断挂起自己, 虚拟机也显然不可能持续等待线程重新被激活分配处理器时间</strong></em>。对于这种情况, 就必须引入安全区域(Safe Region)来解决。</p><p><strong>安全区域是指能够确保在某一段代码片段之中, 引用关系不会发生变化</strong>, 因此, 在这个区域中任意地方开始垃圾收集都是安全的。我们也可以把安全区域看作被扩展拉伸了的安全点。</p><blockquote><p>流程：</p><p>当用户线程执行到安全区域里面的代码时, 首先会标识自己已经进入了安全区域, 那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。</p><p>当线程要离开安全区域时, 它要检查虚拟机是否已经完成了根节点枚举(或者垃圾收集过程中其他需要暂停用户线程的 阶段), 如果完成了, 那线程就当作没事发生过, 继续执行；否则它就必须一直等待, 直到收到可以离开安全区域的信号为止。</p></blockquote><p>总结：</p><ol><li>引入安全区域的目的：<strong>解决程序不执行时(没有分配处理器时间), 线程无法响应虚拟机的中断请求挂起自己的问题</strong>。</li><li><strong>安全区域是指能够确保在某一段代码片段之中, 引用关系不会发生变化, 保证在这个区域中任意地方开始垃圾收集都是安全的。</strong></li></ol><h3 id="记忆集与卡表" tabindex="-1"><a class="header-anchor" href="#记忆集与卡表" aria-hidden="true">#</a> 记忆集与卡表</h3><p>垃圾收集器<strong>在新生代中建立了名为记忆集</strong>(Remembered Set)的数据结构, 用以<strong>避免把整个老年代加进GC Roots扫描范围</strong>。</p><p>记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构, 卡表是其实现。</p><h3 id="写屏障" tabindex="-1"><a class="header-anchor" href="#写屏障" aria-hidden="true">#</a> 写屏障</h3><p>记忆集来缩减GC Roots扫描范围的问题, 但还没有<strong>解决卡表元素如何维护的问题, 例如它们何时变脏、谁来把它们变脏等</strong>, 使用写屏障。</p><h3 id="并发的可达性分析" tabindex="-1"><a class="header-anchor" href="#并发的可达性分析" aria-hidden="true">#</a> 并发的可达性分析</h3><p>可达性分析算法理论上要求全过程都基于一个能保障一致性的快照中才能够进行分析, 这意味着必须全程冻结用户线程的运行。</p><p>根节点枚举 在各种优化下时间固定, 但是&quot;标记&quot;阶段, 也就是<strong>GC Roots再继续往下遍历对象图时, 停顿时间就必定会与Java堆容量直接成正比例关系</strong>。如果这个阶段会随着堆变大而等比例增加停顿时间, 其影响就会波及几乎所有的垃圾收集器。</p><p>使用并发扫描可以, 大大提升&quot;标记&quot;阶段的速度, 但是可能存在<strong>对象消失问题</strong>。</p><p>解决：CMS是基于增量更新来做并发标记的, G1、Shenandoah则是用原始快照来实现。</p><p>这部分详细参看：《深入理解Java虚拟机(第三版)》</p><h2 id="young-gc-和-full-gc-在什么情况下触发" tabindex="-1"><a class="header-anchor" href="#young-gc-和-full-gc-在什么情况下触发" aria-hidden="true">#</a> Young GC 和 Full GC 在什么情况下触发？</h2><ul><li>Minor GC：新生代的 GC</li><li>Major GC：老年代的 GC</li><li>Full GC：整堆收集, 收集整个 Java 堆和方法区的垃圾收集</li></ul><p>对象优先在新生代Eden区中分配, 如果Eden区没有足够的空间时, 就会触发一次young gc</p><p>Full gc的触发条件有多个, FULL GC的时候会STOP THE WORLD。</p><ul><li><p>在执行Young gc之前, JVM会进行空间分配担保——如果老年代的连续空间小于新生代对象的总大小(或历次晋升的平均大小), 则触发一次full gc。如果大于历次晋升的平均大小, 那么会进行一次Minor GC, 尽管这次Minor GC是有风险的。</p></li><li><p>显式调用System.gc()方法时, 系统建议执行, 不是必然执行；</p></li><li><p>老年代空间不足</p></li><li><p>方法区(元空间)空间不足</p></li></ul><h2 id="三色标记法" tabindex="-1"><a class="header-anchor" href="#三色标记法" aria-hidden="true">#</a> 三色标记法</h2><h3 id="三色标记原理" tabindex="-1"><a class="header-anchor" href="#三色标记原理" aria-hidden="true">#</a> 三色标记原理</h3><p>颜色含义：</p><ul><li>白色：还没有搜索过的对象(标记结束后, 白色对象会被当成垃圾对象)</li><li>灰色：正在搜索的对象</li><li>黑色：搜索完成的对象(不会当成垃圾对象, 不会被GC)</li></ul><p>假设现在有白、灰、黑三个集合(表示当前对象的颜色), 其遍历访问过程为：</p><ol><li>初始时, 所有对象都在【白色集合】中；</li><li>将 GC Roots 直接引用到的对象挪到 【灰色集合】中；</li><li>从灰色集合中获取对象： 3.1. 将本对象引用到的其他对象全部挪到 【灰色集合】中； 3.2. 将本对象挪到【黑色集合】里面。</li><li>重复步骤3, 直至【灰色集合】为空时结束。</li><li>结束后, 仍在【白色集合】的对象即为 GC Roots 不可达, 可以进行回收。</li></ol><blockquote><p>注：如果标记结束后对象仍为白色, 意味着已经&quot;找不到&quot;该对象在哪了, 不可能会再被重新引用。</p></blockquote><figure><img src="'+f+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>当 Stop The World (以下简称 STW)时, 对象间的引用是不会发生变化的, 可以轻松完成标记。</p><p>而当需要支持并发标记时, 即标记期间应用线程还在继续跑, 对象间的引用可能发生变化, 多标和漏标的情况就有可能发生。</p><h3 id="多标——浮动垃圾" tabindex="-1"><a class="header-anchor" href="#多标——浮动垃圾" aria-hidden="true">#</a> 多标——浮动垃圾</h3><p>假设已经遍历到 E(变为灰色了), 此时应用执行了 objD.fieldE = null (D &gt; E 的引用断开)：</p><figure><img src="'+S+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>此刻之后, 对象 E/F/G 是&quot;应该&quot;被回收的。然而因为 E 已经变为灰色了, 其仍会被当作存活对象继续遍历下去。最终的结果是：这部分对象仍会被标记为存活, 即本轮 GC 不会回收这部分内存。</p><p>这部分本应该回收 但是没有回收到的内存, 被称之为&quot;浮动垃圾&quot;。浮动垃圾并不会影响应用程序的正确性, 只是需要等到下一轮垃圾回收中才被清除。</p><p>另外, 针对并发标记开始后的新对象, 通常的做法是直接全部当成黑色, 本轮不会进行清除。这部分对象期间可能会变为垃圾, 这也算是浮动垃圾的一部分。</p><h3 id="漏标-读写屏障" tabindex="-1"><a class="header-anchor" href="#漏标-读写屏障" aria-hidden="true">#</a> 漏标-读写屏障</h3><p>假设 GC 线程已经遍历到 E(变为灰色了), 此时应用线程先执行了：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>var G = objE.fieldG; 
objE.fieldG = null;  // 灰色E 断开引用 白色G 
objD.fieldG = G;  // 黑色D 引用 白色G
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+q+`" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>此时切回 GC 线程继续跑, 因为 E 已经没有对 G 的引用了, 所以不会将 G 放到灰色集合；尽管因为 D 重新引用了 G, 但因为 D 已经是黑色了, 不会再重新做遍历处理。</p><p>最终导致的结果是：G 会一直停留在白色集合中, 最后被当作垃圾进行清除。这直接影响到了应用程序的正确性, 是不可接受的。</p><p>不难分析, 漏标只有同时满足以下两个条件时才会发生：</p><ol><li>灰色对象断开了白色对象的引用(直接或间接的引用)；即灰色对象原来成员变量的引用发生了变化。</li><li>黑色对象重新引用了该白色对象；即黑色对象成员变量增加了新的引用。</li></ol><p>从代码的角度看：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>var G = objE.fieldG; // 1.读
objE.fieldG = null;  // 2.写
objD.fieldG = G;     // 3.写
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>读取对象 E 的成员变量 fieldG 的引用值, 即对象 G；</li><li>对象 E 往其成员变量 fieldG, 写入 null值。</li><li>对象 D 往其成员变量 fieldG, 写入对象 G ；</li></ol><p>我们只要在上面这三步中的任意一步中做一些&quot;手脚&quot;, 将对象 G 记录起来, 然后作为灰色对象再进行遍历即可。比如放到一个特定的集合, 等初始的 GC Roots 遍历完(并发标记), 该集合的对象遍历即可(重新标记)。</p><blockquote><p>重新标记是需要 STW 的, 因为应用程序一直在跑的话, 该集合可能会一直增加新的对象, 导致永远都跑不完。当然, 并发标记期间也可以将该集合中的大部分先跑了, 从而缩短重新标记 STW 的时间, 这个是优化问题了。</p></blockquote><p>写屏障用于拦截第二和第三步；而读屏障则是拦截第一步。它们的拦截的目的很简单：就是在读写前后, 将对象 G 给记录下来。</p><h3 id="写屏障-1" tabindex="-1"><a class="header-anchor" href="#写屏障-1" aria-hidden="true">#</a> 写屏障</h3><p>给某个对象的成员变量赋值时, 其底层代码大概长这样：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>/**
* @param field 某对象的成员变量, 如 D.fieldG
* @param new_value 新值, 如 null
*/
void oop_field_store(oop* field, oop new_value) { 
    *field = new_value; // 赋值操作
} 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所谓的写屏障, 其实就是指在赋值操作前后, 加入一些处理(可以参考AOP的概念), 读屏障的含义也类似。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>void oop_field_store(oop* field, oop new_value) {  
    pre_write_barrier(field); // 写屏障-写前操作
    *field = new_value; 
    post_write_barrier(field, value);  // 写屏障-写后操作
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="写屏障-satb" tabindex="-1"><a class="header-anchor" href="#写屏障-satb" aria-hidden="true">#</a> 写屏障 + SATB</h4><p>当对象 E 的成员变量的引用发生变化时(objE.fieldG = null;), 我们可以利用写屏障, 将 E 原来成员变量的引用对象 G 记录下来：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>void pre_write_barrier(oop* field) {
    oop old_value = *field; // 获取旧值
    remark_set.add(old_value); // 记录 原来的引用对象
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当原来成员变量的引用发生变化之前, 记录下原来的引用对象。</p><p>这种做法的思路是：尝试保留开始时的对象图, 即原始快照(Snapshot At The Beginning, SATB), 当某个时刻 的 GC Roots 确定后, 当时的对象图就已经确定了。</p><p>比如 当时 D 是引用着 G 的, 那后续的标记也应该是按照这个时刻的对象图走(D 引用着 G)。如果期间发生变化, 则可以记录起来, 保证标记依然按照原本的视图来。</p><blockquote><p>SATB 破坏了条件一：【灰色对象断开了白色对象的引用】, 从而保证了不会漏标。</p></blockquote><h3 id="写屏障-增量更新" tabindex="-1"><a class="header-anchor" href="#写屏障-增量更新" aria-hidden="true">#</a> 写屏障 + 增量更新</h3><p>当对象 D 的成员变量的引用发生变化时(objD.fieldG = G;), 我们可以利用写屏障, 将 D 新的成员变量引用对象 G 记录下来：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>void post_write_barrier(oop* field, oop new_value) {  
  if($gc_phase == GC_CONCURRENT_MARK &amp;&amp; !isMarkd(field)) {
      remark_set.add(new_value); // 记录新引用的对象
  }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当有新引用插入进来时, 记录下新的引用对象。</p><p>这种做法的思路是：不要求保留原始快照, 而是针对新增的引用, 将其记录下来等待遍历, 即增量更新(Incremental Update)。</p><blockquote><p>增量更新破坏了条件二：【黑色对象重新引用了该白色对象】, 从而保证了不会漏标。</p></blockquote><h3 id="读屏障" tabindex="-1"><a class="header-anchor" href="#读屏障" aria-hidden="true">#</a> 读屏障</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>oop oop_field_load(oop* field) {
    pre_load_barrier(field); // 读屏障-读取前操作
    return *field;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>读屏障是直接针对第一步：var G = objE.fieldG;, 当读取成员变量时, 一律记录下来：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>void pre_load_barrier(oop* field, oop old_value) {  
  if($gc_phase == GC_CONCURRENT_MARK &amp;&amp; !isMarkd(field)) {
      oop old_value = *field;
      remark_set.add(old_value); // 记录读取到的对象
  }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种做法是保守的, 但也是安全的。因为条件二中【黑色对象重新引用了该白色对象】, 重新引用的前提是：得获取到该白色对象, 此时已经读屏障就发挥作用了。</p><h3 id="三色标记法与现代垃圾回收器" tabindex="-1"><a class="header-anchor" href="#三色标记法与现代垃圾回收器" aria-hidden="true">#</a> 三色标记法与现代垃圾回收器</h3><p>现代追踪式(可达性分析)的垃圾回收器几乎都借鉴了三色标记的算法思想, 尽管实现的方式不尽相同：比如白色/黑色集合一般都不会出现(但是有其他体现颜色的地方)、灰色集合可以通过栈/队列/缓存日志等方式进行实现、遍历方式可以是广度/深度遍历等等。</p><p>对于读写屏障, 以Java HotSpot VM 为例, 其并发标记时对漏标的处理方案如下：</p><ul><li>CMS：写屏障 + 增量更新</li><li>G1：写屏障 + SATB</li><li>ZGC：读屏障</li></ul>`,99),$={href:"https://www.cnblogs.com/jmcui/p/14165601.html",target:"_blank",rel:"noopener noreferrer"},Q=t('<h1 id="垃圾收集器" tabindex="-1"><a class="header-anchor" href="#垃圾收集器" aria-hidden="true">#</a> 垃圾收集器</h1><h2 id="经典的垃圾收集器" tabindex="-1"><a class="header-anchor" href="#经典的垃圾收集器" aria-hidden="true">#</a> 经典的垃圾收集器</h2><figure><img src="'+C+'" alt="垃圾收集器总结" tabindex="0" loading="lazy"><figcaption>垃圾收集器总结</figcaption></figure><p>《Java虚拟机规范》中对垃圾收集器应该如何实现并没有做出任何规定。</p><p><strong>jdk1.8默认使用ParallelGC。新生代采用的是Parallel Scavenge, 老年代Parallel Old。</strong></p><p>使用ParNew(标记复制、并行、作用于新生代) + CMS的垃圾收集器(标记清除、并行、作用于老年代), 追求响应速度优先, 其适用于多CPU环境的Server模式的互联网或者B/S业务。</p><p>如果追求吞吐量优先, 应用在后台运算并不需要太多交互场景的, 可采用Parallel(标记复制、并行、作用于新生代) + Parallel Old 的垃圾收集器(标记整理、并行、作用于老年代)</p><blockquote><p><strong>&quot;Stop The World&quot;</strong>：<strong>虚拟机在后台自动发起和自动完成的, 在用户不可知、不可控的情况下把用户的正常工作的用户线程全部停掉</strong>。这对很多应用来说都是不能接受的。</p></blockquote><h3 id="serial收集器" tabindex="-1"><a class="header-anchor" href="#serial收集器" aria-hidden="true">#</a> Serial收集器</h3><p>新生代 单线程 复制算法</p><p>优点：</p><ul><li>与其他单线程垃圾收集器相比简单高效</li><li>对于内存受限的环境, 额外内存消耗最小</li><li>对于单核或者核心数较少的环境来说, 其没有线程交互开销, 专心做垃圾收集可以获得最高的单线程收集效率</li></ul><p>使用场景：</p><p>Serial收集器对于运行在<strong>客户端模式下的虚拟机</strong>来说是一个很好的选择。</p><blockquote><p>在用户桌面的应用场景以及近年来流行的部分微服务应用中, 分配给虚拟机管理的内存一般来说并不会特别大, 收集几十兆甚至一两百兆的新生代(仅仅是指新生代使用的内存, 桌面应用甚少超过这个容量), 垃圾收集的停顿时间完全可以控制在十几、几十毫秒, 最多一 百多毫秒以内, 只要不是频繁发生收集, 这点停顿时间对许多用户来说是完全可以接受的。</p></blockquote><p>Serial/Serial Old收集器运行示意图：</p><figure><img src="'+x+'" alt="Serial/Serial Old收集器运行示意图" tabindex="0" loading="lazy"><figcaption>Serial/Serial Old收集器运行示意图</figcaption></figure><h3 id="parnew收集器" tabindex="-1"><a class="header-anchor" href="#parnew收集器" aria-hidden="true">#</a> ParNew收集器</h3><p>ParNew收集器实质上是Serial收集器的多线程并行版本。</p><p>ParNew收集器是激活CMS后(使用-XX：+UseConcMarkSweepGC选项)的默认新生代收集器。</p><p>新生代 多线程 复制算法。</p><p><strong>JDK9以前ParNew + CMS 适用于 服务端模式下的垃圾收集器组合</strong>。</p><p>ParNew/Serial Old收集器运行示意图：</p><figure><img src="'+G+'" alt="ParNew/Serial Old收集器运行示意图" tabindex="0" loading="lazy"><figcaption>ParNew/Serial Old收集器运行示意图</figcaption></figure><h3 id="parallel-scavenge收集器" tabindex="-1"><a class="header-anchor" href="#parallel-scavenge收集器" aria-hidden="true">#</a> Parallel Scavenge收集器</h3><p>新生代 多线程 复制算法</p><p>CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间, 而Parallel Scavenge收集器的目标则是<strong>达到一个可控制的吞吐</strong><strong>量</strong>(Throughput)。所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值。</p><p>停顿时间越短就越适合需要与用户交互或需要保证服务响应质量的程序, 良好的响应速度能提升用户体验；而高吞吐量则可以最高效率地利用处理器资源, 尽快完成程序的运算任务, 主要适合在后台运算而不需要太多交互的分析任务。</p><blockquote><p>Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量, 分别是控制最大垃圾收集停顿时间的<code>-XX：MaxGCPauseMillis</code>参数以及直接设置吞吐量大小的<code>XX：GCTimeRatio</code>参数。</p><p><strong>-XX：MaxGCPauseMillis参数允许的值是一个大于0的毫秒数, 收集器将尽力保证内存回收花费的时间不超过用户设定值</strong>。垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的：系统把新生代调得小一些, 收集300MB新生代肯定比收集500MB快, 但这也直接导致垃圾收集发生得更频繁, 原来10秒收集一次、每次停顿100毫秒, 现在变成5秒收集一次、每次停顿70毫秒。停顿时间的确在下降, 但吞吐量也降下来了。</p><p>-XX：GCTimeRatio参数的值则应当是一个大于0小于100的整数, 也就是垃圾收集时间占总时间的比率, 相当于吞吐量的倒数。譬如把此参数设置为19, 那允许的最大垃圾收集时间就占总时间的5%, 即1/(1+19)), 默认值为99, 即允许最大1%(即1/(1+99))的垃圾收集时间。</p></blockquote><p>Parallel Scavenge/Parallel Old收集器运行示意图：</p><figure><img src="'+M+'" alt="Parallel Scavenge/Parallel Old收集器运行示意图" tabindex="0" loading="lazy"><figcaption>Parallel Scavenge/Parallel Old收集器运行示意图</figcaption></figure><h3 id="serial-old收集器" tabindex="-1"><a class="header-anchor" href="#serial-old收集器" aria-hidden="true">#</a> Serial Old收集器</h3><p>Serial Old是Serial收集器的老年代版本。</p><p>老年代 单线程 整理算法</p><p><strong>使用场景</strong>：</p><p>这个收集器的主要意义也是供客户端模式下的HotSpot虚拟机使用。</p><p>如果在服务端模式下, 它也可能有两种用途：</p><ol><li>在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用[1],</li><li>作为CMS收集器发生失败时的后备预案, 在并发收集发生Concurrent Mode Failure时使用。</li></ol><h3 id="parallel-old收集器" tabindex="-1"><a class="header-anchor" href="#parallel-old收集器" aria-hidden="true">#</a> Parallel Old收集器</h3><p>Parallel Old是Parallel Scavenge收集器的老年代版本。</p><p>老年代 多线程 整理算法</p><p>直到Parallel Old收集器出现后, &quot;吞吐量优先&quot;收集器终于有了比较名副其实的搭配组合, <strong>在注重吞吐量或者处理器资源较为稀缺的场合, 都可以优先考虑Parallel Scavenge / Parallel Old收集器这个组合</strong>。</p><h3 id="cms收集器" tabindex="-1"><a class="header-anchor" href="#cms收集器" aria-hidden="true">#</a> CMS收集器</h3><blockquote><p><strong>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器</strong>。这是因为CMS收集器工作时, GC工作线程与用户线程可以<code>并发</code>执行, 以此来达到降低收集停顿时间的目的。</p></blockquote><p>使用场景：集中在 <strong>互联网网站或者基于浏览器的B/S系统的服务端</strong> 上, 这类应用通常都会较为关注服务的响应速度, 希望系统停顿时间尽可能短, 以给用户带来良好的交互体验。</p><p>CMS收集器仅作用于<strong>老年代</strong>的收集, 是基于<code>标记-清除算法</code>的, 它的运作过程分为4个步骤：</p><ol><li>初始标记(CMS initial mark)：仅仅只是<strong>标记一下GC Roots能直接关联到的对象</strong>, 速度很快, 需要&quot;Stop The World&quot;。</li><li>并发标记(CMS concurrent mark)：是<strong>从GC Roots的直接关联对象开始遍历整个对象图的过程</strong>, 这个过程耗时较长但是不需要停顿用户线程, 可以与垃圾收集线程一起并发运行。</li><li>重新标记(CMS remark)：为了<strong>修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</strong>, 这个阶段的停顿时间一般会比初始标记阶段稍长一些, 但远比并发标记的时间短。此阶段也需要&quot;Stop The World&quot;。</li><li>并发清除(CMS concurrent sweep)：<strong>清理删除掉标记阶段判断的已经死亡的对象</strong>。由于不需要移动存活对象, 所以这个阶段也是可以与用户线程同时并发的</li></ol><blockquote><p>CMS以流水线方式拆分了收集周期, 将耗时长的操作单元保持与应用线程并发执行。只将那些必需STW才能执行的操作单元单独拎出来, 控制这些单元在恰当的时机运行, 并能保证仅需短暂的时间就可以完成。这样, 在整个收集周期内, 只有<strong>两次短暂的暂停(初始标记和重新标记)</strong>, <strong>达到了近似并发的目的</strong>。</p></blockquote><p>由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作。所以, 从总体上来说, CMS收集器的内存回收过程是与用户线程一起并发执行的。通过下图可以比较清楚地看到CMS收集器的运作步骤中并发和需要停顿的时间：</p><figure><img src="'+y+`" alt="Concurrent Mark Sweep收集器运行示意图" tabindex="0" loading="lazy"><figcaption>Concurrent Mark Sweep收集器运行示意图</figcaption></figure><p>CMS收集器<strong>优点</strong>：并发收集、低停顿。</p><p>CMS收集器<strong>缺点</strong>：</p><ul><li><strong>CMS收集器对CPU资源非常敏感</strong>。面向并发设计的程序都对CPU资源比较敏感。在并发阶段, 它虽然不会导致用户线程停顿, 但会因为占用了一部分线程(或者说CPU资源)而导致应用程序变慢, 总吞吐量会降低。</li><li><strong>CMS收集器无法处理浮动垃圾(Floating Garbage)</strong>。 <ul><li>由于CMS并发清理阶段用户线程还在运行着, 伴随程序运行自然就还会有新的垃圾不断产生。这一部分垃圾出现在标记过程之后, CMS无法再当次收集中处理掉它们, 只好留待下一次GC时再清理掉。</li><li>这一部分垃圾就被称为&quot;浮动垃圾&quot;。也是由于在垃圾收集阶段用户线程还需要运行, 那也就还需要预留有足够的内存空间给用户线程使用, 因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集, 需要预留一部分空间提供并发收集时的程序运作使用。</li></ul></li><li><strong>CMS收集器是基于标记-清除算法, 收集结束时可能存在大量空间碎片</strong>。碎片过多时, 将会给大对象分配带来很大麻烦, 往往出现老年代空间剩余, 但无法找到足够大连续空间来分配当前对象(所以未提供CMS的新生代版本)。</li></ul><h3 id="garbage-first收集器-g1" tabindex="-1"><a class="header-anchor" href="#garbage-first收集器-g1" aria-hidden="true">#</a> Garbage First收集器 (G1)</h3><h4 id="g1简介" tabindex="-1"><a class="header-anchor" href="#g1简介" aria-hidden="true">#</a> G1简介</h4><p>Garbage First(简称G1)收集器是垃圾收集器技术发展历史上的里程碑式的成果, 它开创了<strong>收集器面向局部收集的设计思路</strong>和<strong>基于Region的内存布局形式</strong>。</p><p>G1是一款主要面向服务端应用的垃圾收集器。</p><p>G1 GC切分堆内存为多个区间(Region), 从而避免很多GC操作在整个Java堆或者整个年轻代进行。G1 GC只关注你有没有存货对象, 都会被回收并放入可用的Region队列。G1 GC是基于Region的GC, <strong>适用于大内存机器。即使内存很大, Region扫描, 性能还是很高的</strong>。</p><blockquote><p>JDK 9发布之日, G1宣告取代Parallel Scavenge加Parallel Old组合, 成为服务端模式下的默认垃圾收集器, 而CMS则沦落至被声明为不推荐使用(Deprecate)的收集器。如果对JDK 9及以上版本的HotSpot虚拟机使用参数 <code>-XX：+UseConcMarkSweepGC</code> 来开启CMS收集器的话, 用户会收到一个警告信息, 提示CMS未来将会被废弃：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Java</span> <span class="token class-name">HotSpot</span><span class="token punctuation">(</span><span class="token constant">TM</span><span class="token punctuation">)</span> <span class="token number">64</span><span class="token operator">-</span><span class="token class-name">Bit</span> <span class="token class-name">Server</span> <span class="token constant">VM</span> warning<span class="token operator">:</span> <span class="token class-name">Option</span> <span class="token class-name">UseConcMarkSweepGC</span> was deprecated in version <span class="token number">9.0</span> and will likely
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></blockquote><h4 id="g1特点" tabindex="-1"><a class="header-anchor" href="#g1特点" aria-hidden="true">#</a> G1特点</h4><ul><li><strong>并行与并发</strong>：G1能充分利用多CPU、多核环境下的硬件优势, 使用多个CPU来缩短Stop-the-world停顿的时间, 部分其他收集器原来需要停顿Java线程执行的GC操作, G1收集器仍然可以通过<strong>并发</strong>的方式让Java程序继续运行。</li><li>分代收集：G1能够自己管理不同分代内已创建对象和新对象的收集。</li><li>空间整合：与CMS的标记-清除算法不同, G1从整体来看是基于<strong>标记-整理算法</strong>实现的收集器, 从局部(两个Region之间)上来看是基于&quot;<strong>复制</strong>&quot;算法实现的。但无论如何, 这两种算法都意味着G1运作期间不会产生内存空间碎片, 收集后能提供规整的可用内存。<strong>这种特性有利于程序长时间运行, 分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC</strong>。</li><li>可预测的停顿：这是G1相对于CMS的一个优势, 降低停顿时间是G1和CMS共同的关注点。</li></ul><h4 id="g1的目标" tabindex="-1"><a class="header-anchor" href="#g1的目标" aria-hidden="true">#</a> <strong>G1的目标：</strong></h4><p>作为CMS收集器的替代者和继承人, 设计者们希望做出一款能够建立起**&quot;停顿时间模型&quot;**(PausePrediction Model)的收集器, <strong>停顿时间模型的意思是能够支持指定在一个长度为M毫秒的时间片段内, 消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标</strong>, 这几乎已经是实时Java(RTSJ)的中软实时垃圾收集器特征了。</p><h4 id="怎么做才能实现g1的目标呢" tabindex="-1"><a class="header-anchor" href="#怎么做才能实现g1的目标呢" aria-hidden="true">#</a> <strong>怎么做才能实现G1的目标呢？</strong></h4><p>1、首先要有一个思想上的改变</p><p>在G1收集器出现之前的所有其他收集器, 包括CMS在内, 垃圾收集的目标范围要么是整个新生代(Minor GC), 要么就是整个老年代(Major GC), 再要么就是整个Java堆(Full GC)。</p><p>而G1跳出了这个樊笼, 它可以<strong>面向堆内存任何部分来组成回收集(Collection Set, 一般简称CSet)进行回收</strong>, 衡量标准不再是它属于哪个分代, 而是哪块内存中存放的垃圾数量最多, 回收收益最大, 这就是G1收集器的<strong>Mixed GC模式</strong>。</p><p>2、G1开创的<strong>基于Region的堆内存布局</strong>是它能够实现这个目标的关键</p><p>虽然G1也仍是遵循分代收集理论设计的, 但其堆内存的布局与其他收集器有非常明显的差异：</p><p><strong>G1不再坚持固定大小以及固定数量的分代区域划分, 而是把连续的Java堆划分为多个大小相等的独立区域(Region), 每一个Region都可以根据需要, 扮演新生代的Eden空间、Survivor空间, 或者老年代空间</strong>。收集器能够对扮演不同角色的Region采用不同的策略去处理, 这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。</p><p>Region中还有一类特殊的Humongous区域, 专门用来存储大对象。<strong>G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象</strong>。</p><p>每个Region的大小可以通过参数<code>-XX：G1HeapRegionSize</code>设定, 取值范围为1MB～32MB, 且应为2的N次幂。而对于那些超过了整个Region容量的超级大对象, 将会被存放在N个连续的Humongous Region之中, G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待。</p><p><strong>3、建立可预测的停顿时间模型</strong></p><p>将Region作为单次回收的最小单元, 即每次收集到的内存空间都是Region大小的整数倍, 这样可以<strong>有计划地避免在整个Java堆中进行全区域的垃圾收集</strong>。</p><p>具体的处理思路是让G1收集器去跟踪各个Region里面的垃圾堆积的&quot;价值&quot;大小, 价值即回收所获得的空间大小以及回收所需时间的经验值, 然后在后台维护一个优先级列表, 每次根据用户设定允许的收集停顿时间(使用参数-XX：MaxGCPauseMillis指定, 默认值是200毫秒), 优先处理回收价值收益最大的那些Region, 这也就是&quot;Garbage First&quot;名字的由来。这种使用Region划分内存空间, 以及具有优先级的区域回收方式, 保证了G1收集器在有限的时间内获取尽可能高的收集效率。</p><h4 id="g1收集器region分区示意图" tabindex="-1"><a class="header-anchor" href="#g1收集器region分区示意图" aria-hidden="true">#</a> G1收集器Region分区示意图</h4><figure><img src="`+J+'" alt="G1收集器Region分区示意图" tabindex="0" loading="lazy"><figcaption>G1收集器Region分区示意图</figcaption></figure><h4 id="g1将堆内存-化整为零-的-解题思路-遇到的难题" tabindex="-1"><a class="header-anchor" href="#g1将堆内存-化整为零-的-解题思路-遇到的难题" aria-hidden="true">#</a> G1将堆内存&quot;化整为零&quot;的&quot;解题思路&quot;, 遇到的难题</h4><p>从2004年Sun实验室发表第一篇关于G1的论文后一直拖到2012年4月JDK 7 Update 4发布, 用将近10年时间才倒腾出能够商用的G1收集器来。G1收集器至少有(不限于)以下这些关键的细节问题需要妥善解决：</p><p><strong>1、将Java堆分成多个独立Region后, Region里面存在的跨Region引用对象如何解决？</strong></p><p>使用记忆集避免全堆作为GC Roots扫描, 但在G1收集器上记忆集的应用复杂很多。</p><p>它的每个Region都维护有自己的记忆集, 这些记忆集会记录下别的Region指向自己的指针, 并标记这些指针分别在哪些卡页的范围之内。</p><p>G1的记忆集在存储结构的本质上是一种<strong>哈希表</strong>, <strong>Key是别的Region的起始地址, Value是一个集合, 里面存储的元素是卡表的索引号</strong>。这 种&quot;双向&quot;的卡表结构(卡表是&quot;我指向谁&quot;, 这种结构还记录了&quot;谁指向我&quot;)比原来的卡表实现起来更复杂, 同时由于Region数量比传统收集器的分代数量明显要多得多, 因此<strong>G1收集器要比其他的传统垃圾收集器有着更高的内存占用负担</strong>。</p><p>根据经验, <strong>G1至少要耗费大约相当于Java堆容量10%至20%的额外内存来维持收集器工作</strong>。</p><p><strong>2、在并发标记阶段如何保证收集线程与用户线程互不干扰地运行？</strong></p><p><strong>首先要解决的是用户线程改变对象引用关系时, 必须保证其不能打破原本的对象图结构, 导致标记结果出现错误。</strong></p><p>解决办法：</p><p>CMS收集器采用增量更新算法实现, 而G1收集器则是通过原始快照(SATB)算法来实现的。</p><p><strong>回收过程中新创建对象的内存分配上, 程序要继续运行会持续创建新对象。</strong></p><p>解决办法：</p><p>G1为每一个Region设计了两个名为TAMS(Top at Mark Start)的指针, 把Region中的一部分空间划分出来用于并发回收过程中的新对象分配, 并发回收时新分配的对象地址都必须要在这两个指针位置以上。G1收集器默认在这个地址以上的对象是被隐式标记过的, 即默认它们是存活的, 不纳入回收范围。与CMS中的&quot;Concurrent Mode Failure&quot;失败会导致Full GC类似, 如果内存回收的速度赶不上内存分配的速度, <strong>G1收集器也要被迫冻结用户线程执行, 导致Full GC而产生长时间&quot;Stop The World&quot;</strong>。</p><p><strong>3、怎样建立起可靠的停顿预测模型？</strong></p><p>用户通过 <code>-XX：MaxGCPauseMillis</code> 参数指定的停顿时间只意味着垃圾收集发生之前的期望值, 但G1收集器要怎么做才能满足用户的期望呢？</p><p>G1收集器的停顿预测模型是以<strong>衰减均值</strong>(Decaying Average)为理论基础来实现的。</p><p>在垃圾收集过程中, G1收集器会记录每个Region的回收耗时、每个Region记忆集里的脏卡数量等各个可测量的步骤花费的成本, 并分析得出平均值、标准偏差、置信度等统计信息。这里强调的&quot;衰减平均值&quot;是指它会比普通的平均值更容易受到新数据的影响, 平均值代表整体平均状态, 但衰减平均值更准确地代表&quot;最近的&quot;平均状态。</p><p>换句话说, <strong>Region的统计状态越新越能决定其回收的价值</strong>。然后通过这些信息预测现在开始回收的话, <strong>由哪些Region组成回收集才可以在不超过期望停顿时间的约束下获得最高的收益</strong>。</p><h4 id="g1的运作过程" tabindex="-1"><a class="header-anchor" href="#g1的运作过程" aria-hidden="true">#</a> G1的运作过程</h4><p>如果我们不去计算用户线程运行过程中的动作(如使用写屏障维护记忆集的操作), G1收集器运作过程大致可划分为以下四个步骤：</p><ol><li><strong>初始标记(Initial Marking)</strong>：<strong>仅仅只是标记一下GC Roots能直接关联到的对象, 并且修改TAMS指针的值, 让下一阶段用户线程并发运行时, 能正确地在可用的Region中分配新对象</strong>。这个阶段需要停顿线程, 但耗时很短, 而且是借用进行Minor GC的时候同步完成的, 所以G1收集器在这个阶段实际并没有额外的停顿。</li><li><strong>并发标记(Concurrent Marking)</strong>：<strong>从GC Root开始对堆中对象进行可达性分析, 递归扫描整个堆里的对象图, 找出要回收的对象</strong>。这阶段耗时较长, 但可与用户程序并发执行。当对象图扫描完成以后, 还要重新处理SATB记录下的在并发时有引用变动的对象。</li><li><strong>最终标记(Final Marking)</strong>：<strong>对用户线程做另一个短暂的暂停, 用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录</strong>。</li><li><strong>筛选回收(Live Data Counting and Evacuation)</strong>：**负责更新Region的统计数据, 对各个Region的回收价值和成本进行排序, 根据用户所期望的停顿时间来制定回收计划, 可以自由选择任意多个Region构成回收集, 然后把决定回收的那一部分Region的存活对象复制到空的Region中, 再清理掉整个旧Region的全部空间。**这里的操作涉及存活对象的移动, 是必须暂停用户线程, 由多条收集器线程并行完成的。</li></ol><p>G1收集器运行示意图：</p><figure><img src="'+w+'" alt="G1收集器运行示意图" tabindex="0" loading="lazy"><figcaption>G1收集器运行示意图</figcaption></figure><h2 id="cms和g1的区别" tabindex="-1"><a class="header-anchor" href="#cms和g1的区别" aria-hidden="true">#</a> *CMS和G1的区别</h2><h3 id="区别" tabindex="-1"><a class="header-anchor" href="#区别" aria-hidden="true">#</a> 区别</h3><p><strong>区别一： 使用范围不一样</strong></p><p>CMS收集器是老年代的收集器, 可以配合新生代的Serial和ParNew收集器一起使用</p><p>G1收集器收集范围是老年代和新生代。不需要结合其他收集器使用</p><p><strong>区别二： STW的时间</strong></p><p>CMS收集器以最小的停顿时间为目标的收集器。</p><p>G1收集器可预测垃圾回收的停顿时间(建立可预测的停顿时间模型)</p><p><strong>区别三： 垃圾碎片</strong></p><p>CMS收集器是使用&quot;标记-清除&quot;算法进行的垃圾回收, 容易产生内存碎片</p><p>G1收集器使用的是&quot;标记-整理&quot;算法, 进行了空间整合, 降低了内存空间碎片。</p><p><strong>区别四： 垃圾回收的过程不一样</strong></p><p>CMS收集器 G1收集器</p><ol><li>初始标记 1. 初始标记</li><li>并发标记 2. 并发标记</li><li>重新标记 3. 最终标记</li><li>并发清除 4. 筛选回收</li></ol><h3 id="g1的优劣势分析" tabindex="-1"><a class="header-anchor" href="#g1的优劣势分析" aria-hidden="true">#</a> G1的优劣势分析</h3><p><strong>G1的优势</strong>：</p><p>1、最大停顿时间、分Region的内存布局、按收益动态确定回收集这些创新性设计带来的优势</p><p>2、算法层面的优势</p><p>与CMS的&quot;标记-清除&quot;算法不同, G1从整体来看是基于&quot;标记-整理&quot;算法实现的收集器, 但从局部(两个Region之间)上看又是基于&quot;标记-复制&quot;算法实现, 无论如何, 这两种算法都意味着<strong>G1运作期间不会产生内存空间碎片, 垃圾收集完成之后能提供规整的可用内存</strong>。</p><p>这种特性有利于程序长时间运行, 在程序为大对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集</p><p><strong>G1的弱势</strong>：</p><p>在用户程序运行过程中, G1无论是为了垃圾收集产生的内存占用(Footprint)还是程序运行时的额外执行负载(Overload)都要比CMS要高。</p><blockquote><p><strong>就内存占用来说</strong>, 虽然G1和CMS都使用卡表来处理跨代指针, 但G1的卡表实现更为复杂, 而且堆中每个Region, 无论扮演的是新生代还是老年代角色, 都必须有一份卡表, 这导致G1的记忆集(和其他内存消耗)可能会占整个堆容量的20%乃至更多的内存空间；相比起来CMS的卡表就相当简单, 只有唯一一份, 而且只需要处理老年代到新生代的引用, 反过来则不需要, 由于新生代的对象具有朝生夕灭的不稳定性, 引用变化频繁, 能省下这个区域的维护开销是很划算的。</p><p><strong>在执行负载的角度上</strong>, 同样由于两个收集器各自的细节实现特点导致了用户程序运行时的负载会有不同, 譬如它们都使用到写屏障, CMS用写后屏障来更新维护卡表；而G1除了使用写后屏障来进行同样的(由于G1的卡表结构复杂, 其实是更烦琐的)卡表维护操作外, 为了实现原始快照搜索(SATB)算法, 还需要使用写前屏障来跟踪并发时的指针变化情况。相比起增量更新算法, 原始快照搜索能够减少并发标记和重新标记阶段的消耗, 避免CMS那样在最终标记阶段停顿时间过长的缺点, 但是在用户程序运行过程中确实会产生由跟踪引用变化带来的额外负担。由于G1对写屏障的复杂操作要比CMS消耗更多的运算资源, 所以CMS的写屏障实现是直接的同步操作, 而G1就不得不将其实现为类似于消息队列的结构, 把写前屏障和写后屏障中要做的事情都放到队列里, 然后再异步处理。</p></blockquote><p><strong>总览</strong></p><table><thead><tr><th style="text-align:left;"></th><th>CMS</th><th>G1</th></tr></thead><tbody><tr><td style="text-align:left;">JDK版本</td><td></td><td></td></tr><tr><td style="text-align:left;">回收算法</td><td>标记—清除</td><td>标记—整理(标记—复制)</td></tr><tr><td style="text-align:left;">运行环境</td><td>针对70G以内的堆内存</td><td>可针对好几百G的大内存</td></tr><tr><td style="text-align:left;">回收区域</td><td>老年代</td><td>新生代和老年代</td></tr><tr><td style="text-align:left;">内存布局</td><td>传统连续的新生代和老年代区域</td><td>Region(将新生代和老年代切分成Region, 默认一个Region 1 M,默认2048块)<br>MIN_REGION_SIZE：允许的最小的REGION_SIZE, 即1M, 不可能比1M还小；<br>MAX_REGION_SIZE：允许的最大的REGION_SIZE, 即32M, 不可能比32M更大；<br>限制最大REGION_SIZE是为了考虑GC时的清理效果；</td></tr><tr><td style="text-align:left;">浮动垃圾</td><td>是</td><td>否</td></tr><tr><td style="text-align:left;">内存碎片</td><td>是</td><td>否</td></tr><tr><td style="text-align:left;">全堆扫描</td><td>是</td><td>否</td></tr><tr><td style="text-align:left;">回收时间可控</td><td>否</td><td>是</td></tr><tr><td style="text-align:left;">对象进入老年代的年龄</td><td></td><td></td></tr><tr><td style="text-align:left;">空间动态调整</td><td>否</td><td>是(新生代5%-60%动态调整, 一般不需求指定)</td></tr><tr><td style="text-align:left;">调优参数</td><td>多(近百个)</td><td>少(十几个)</td></tr></tbody></table><h2 id="低延迟的垃圾收集器" tabindex="-1"><a class="header-anchor" href="#低延迟的垃圾收集器" aria-hidden="true">#</a> 低延迟的垃圾收集器</h2><p>垃圾收集器的三项重要指标：<strong>内存占用、吞吐量、延迟</strong>。</p><p><strong>内存的扩大, 对低延迟反而会带来负面效果</strong>：虚拟机要回收完整的1TB的堆内存, 要比回收1GB的堆内存耗费更多的时间。</p><blockquote><p>CMS和G1分别使用增量更新和原始快照技术, 实现了标记阶段的并发, 不会因管理的堆内存变大, 要标记的对象变多而导致停顿时间随之增长。但是对于标记阶段之后的处理, 仍未得到妥善解决。</p><p>CMS使用标记-清除算法, 虽然避免了整理阶段收集器带来的停顿, 但是清除算法不论如何优化改进, 在设计原理上避免不了空间碎片的产生, 随着空间碎片不断淤积最终依然逃不过&quot;Stop TheWorld&quot;的命运。</p><p>G1虽然可以按更小的粒度进行回收, 从而抑制整理阶段出现时间过长的停顿, 但毕竟也还是要暂停的。</p></blockquote><h3 id="shenandoah收集器" tabindex="-1"><a class="header-anchor" href="#shenandoah收集器" aria-hidden="true">#</a> Shenandoah收集器</h3><p>Shenandoah是一款只有OpenJDK才会包含, 而OracleJDK里反而不存在的收集器。</p><p>目标是实现一种能在任何堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的垃圾收集器, 该目标意味着相比CMS和G1, Shenandoah不仅要进行并发的垃圾标记, 还要并发地进行对象清理后的整理动作。</p><h3 id="zgc收集器" tabindex="-1"><a class="header-anchor" href="#zgc收集器" aria-hidden="true">#</a> ZGC收集器</h3><blockquote><p>ZGC(&quot;Z&quot;并非什么专业名词的缩写, 这款收集器的名字就叫作Z Garbage Collector)是一款在JDK 11中新加入的具有实验性质[1]的低延迟垃圾收集器, 是由Oracle公司研发的。2018年Oracle创建了JEP 333将ZGC提交给OpenJDK, 推动其进入OpenJDK 11的发布清单之中。</p></blockquote><p>ZGC和Shenandoah的目标是高度相似的, 都希望在<strong>尽可能对吞吐量影响不太大的前提下, 实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟</strong>。</p><h2 id="如何选择垃圾收集器" tabindex="-1"><a class="header-anchor" href="#如何选择垃圾收集器" aria-hidden="true">#</a> 如何选择垃圾收集器？</h2><h3 id="主要因素" tabindex="-1"><a class="header-anchor" href="#主要因素" aria-hidden="true">#</a> 主要因素</h3><ol><li>应用程序的主要关注点是什么？ <ol><li>如果是数据分析、科学计算类的任务, 目标是能尽快算出结果, 那吞吐量就是主要关注点；</li><li>如果是SLA应用, 那停顿时间直接影响服务质量, 严重的甚至会导致事务超时, 这样延迟就是主要关注点；</li><li>如果是客户端应用或者嵌入式应用, 那垃圾收集的内存占用则是不可忽视的。</li></ol></li><li>运行应用的基础设施如何？</li><li>使用JDK的发行商是什么？版本号是多少？</li></ol><h3 id="如何选择" tabindex="-1"><a class="header-anchor" href="#如何选择" aria-hidden="true">#</a> 如何选择？</h3><blockquote><p>使用ParNew(标记复制、并行、作用于新生代) + CMS的垃圾收集器(标记清除、并行、作用于老年代), 追求响应速度优先, 其适用于多CPU环境的Server模式的互联网或者B/S业务。</p><p>如果追求吞吐量优先, 应用在后台运算并不需要太多交互场景的, 可采用Parallel(标记复制、并行、作用于新生代) + Parallel Old 的垃圾收集器(标记整理、并行、作用于老年代)</p></blockquote><p>如果是直接面向用户提供服务的B/S系统, 延迟时间是主要关注点。</p><ul><li>有充足的预算但没有太多调优经验, 可以选择商业性解决方案, Zing VM可以使用C4收集器</li><li>能够掌控软硬件型号, 使用较新的版本, 同时又特别注重延迟, 那ZGC很值得尝试</li><li>遗留系统, 软硬件基础设施和JDK版本都比较落后, 对于大概4GB到6GB以下的堆内存, CMS一般能处理得比较好, 而对于更大的堆内存, 可重点考察一下G1。</li></ul><p>如果是面向计算, 没有太多交互, 注重高吞吐量, 可以使用Java8默认提供的垃圾收集器——Parallel Scavenge收集器和Parallel Old。</p><h1 id="内存分配与回收策略" tabindex="-1"><a class="header-anchor" href="#内存分配与回收策略" aria-hidden="true">#</a> 内存分配与回收策略</h1><p>内存分配与回收策略(即垃圾回收过程)</p><ul><li><strong>对象优先在Eden分配</strong>。大多数情况下, 对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时, 虚拟机将发起一次Minor GC。</li><li><strong>大对象直接进入老年代</strong>。大对象就是指需要大量连续内存空间的Java对象, 最典型的大对象便是那种很长的字符串, 或者元素数量很庞大的数组。这样做的目的就是避免在Eden区及两个Survivor区之间来回复制, 产生大量的内存复制操作。</li><li><strong>长期存活的对象将进入老年代</strong>。 <ul><li>HotSpot虚拟机中多数收集器都采用了分代收集来管理堆内存, 那内存回收时就必须能决策哪些存活对象应当放在新生代, 哪些存活对象放在老年代中。为做到这点, 虚拟机给每个对象定义了一个对象年龄(Age)计数器, 存储在对象头中(详见第2章)。对象通常在Eden区里诞生, 如果经过第一次Minor GC后仍然存活, 并且能被Survivor容纳的话, 该对象会被移动到Survivor空间中, 并且将其对象 年龄设为1岁。对象在Survivor区中每熬过一次Minor GC, 年龄就增加1岁, 当它的年龄增加到一定程度(默认为15), 就会被晋升到老年代中。对象晋升老年代的年龄阈值, 可以通过参数<code>-XX：MaxTenuringThreshold</code>设置。</li></ul></li><li><strong>动态对象年龄判定</strong>。 <ul><li>为了能更好地适应不同程序的内存状况, HotSpot虚拟机并不是永远要求对象的年龄必须达到<code>-XX：MaxTenuringThreshold</code>才能晋升老年代, 如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半, 年龄大于或等于该年龄的对象就可以直接进入老年代, 无须等到<code>-XX：MaxTenuringThreshold</code>中要求的年龄。</li></ul></li><li><strong>空间分配担保</strong>。 <ul><li>在发生Minor GC之前, 虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间, 如果这个条件成立, 那这一次Minor GC可以确保是安全的。如果不成立, 则虚拟机会先查看<code>-XX：HandlePromotionFailure</code>参数的设置值是否允许担保失败(Handle Promotion Failure)；如果允许, 那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小, 如果大于, 将尝试进行一次Minor GC, 尽管这次Minor GC是有风险的；如果小于, 或者<code>-XX：HandlePromotionFailure</code>设置不允许冒险, 那这时就要改为进行一次Full GC。</li></ul></li></ul><p>(参考：深入理解Java虚拟机第三版的3.8节)</p>',148),nn={href:"https://www.cnblogs.com/hexinwei1/p/9525737.html",target:"_blank",rel:"noopener noreferrer"},an=t('<h1 id="类加载过程" tabindex="-1"><a class="header-anchor" href="#类加载过程" aria-hidden="true">#</a> 类加载过程</h1><p>系统加载 Class 类型的文件主要三步：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</p><p>如下图：</p><figure><img src="'+_+'" alt="类加载过程" tabindex="0" loading="lazy"><figcaption>类加载过程</figcaption></figure><h2 id="加载" tabindex="-1"><a class="header-anchor" href="#加载" aria-hidden="true">#</a> 加载</h2><p>在加载阶段, JVM主要完成下面三件事情：</p><ol><li>通过全类名获取定义此类的二进制字节流</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li>在内存中生成一个代表该类的 <code>Class</code> 对象, 作为方法区这些数据的访问入口</li></ol><p>虚拟机规范上面这 3 点并不具体, 因此是非常灵活的。比如：&quot;通过全类名获取定义此类的二进制字节流&quot; 并没有指明具体从哪里获取、怎样获取。比如：比较常见的就是从 <code>ZIP</code> 包中读取(日后出现的 <code>JAR</code>、<code>EAR</code>、<code>WAR</code> 格式的基础)、其他文件生成(典型应用就是 <code>JSP</code>)等等。</p><p><strong>一个非数组类的加载阶段(加载阶段获取类的二进制字节流的动作)是可控性最强的阶段, 这一步可以去完成, 还可以自定义类加载器去控制字节流的获取方式(重写一个类加载器的 <code>loadClass()</code> 方法)。数组类型不通过类加载器创建, 它由 Java 虚拟机直接创建。</strong></p><p>加载阶段和连接阶段的部分内容是交叉进行的, 加载阶段尚未结束, 连接阶段可能就已经开始了。</p><blockquote><p>说明：除了在加载阶段用户应用程序可以通过自定义类加载器的方式局部参与外, 其余动作都完全由Java虚拟机来主导控制。</p></blockquote><h2 id="连接" tabindex="-1"><a class="header-anchor" href="#连接" aria-hidden="true">#</a> 连接</h2><h4 id="验证" tabindex="-1"><a class="header-anchor" href="#验证" aria-hidden="true">#</a> 验证</h4><h5 id="_1、文件格式验证" tabindex="-1"><a class="header-anchor" href="#_1、文件格式验证" aria-hidden="true">#</a> 1、文件格式验证</h5><p>主要验证内容：</p><ul><li>是否以魔数<code>0xCAFEBABE</code>开头。</li><li>主、次版本号是否在当前Java虚拟机接受范围之内。</li><li>常量池的常量中是否有不被支持的常量类型(检查常量tag标志)。</li><li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</li><li><code>CONSTANT_Utf8_info</code>型的常量中是否有不符合UTF-8编码的数据。</li><li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。</li><li>……</li></ul><p>该验证阶段的主要目的是<strong>保证输入的字节流能正确地解析并存储于方法区之内, 格式上符合描述一个Java类型信息的要求</strong>。这阶段的验证是基于二进制字节流进行的, 只有通过了这个阶段的验证之后, 这段字节流才被允许进入Java虚拟机内存的方法区中进行存储, 所以后面的三个验证阶段全部是基于方法区的存储结构上进行的, 不会再直接读取、操作字节流了。</p><h5 id="_2、元数据验证" tabindex="-1"><a class="header-anchor" href="#_2、元数据验证" aria-hidden="true">#</a> 2、元数据验证</h5><p>这个阶段是<strong>对字节码描述的信息进行语义分析</strong>。主要验证内容：</p><ul><li>这个类是否有父类(除了java.lang.Object之外, 所有的类都应当有父类)。</li><li>这个类的父类是否继承了不允许被继承的类(被final修饰的类)。</li><li>如果这个类不是抽象类, 是否实现了其父类或接口之中要求实现的所有方法。</li><li>类中的字段、方法是否与父类产生矛盾(例如覆盖了父类的final字段, 或者出现不符合规则的方法重载, 例如方法参数都一致, 但返回值类型却不同等)。</li></ul><h5 id="_3、字节码验证" tabindex="-1"><a class="header-anchor" href="#_3、字节码验证" aria-hidden="true">#</a> 3、字节码验证</h5><p>第三阶段是整个验证过程中最复杂的一个阶段, 主要目的是<strong>通过数据流分析和控制流分析, 确定程序语义是合法的、符合逻辑的</strong>。主要验证内容：</p><ul><li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作, 例如不会出现类似于&quot;在操作栈放置了一个int类型的数据, 使用时却按long类型来加载入本地变量表中&quot;这样的情况。</li><li>保证任何跳转指令都不会跳转到方法体以外的字节码指令上。</li><li>保证方法体中的类型转换总是有效的, 例如可以把一个子类对象赋值给父类数据类型, 这是安全的, 但是把父类对象赋值给子类数据类型, 甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型, 则是危险和不合法的。</li></ul><p>元数据验证段对元数据信息中的数据类型校验完毕以后, 这阶段就要对类的方法体(Class文件中的Code属性)进行校验分析, 保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。</p><h5 id="_4、符号引用验证" tabindex="-1"><a class="header-anchor" href="#_4、符号引用验证" aria-hidden="true">#</a> 4、符号引用验证</h5><p>校验行为发生在虚拟机将符号引用转化为直接引用的时候, 这个转化动作将在连接的第三阶段——解析阶段中发生。目的：<strong>确保解析动作正确执行</strong>。主要验证内容：</p><ul><li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li><li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。</li><li>符号引用中的类、字段、方法的可访问性(<code>private</code>、<code>protected</code>、<code>public</code>、<code>&lt;package&gt;</code>)是否可被当前类访问</li></ul><h4 id="准备" tabindex="-1"><a class="header-anchor" href="#准备" aria-hidden="true">#</a> 准备</h4><p><strong>准备阶段是正式为类中定义的变量(即静态变量, 被static修饰的变量)分配内存并设置类变量初始值的阶段</strong>。这一阶段并不包括实例变量, 实例变量的初始化随着对象一块分配在Java堆中。</p><blockquote><p>从概念上讲, 这些变量所使用的内存都应当在方法区中进行分配, 但必须注意到方法区本身是一个逻辑上的区域, 在JDK 7及之前, HotSpot使用永久代来实现方法区时, 实现是完全符合这种逻辑概念的；而在JDK 8及之后, 类变量则会随着Class对象一起存放在Java堆中, 这时候&quot;类变量在方法区&quot;就完全是一种对逻辑概念的表述了。</p></blockquote><p><strong>这里所设置的初始值&quot;通常情况&quot;下是数据类型默认的零值</strong>(如 0、0L、null、false 等), 比如我们定义了public static int value=111 , 那么 value 变量在准备阶段的初始值就是 0 而不是 111(初始化阶段才会赋值)。特殊情况：比如给 value 变量加上了 final 关键字public static final int value=111 , 那么准备阶段 value 的值就被赋值为 111。</p><h4 id="解析" tabindex="-1"><a class="header-anchor" href="#解析" aria-hidden="true">#</a> 解析</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。</p><blockquote><p>符号引用就是一组符号来描述目标, 可以是任何字面量。</p></blockquote><blockquote><p><strong>直接引用</strong>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。在程序实际运行时, 只有符号引用是不够的, 举个例子：在程序执行方法时, 系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候, 只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置, 从而使得方法可以被调用。</p></blockquote><p>综上, 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程, 也就是得到类或者字段、方法在内存中的指针或者偏移量。</p><p>对类/接口、字段、方法、接口方法的解析过程, 可参看《深入理解Java虚拟机(第3版)》。</p><h2 id="初始化" tabindex="-1"><a class="header-anchor" href="#初始化" aria-hidden="true">#</a> 初始化</h2><p>初始化阶段是执行初始化方法 <code>&lt;clinit&gt; ()</code>方法的过程, 是类加载的最后一步, 这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。</p><blockquote><p>说明： <code>&lt;clinit&gt; ()</code>方法是编译之后自动生成的。</p></blockquote><p>对于<code>&lt;clinit&gt; ()</code> 方法的调用, 虚拟机会自己确保其在多线程环境中的安全性。因为 <code>&lt;clinit&gt; ()</code> 方法是带锁线程安全, 所以在多线程环境下进行类初始化的话可能会引起多个进程阻塞, 并且这种阻塞很难被发现。</p><p>对于初始化阶段, 虚拟机严格规范了有且只有 以下情况下, 必须对类进行初始化(只有主动去使用类才会初始化类)：</p><ol><li><p>当遇到 new 、 getstatic、putstatic 或 invokestatic 这 4 条直接码指令时, 比如 new 一个类, 读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。</p><p>当 jvm 执行 new 指令时会初始化类。即当程序创建一个类的实例对象。</p><p>当 jvm 执行 getstatic 指令时会初始化类。即程序访问类的静态变量(不是静态常量, 常量会被加载到运行时常量池)。</p><p>当 jvm 执行 putstatic 指令时会初始化类。即程序给类的静态变量赋值。</p><p>当 jvm 执行 invokestatic 指令时会初始化类。即程序调用类的静态方法。</p></li><li><p>使用 java.lang.reflect 包的方法对类进行反射调用时如 Class.forname(&quot;...&quot;), newInstance() 等等。如果类没初始化, 需要触发其初始化。</p></li><li><p>初始化一个类, 如果其父类还未初始化, 则先触发该父类的初始化。</p></li><li><p>当虚拟机启动时, 用户需要定义一个要执行的主类 (包含 main 方法的那个类), 虚拟机会先初始化这个类。</p></li><li><p>MethodHandle 和 VarHandle 可以看作是轻量级的反射调用机制, 而要想使用这 2 个调用, 就必须先使用 findStaticVarHandle 来初始化要调用的类。</p></li><li><p>当一个接口中定义了 JDK8 新加入的默认方法(被 default 关键字修饰的接口方法)时, 如果有这个接口的实现类发生了初始化, 那该接口要在其之前被初始化。</p></li></ol><h2 id="补充-卸载" tabindex="-1"><a class="header-anchor" href="#补充-卸载" aria-hidden="true">#</a> 补充：卸载</h2><p>卸载类即该类的 Class 对象被 GC。</p><p>卸载类需要满足 3 个要求:</p><ol><li>该类的所有的实例对象都已被 GC, 也就是说堆不存在该类的实例对象。</li><li>该类没有在其他任何地方被引用</li><li>该类的类加载器的实例已被 GC</li></ol><p>所以, 在 JVM 生命周期内, 由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。</p><p>只要想通一点就好了, jdk 自带的 <code>BootstrapClassLoader</code>, <code>ExtClassLoader</code>, <code>AppClassLoader</code> 负责加载 jdk 提供的类, 所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的, 所以使用我们自定义加载器加载的类是可以被卸载掉的。</p><h1 id="类加载器和双亲委派模型" tabindex="-1"><a class="header-anchor" href="#类加载器和双亲委派模型" aria-hidden="true">#</a> 类加载器和双亲委派模型</h1><p>所有的类都由类加载器加载, 加载的作用就是将 .class文件加载到内存。</p><blockquote><p>Java虚拟机设计团队有意把类加载阶段中的&quot;通过一个类的全限定名来获取描述该类的二进制字节流&quot;这个动作放到Java虚拟机外部去实现, 以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为&quot;类加载器&quot;(Class Loader)。</p></blockquote><p>每一个类加载器, 都拥有一个独立的类名称空间比较两个类是否&quot;相等&quot;。只有在这两个类是由同一个类加载器加载的前提下才有意义, 否则, 即使这两个类来源于同一个Class文件, 被同一个Java虚拟机加载, 只要加载它们的类加载器不同, 那这两个类就必定不相等。</p><p>这里所指的&quot;相等&quot;, 包括代表类的Class对象的<code>equals()</code>方法、<code>isAssignableFrom()</code>方法、<code>isInstance()</code>方法的返回结果, 也包括了使用<code>instanceof</code>关键字做对象所属关系判定等各种情况。如果没有注意到类加载器的影响, 在某些情况下可能会产生具有迷惑性的结果,</p><h2 id="类加载器总结" tabindex="-1"><a class="header-anchor" href="#类加载器总结" aria-hidden="true">#</a> 类加载器总结</h2><p>JVM 中内置了三个重要的 ClassLoader, 除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>：</p><ol><li><strong>BootstrapClassLoader(启动类加载器)</strong> ：最顶层的加载类, 由C++实现, 负责加载 <code>%JAVA_HOME%/lib</code>目录下的jar包和类或者或被 <code>-Xbootclasspath</code>参数指定的路径中的所有类。</li><li><strong>ExtensionClassLoader(扩展类加载器)</strong> ：主要负责加载目录 <code>%JRE_HOME%/lib/ext</code> 目录下的jar包和类, 或被 <code>java.ext.dirs</code> 系统变量所指定的路径下的jar包。</li><li><strong>AppClassLoader(应用程序类加载器)</strong> ：面向我们用户的加载器, 负责加载当前应用classpath下的所有jar包和类。</li></ol><h2 id="双亲委派模型" tabindex="-1"><a class="header-anchor" href="#双亲委派模型" aria-hidden="true">#</a> 双亲委派模型</h2><p>双亲委派模型要求除了顶层的启动类加载器外, 其余的类加载器都应有自己的父类加载器。</p><h3 id="双亲委派模型的工作过程" tabindex="-1"><a class="header-anchor" href="#双亲委派模型的工作过程" aria-hidden="true">#</a> <strong>双亲委派模型的工作过程</strong></h3><p>如果一个类加载器收到了类加载的请求, 它首先不会自己去尝试加载这个类, 而是把这个请求委派给父类加载器去完成, 每一个层次的类加载器都是如此, 因此所有的加载请求最终都应该传送到最顶层的启动类加载器中, 只有当父加载器反馈自己无法完成这个加载请求(它的搜索范围中没有找到所需的类)时, 子加载器才会尝试自己去完成加载。</p><figure><img src="'+O+'" alt="双亲委派模型" tabindex="0" loading="lazy"><figcaption>双亲委派模型</figcaption></figure><h3 id="好处" tabindex="-1"><a class="header-anchor" href="#好处" aria-hidden="true">#</a> 好处</h3><p>使用双亲委派模型来组织类加载器之间的关系, 一个显而易见的好处就是Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系。</p><p>双亲委派模型保证了Java程序的稳定运行, 可以避免类的重复加载(JVM 区分不同类的方式不仅仅根据类名, 相同的类文件被不同的类加载器加载产生的是两个不同的类), 也保证了 Java 的核心 API 不被篡改。如果没有使用双亲委派模型, 而是每个类加载器加载自己的话就会出现一些问题, 比如我们编写一个称为 <code>java.lang.Object</code> 类的话, 那么程序运行的时候, 系统就会出现多个不同的 <code>Object</code> 类。</p><h3 id="如何破坏双亲委派模型" tabindex="-1"><a class="header-anchor" href="#如何破坏双亲委派模型" aria-hidden="true">#</a> 如何破坏双亲委派模型？</h3><p>自定义加载器的话, 需要继承 <code>ClassLoader</code> 。如果我们不想打破双亲委派模型, 就重写 <code>ClassLoader</code> 类中的 <code>findClass()</code> 方法即可, 无法被父类加载器加载的类最终会通过这个方法被加载。但是, 如果想打破双亲委派模型则需要重写 <code>loadClass()</code> 方法</p><h3 id="自定义类加载器" tabindex="-1"><a class="header-anchor" href="#自定义类加载器" aria-hidden="true">#</a> 自定义类加载器</h3><p>除了 <code>BootstrapClassLoader</code> 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>。如果我们要自定义自己的类加载器, 很明显需要继承 <code>ClassLoader</code>。</p>',69);function sn(en,tn){const s=l("ExternalLinkIcon");return p(),i("div",null,[R,n("ul",null,[n("li",null,[n("a",E,[a("java中内存泄漏和内存溢出是什么"),e(s)])])]),P,n("p",null,[X,a(" 为啥把缓存设置为[-128, 127]区间？("),n("a",D,[a("参见 issue/461"),e(s)]),a(")性能和资源之间的权衡。")]),I,n("p",null,[a("关于应用的使用案例参考："),n("a",H,[a("Java的四种引用详解与使用案例"),e(s)])]),T,A,B,L,N,n("ul",null,[n("li",null,[n("a",z,[a("在Java中将对象分配为null会影响垃圾回收吗？"),e(s)])]),n("li",null,[n("a",K,[a("java中将对象赋值为null, 对垃圾回收有用吗？"),e(s)])])]),F,n("p",null,[a("参考："),n("a",V,[a("新生代Eden与两个Survivor区的解释"),e(s)])]),W,n("p",null,[a("关于"),U,a(", 可参考："),n("a",Z,[a("垃圾回收算法——标记—整理回收"),e(s)]),a(" (了解)")]),Y,n("p",null,[a("参看："),n("a",$,[a("JVM系列十六(三色标记法与读写屏障)"),e(s)])]),Q,n("p",null,[a("关于垃圾收集机制的详细内容可参考："),n("a",nn,[a("JVM垃圾回收机制"),e(s)])]),an])}const pn=o(j,[["render",sn],["__file","jvm.html.vue"]]);export{pn as default};
