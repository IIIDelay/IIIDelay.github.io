const e=JSON.parse(`{"key":"v-7a032ebf","path":"/en/javabase/collection/map.html","title":"Map","lang":"en-US","frontmatter":{"icon":"edit","date":"2023-04-07T00:00:00.000Z","category":["base","collection"],"tag":["map","hash"],"description":"Map HashCode 1. HashCode 为什么使用 31 作为乘数？ hashCode的源码中可以看到, 有一个固定值31, 在for循环每次执行时进行乘积计算, 循环后的公式: s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1] 原因: 31 是一个奇质数, 如果选择偶数会导致乘积运算时数据溢出。 在二进制中, 2个5次方是32, 那么也就是 31 * i == (i &lt;&lt; 5) - i 这主要是说乘积运算可以使用位移提升性能, 同时目前的JVM虚拟机也会自动支持此类的优化 超过 5 千个单词计算 hashCode, 这个 hashCode 的运算使用 31、33、37、39 和 41 作为乘积, 得到的碰撞 结果, 31 被使用就很正常了。 31的碰撞概率很小, 比较稳定, 而且不超过int的取值范围。199的碰撞概率更小, 这就相当于一排奇数的茅坑量多, 自然会减少碰撞。但这个范围值已经远超过int的取值范围了, 如果用此数作为乘数, 又返回int值, 就会丢失数据信息。 hash的散列比较均匀","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/en/javabase/collection/map.html"}],["meta",{"property":"og:site_name","content":"IIIDelay's Blog"}],["meta",{"property":"og:title","content":"Map"}],["meta",{"property":"og:description","content":"Map HashCode 1. HashCode 为什么使用 31 作为乘数？ hashCode的源码中可以看到, 有一个固定值31, 在for循环每次执行时进行乘积计算, 循环后的公式: s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1] 原因: 31 是一个奇质数, 如果选择偶数会导致乘积运算时数据溢出。 在二进制中, 2个5次方是32, 那么也就是 31 * i == (i &lt;&lt; 5) - i 这主要是说乘积运算可以使用位移提升性能, 同时目前的JVM虚拟机也会自动支持此类的优化 超过 5 千个单词计算 hashCode, 这个 hashCode 的运算使用 31、33、37、39 和 41 作为乘积, 得到的碰撞 结果, 31 被使用就很正常了。 31的碰撞概率很小, 比较稳定, 而且不超过int的取值范围。199的碰撞概率更小, 这就相当于一排奇数的茅坑量多, 自然会减少碰撞。但这个范围值已经远超过int的取值范围了, 如果用此数作为乘数, 又返回int值, 就会丢失数据信息。 hash的散列比较均匀"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://mister-hope.github.io/"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"Map"}],["meta",{"property":"article:author","content":"Mr.IIIDelay"}],["meta",{"property":"article:tag","content":"map"}],["meta",{"property":"article:tag","content":"hash"}],["meta",{"property":"article:published_time","content":"2023-04-07T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Map\\",\\"image\\":[\\"https://mister-hope.github.io/\\"],\\"datePublished\\":\\"2023-04-07T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.IIIDelay\\",\\"url\\":\\"https://mrhope.site\\"}]}"]]},"headers":[{"level":2,"title":"HashCode","slug":"hashcode","link":"#hashcode","children":[]},{"level":2,"title":"HashMap","slug":"hashmap","link":"#hashmap","children":[]},{"level":2,"title":"ConcurrentHashMap","slug":"concurrenthashmap","link":"#concurrenthashmap","children":[]}],"git":{},"readingTime":{"minutes":29.4,"words":8820},"filePathRelative":"en/javabase/collection/map.md","localizedDate":"April 7, 2023","excerpt":"<h1> Map</h1>\\n<h2> HashCode</h2>\\n<h4> 1. HashCode 为什么使用 31 作为乘数？</h4>\\n\\n<blockquote>\\n<p><code>hashCode</code>的源码中可以看到, 有一个固定值<code>31</code>, 在for循环每次执行时进行乘积计算, 循环后的公式: <code>s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</code></p>\\n<p>原因:</p>\\n<ul>\\n<li>31 是一个奇质数, 如果选择偶数会导致乘积运算时数据溢出。</li>\\n<li>在二进制中, 2个5次方是32, 那么也就是 <code>31 * i == (i &lt;&lt; 5) - i</code>\\n<ul>\\n<li>这主要是说乘积运算可以使用位移提升性能, 同时目前的JVM虚拟机也会自动支持此类的优化</li>\\n</ul>\\n</li>\\n<li>超过 5 千个单词计算 hashCode,  这个 hashCode 的运算使用 31、33、37、39 和 41 作为乘积, 得到的碰撞 结果, 31 被使用就很正常了。\\n<ul>\\n<li>31的碰撞概率很小, 比较稳定, 而且不超过int的取值范围。<u>199的碰撞概率更小, 这就相当于一排奇数的茅坑量多, 自然会减少碰撞</u>。<strong>但这个范围值已经远超过int的取值范围了, 如果用此数作为乘数, 又返回int值, 就会丢失数据信息</strong>。</li>\\n<li>hash的散列比较均匀</li>\\n</ul>\\n</li>\\n</ul>\\n</blockquote>","copyright":{"author":"Mr.IIIDelay"},"autoDesc":true}`);export{e as data};
