import{_ as t,W as r,X as d,Y as s,Z as n,$ as a,a1 as i,C as l}from"./framework-b5ea9e64.js";const p="/assets/202112021507099-d8b95cb2.jpg",o="/assets/20210628214025-c8a4be70.png",c={},u=s("h1",{id:"redis面试题",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#redis面试题","aria-hidden":"true"},"#"),n(" Redis面试题")],-1),h={href:"https://zhuanlan.zhihu.com/p/354314607",target:"_blank",rel:"noopener noreferrer"},g=i('<h2 id="_1-什么是redis" tabindex="-1"><a class="header-anchor" href="#_1-什么是redis" aria-hidden="true">#</a> 1. 什么是redis？</h2><p><strong>Redis (Remote Dictionary Server)就是一个使用 C 语言开发的数据库</strong>，与传统数据库不同的是 <strong>Redis 的数据是存在内存中的</strong> ，也就是它是内存数据库，所以读写速度非常快，因此 Redis 被广泛应用于缓存方向。</p><p><strong>Redis 除了做缓存之外，Redis 也经常用来做分布式锁，甚至是消息队列。</strong></p><p><strong>Redis 提供了多种数据类型来支持不同的业务场景。Redis 还支持事务 、持久化、Lua 脚本、多种集群方案。</strong></p><h2 id="_2-分布式缓存常见的技术选型" tabindex="-1"><a class="header-anchor" href="#_2-分布式缓存常见的技术选型" aria-hidden="true">#</a> 2. 分布式缓存常见的技术选型</h2><h3 id="_2-1-缓存类型" tabindex="-1"><a class="header-anchor" href="#_2-1-缓存类型" aria-hidden="true">#</a> 2.1 缓存类型</h3><p>本地缓存是内存访问，没有远程交互开销，性能最好，但是受限于单机容量，一般缓存较小且无法扩展。</p><p>分布式缓存一般都具有良好的水平扩展能力，对较大数据量的场景也能应付自如。缺点就是需要进行远程请求，性能不如本地缓存。</p><p>分布式缓存主要解决的是单机缓存的容量受服务器限制并且无法保存通用的信息。因为，本地缓存只在当前服务里有效，比如如果你部署了两个相同的服务，他们两者之间的缓存数据是无法共同的。</p><p>Memcached 是分布式缓存最开始兴起的那会，比较常用的。后来，随着 Redis 的发展，大家慢慢都转而使用更加强大的 Redis 了。</p><p>为了平衡这种情况，实际业务中一般采用<strong>多级缓存</strong>，本地缓存只保存访问频率最高的部分热点数据，其他的热点数据放在分布式缓存中。</p><h3 id="_2-1-redis-和-memcached-的区别和共同点" tabindex="-1"><a class="header-anchor" href="#_2-1-redis-和-memcached-的区别和共同点" aria-hidden="true">#</a> 2.1 Redis 和 Memcached 的区别和共同点</h3><p><strong>共同点</strong> ：</p><ol><li>都是基于内存的数据库，一般都用来当做缓存使用。</li><li>都有过期策略。</li><li>两者的性能都非常高。</li></ol><p><strong>区别</strong> ：</p><ol><li><strong>Redis 支持更丰富的数据类型(支持更复杂的应用场景)</strong>。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。</li><li><strong>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memecache 把数据全部存在内存之中。</strong></li><li><strong>Redis 有灾难恢复机制。</strong> 因为可以把缓存中的数据持久化到磁盘上。</li><li><strong>Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。</strong></li><li><strong>Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的.</strong></li><li><strong>Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。</strong> (Redis 6.0 引入了多线程 IO )</li><li><strong>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。</strong></li><li><strong>Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。</strong></li></ol><p>相信看了上面的对比之后，我们已经没有什么理由可以选择使用 Memcached 来作为自己项目的分布式缓存了。</p><h2 id="_3-redis有哪些优缺点" tabindex="-1"><a class="header-anchor" href="#_3-redis有哪些优缺点" aria-hidden="true">#</a> 3. Redis有哪些优缺点？</h2><p>优点：</p><ul><li>性能极高 – Redis 能读的速度是 110000 次/s,写的速度是 81000 次/s 。</li><li>丰富的数据类型</li><li>原子 – Redis 的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。(多操作使用事务保证原子性)</li><li>丰富的特性 – Redis 还支持 publish/subscribe, 通知, key 过期等等特性。</li></ul><p>缺点：</p><ul><li>容量受到物理内存的限制,不能用作海量数据的高性能读写。因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</li></ul><h2 id="_4-为什么要用-redis-为什么要用缓存" tabindex="-1"><a class="header-anchor" href="#_4-为什么要用-redis-为什么要用缓存" aria-hidden="true">#</a> 4. 为什么要用 Redis /为什么要用缓存？</h2><p>从高性能和高并发的角度去思考。</p><p><strong>高性能</strong>：</p><p>用户第一次访问数据库中的高频数据比较慢(硬盘读取)，如果将<strong>用户高频访问而且不经常改变的数据</strong>放到redis，用户下次访问直接从缓存中读取(读取内存)，大大提高访问速度。</p><p>注：但是要注意数据库与缓存的数据一致性。</p><p><strong>高并发</strong>：</p><p>一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右(4 核 8g) ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+(就单机 redis 的情况，redis 集群的话会更高)</p><blockquote><p>QPS(Query Per Second)：服务器每秒可以执行的查询次数</p></blockquote><p>高频访问数据转移到缓存可以大大提升系统的并发能力。</p><h2 id="_5-如何保障mysql和redis之间的数据一致性" tabindex="-1"><a class="header-anchor" href="#_5-如何保障mysql和redis之间的数据一致性" aria-hidden="true">#</a> 5. 如何保障mysql和redis之间的数据一致性？</h2><figure><img src="'+p+`" alt="mysql和redis的数据一致性" tabindex="0" loading="lazy"><figcaption>mysql和redis的数据一致性</figcaption></figure><p><strong>缓存与数据库双写时数据不一致</strong>的问题。不管是先写数据库，再删除缓存；还是先删除缓存，再写库，都有可能出现数据不一致的情况。具体情况如下：</p><ol><li>如果删除了缓存Redis，还没有来得及写库MySQL，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。</li><li>如果先写了库，在删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。</li></ol><p>因为写和读是并发的，没法保证顺序,就会出现缓存和数据库的数据不一致的问题。如何解决？</p><h3 id="方案一-延时双删" tabindex="-1"><a class="header-anchor" href="#方案一-延时双删" aria-hidden="true">#</a> 方案一：延时双删</h3><p>在写库前后都进行<code>redis.del(key)</code>操作，并且设定合理的超时时间。</p><ul><li>伪代码如下：</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span><span class="token class-name">Object</span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>
    redis<span class="token punctuation">.</span><span class="token function">delKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    db<span class="token punctuation">.</span><span class="token function">updateData</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    redis<span class="token punctuation">.</span><span class="token function">delKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>具体的步骤就是：</strong></p><p>1)先删除缓存</p><p>2)再写数据库</p><p>3)休眠500毫秒</p><p>4)再次删除缓存 <strong>那么，这个500毫秒怎么确定的，具体该休眠多久呢？</strong></p><p>需要评估自己的项目的读数据业务逻辑的耗时。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。</p><p>当然这种策略还要考虑redis和数据库主从同步的耗时。最后的的写数据的休眠时间：则在读数据业务逻辑的耗时基础上，加几百ms即可。比如：休眠1秒。</p><p><strong>设置缓存过期时间</strong></p><p>从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。所有的写操作以数据库为准，只要到达缓存过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。</p><p><strong>该方案的弊端</strong></p><p>结合双删策略+缓存超时设置，这样最差的情况就是在超时时间内数据存在不一致，而且又增加了写请求的耗时。</p><h3 id="方案二-异步更新缓存-基于订阅binlog的同步机制" tabindex="-1"><a class="header-anchor" href="#方案二-异步更新缓存-基于订阅binlog的同步机制" aria-hidden="true">#</a> 方案二：<strong>异步更新缓存(基于订阅binlog的同步机制)</strong></h3><p><strong>整体思路：</strong></p><p>MySQL binlog增量订阅消费+消息队列+增量数据更新到redis</p><p><strong>1)读Redis</strong>：热数据基本都在Redis</p><p><strong>2)写MySQL</strong>:增删改都是操作MySQL</p><p><strong>3)更新Redis数据</strong>：MySQ的数据操作binlog，来更新到Redis</p><p><strong>Redis更新</strong></p><p><strong>1)数据操作主要分为两大块：</strong></p><ul><li>一个是全量(将全部数据一次写入到redis)</li><li>一个是增量(实时更新)</li></ul><p>这里说的是增量,指的是mysql的update、insert、delate变更数据。</p><p><strong>2)读取binlog后分析 ，利用消息队列,推送更新各台的redis缓存数据。</strong></p><p>这样一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新。</p><p>其实这种机制，很类似MySQL的主从备份机制，因为MySQL的主备也是通过binlog来实现的数据一致性。</p><p>这里可以结合使用canal(阿里的一款开源框架)，通过该框架可以对MySQL的binlog进行订阅，而canal正是模仿了mysql的slave数据库的备份请求，使得Redis的数据更新达到了相同的效果。</p><p>当然，这里的消息推送工具你也可以采用别的第三方：kafka、rabbitMQ等来实现推送更新Redis。</p>`,66),m={href:"https://my.oschina.net/jiagouzhan/blog/2990423",target:"_blank",rel:"noopener noreferrer"},b=i(`<h2 id="_6-redis有哪些数据类型及使用场景" tabindex="-1"><a class="header-anchor" href="#_6-redis有哪些数据类型及使用场景" aria-hidden="true">#</a> 6.Redis有哪些数据类型及使用场景</h2><h3 id="string" tabindex="-1"><a class="header-anchor" href="#string" aria-hidden="true">#</a> String</h3><p>K-V结构</p><p>value如果是数字，可以进行计数操作</p><p>常用操作：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 返回 key 所储存的字符串值的长度</span>
strlen key 
<span class="token comment"># 批量设置 key-value 类型的值</span>
mset key1 value1 key2 value2
<span class="token comment"># 批量获取多个 key 对应的 value</span>
mget key1 key2 
 <span class="token comment"># 将 key 中储存的数字值增一</span>
incr number
 <span class="token comment"># 将 key 中储存的数字值减一</span>
decr number
<span class="token comment"># 数据在 60s 后过期</span>
expire key  <span class="token number">60</span> 
<span class="token comment"># 数据在 60s 后过期 (setex:[set] + [ex]pire)</span>
setex key <span class="token number">60</span> value 
<span class="token comment"># 查看数据还有多久过期</span>
ttl key
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用场景：常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。</p><h3 id="list" tabindex="-1"><a class="header-anchor" href="#list" aria-hidden="true">#</a> List</h3><p>Redis 的 list 的实现为一个 <strong>双向链表</strong>，即可以支持反向查找和遍历。特点是易于数据元素的插入和删除并且且可以灵活调整链表长度，但是链表的随机访问困难。</p><p><strong>应用场景:</strong> 发布与订阅或者说消息队列、慢查询。</p><p>常用操作：</p><p><strong>实现队列和栈</strong></p><figure><img src="`+o+`" alt="redis实现栈和队列" tabindex="0" loading="lazy"><figcaption>redis实现栈和队列</figcaption></figure><p><strong>查看对应下标范围的列表元素(实现分页)</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 查看对应下标的list列表， 0 为 start,1为 end</span>
lrange myList <span class="token number">0</span> <span class="token number">1</span> 
<span class="token comment"># 查看列表中的所有元素，-1表示倒数第一</span>
lrange myList <span class="token number">0</span> <span class="token parameter variable">-1</span> 
查看链表长度
llen myList
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a></h3>`,16);function v(k,y){const e=l("ExternalLinkIcon");return r(),d("div",null,[u,s("p",null,[n("redis常见面试题："),s("a",h,[n("吃透这份Redis学习笔记，直接把阿里面试官按在地上摩擦！"),a(e)])]),g,s("p",null,[n("参看："),s("a",m,[n("高并发架构系列：Redis缓存和MySQL数据一致性方案详解"),a(e)])]),b])}const R=t(c,[["render",v],["__file","redis.html.vue"]]);export{R as default};
