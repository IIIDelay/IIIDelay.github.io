import{_ as e,W as r,X as o,a1 as i}from"./framework-b5ea9e64.js";const a="/assets/image-20230325202613012-dda075b6.png",t="/assets/image-20230325203807607-1b040430.png",l={},c=i('<h1 id="rocketmq的架构设计" tabindex="-1"><a class="header-anchor" href="#rocketmq的架构设计" aria-hidden="true">#</a> RocketMQ的架构设计</h1><ul><li>RocketMQ主要由NameServer、Broker、Producer以及Consumer组成</li></ul><figure><img src="'+a+'" alt="image-20230325202613012" tabindex="0" loading="lazy"><figcaption>image-20230325202613012</figcaption></figure><blockquote><p>1、NameServer是一个功能齐全的服务器，其角色类似于Zookeeper，但是NameServer比Zookeeper更加轻量。主要是NameServer节点之间相互独立，没有任何信息交互。</p><p>2、Producer是消息生产者，负责产生消息，一般由业务系统负责产生消息</p><ul><li>Producer由用户进行分布式部署，消息由Producer通过负载均衡模式发送到Broker集群，发送低延时，支持快速失败</li></ul><p>3、Broker是消息中转角色，负责存储消息，转发消息</p><ul><li>Broker是具体提供业务的服务器，单个Broker节点于NameServer节点保持长连接及心跳，并会定时将Topic信息注册到NameServer，底层的通信和连接时基于Netty实现的</li><li>Broker负责消息存储，以Topic为纬度支持轻量级的队列，单机可以支撑上万队列规模，支持消息推拉模型</li><li>官网显示：具有上亿级消息堆积能力，同时可以保证消息的有序性</li></ul><p>4、Consuemr是消息消费者，负责消息消息，一般是后台系统负责异步消费</p><ul><li>Consumer也由用户部署，支持push与pull两种消费模式，支持集群消费与广播消费，提供实时消息订阅机制。</li></ul></blockquote><blockquote><p>大致流程：</p><ul><li>Broker在启动的时候会去向NameServer注册并且定时发送心跳，Producer在启动的时候会到NameServer上去拉Topic所属的Broker具体地址，然后向具体的Broker发送消息</li></ul><figure><img src="'+t+'" alt="image-20230325203807607" tabindex="0" loading="lazy"><figcaption>image-20230325203807607</figcaption></figure></blockquote>',5),u=[c];function s(m,n){return r(),o("div",null,u)}const d=e(l,[["render",s],["__file","rocketmq.html.vue"]]);export{d as default};
