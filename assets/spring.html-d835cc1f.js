import{_ as e,W as i,X as a,a1 as n}from"./framework-b5ea9e64.js";const t="/assets/image-20230325200822210-8e582096.png",o="/assets/image-20230325200842176-83d2331b.png",l="/assets/resize_m_fixed_w_1184-1904a6aa.webp",r={},s=n('<h1 id="spring-bean" tabindex="-1"><a class="header-anchor" href="#spring-bean" aria-hidden="true">#</a> Spring Bean</h1><blockquote><p>IOC中Bean的生命周期分为四部分:</p><ul><li>实例化、属性赋值、初始化、销毁</li></ul></blockquote><ul><li>Bean的创建、属性赋值</li></ul><figure><img src="'+t+'" alt="image-20230325200822210" tabindex="0" loading="lazy"><figcaption>image-20230325200822210</figcaption></figure><ul><li>Bean的初始化与销毁</li></ul><figure><img src="'+o+'" alt="image-20230325200842176" tabindex="0" loading="lazy"><figcaption>image-20230325200842176</figcaption></figure><blockquote><p>完整的生命周期</p></blockquote><figure><img src="'+l+'" alt="2w字搞懂Spring Bean的一生_spring_12" tabindex="0" loading="lazy"><figcaption>2w字搞懂Spring Bean的一生_spring_12</figcaption></figure><blockquote><p>Tip:</p><p>Bean 生命周期的整个执行过程描述如下。</p><ol><li>根据配置情况调用 Bean 构造方法或工厂方法实例化 Bean。</li><li>利用依赖注入完成 Bean 中所有属性值的配置注入。</li><li>如果 Bean 实现了 BeanNameAware 接口，则 Spring 调用 Bean 的 setBeanName() 方法传入当前 Bean 的 id 值。</li><li>如果 Bean 实现了 BeanFactoryAware 接口，则 Spring 调用 setBeanFactory() 方法传入当前工厂实例的引用。</li><li>如果 Bean 实现了 ApplicationContextAware 接口，则 Spring 调用 setApplicationContext() 方法传入当前 ApplicationContext 实例的引用。</li><li>如果 BeanPostProcessor 和 Bean 关联，则 Spring 将调用该接口的预初始化方法 postProcessBeforeInitialzation() 对 Bean 进行加工操作，此处非常重要，Spring 的 AOP 就是利用它实现的。</li><li>如果 Bean 实现了 InitializingBean 接口，则 Spring 将调用 afterPropertiesSet() 方法。</li><li>如果在配置文件中通过 init-method 属性指定了初始化方法，则调用该初始化方法。</li><li>如果 BeanPostProcessor 和 Bean 关联，则 Spring 将调用该接口的初始化方法 postProcessAfterInitialization()。此时，Bean 已经可以被应用系统使用了。</li><li>如果在 <code>&lt;bean&gt;</code> 中指定了该 Bean 的作用范围为 scope=&quot;singleton&quot;，则将该 Bean 放入 Spring IoC 的缓存池中，将触发 Spring 对该 Bean 的生命周期管理；如果在 <code>&lt;bean&gt;</code> 中指定了该 Bean 的作用范围为 scope=&quot;prototype&quot;，则将该 Bean 交给调用者，调用者管理该 Bean 的生命周期，Spring 不再管理该 Bean。</li><li>如果 Bean 实现了 DisposableBean 接口，则 Spring 会调用 destory() 方法将 Spring 中的 Bean 销毁；如果在配置文件中通过 destory-method 属性指定了 Bean 的销毁方法，则 Spring 将调用该方法对 Bean 进行销毁。</li></ol></blockquote><h2 id="单例bean的线程安全问题" tabindex="-1"><a class="header-anchor" href="#单例bean的线程安全问题" aria-hidden="true">#</a> 单例Bean的线程安全问题</h2><blockquote><p>单例bean存在线程安全问题，因为当多个线程操作同一个对象时，是存在资源竞争的</p></blockquote><ul><li>常见的解决办法 <ul><li>在bean中尽量避免定义可变的成员变量</li><li>在类中定义ThreadLocal成员变量，将需要的可变成员变量保存在ThreadLocal中</li></ul></li><li>大部分 bean 实际都是无状态的，比如xxDao、xxService，这种bean是线程安全的</li></ul>',12),p=[s];function c(g,B){return i(),a("div",null,p)}const u=e(r,[["render",c],["__file","spring.html.vue"]]);export{u as default};
