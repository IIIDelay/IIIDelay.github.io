<!DOCTYPE html>
<html lang="en-US" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.61" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://mister-hope.github.io/en/distributed/cache/redis.html"><meta property="og:site_name" content="IIIDelay的 Blog"><meta property="og:title" content="Redis面试题"><meta property="og:description" content="Redis面试题 redis常见面试题：吃透这份Redis学习笔记，直接把阿里面试官按在地上摩擦！ 1. 什么是redis？ Redis (Remote Dictionary Server)就是一个使用 C 语言开发的数据库，与传统数据库不同的是 Redis 的数据是存在内存中的 ，也就是它是内存数据库，所以读写速度非常快，因此 Redis 被广泛应用于缓存方向。"><meta property="og:type" content="article"><meta property="og:image" content="https://mister-hope.github.io/"><meta property="og:locale" content="en-US"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image:alt" content="Redis面试题"><meta property="article:author" content="Mr.IIIDelay"><meta property="article:tag" content="yellow"><meta property="article:tag" content="curly"><meta property="article:tag" content="long"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"Redis面试题","image":["https://mister-hope.github.io/"],"dateModified":null,"author":[{"@type":"Person","name":"Mr.IIIDelay","url":"https://mrhope.site"}]}</script><title>Redis面试题 | IIIDelay的 Blog</title><meta name="description" content="Redis面试题 redis常见面试题：吃透这份Redis学习笔记，直接把阿里面试官按在地上摩擦！ 1. 什么是redis？ Redis (Remote Dictionary Server)就是一个使用 C 语言开发的数据库，与传统数据库不同的是 Redis 的数据是存在内存中的 ，也就是它是内存数据库，所以读写速度非常快，因此 Redis 被广泛应用于缓存方向。">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d1e1f;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/assets/style-6a04a3cc.css" as="style"><link rel="stylesheet" href="/assets/style-6a04a3cc.css">
    <link rel="modulepreload" href="/assets/app-50a824e8.js"><link rel="modulepreload" href="/assets/framework-b5ea9e64.js"><link rel="modulepreload" href="/assets/redis.html-cd83f8a8.js"><link rel="modulepreload" href="/assets/redis.html-c1b5bdc0.js"><link rel="prefetch" href="/assets/intro.html-3cd3e86c.js" as="script"><link rel="prefetch" href="/assets/index.html-25ccf11e.js" as="script"><link rel="prefetch" href="/assets/slides.html-9b79b21a.js" as="script"><link rel="prefetch" href="/assets/disable.html-5833c3eb.js" as="script"><link rel="prefetch" href="/assets/encrypt.html-5511ae0f.js" as="script"><link rel="prefetch" href="/assets/markdown.html-e4562c5e.js" as="script"><link rel="prefetch" href="/assets/page.html-5677046a.js" as="script"><link rel="prefetch" href="/assets/index.html-046ad4b0.js" as="script"><link rel="prefetch" href="/assets/intro.html-7d3ea627.js" as="script"><link rel="prefetch" href="/assets/index.html-fb2a0ee3.js" as="script"><link rel="prefetch" href="/assets/slides.html-9a7b8de6.js" as="script"><link rel="prefetch" href="/assets/disable.html-cf2277db.js" as="script"><link rel="prefetch" href="/assets/encrypt.html-5219ca3b.js" as="script"><link rel="prefetch" href="/assets/markdown.html-3b8712bd.js" as="script"><link rel="prefetch" href="/assets/page.html-9f106f64.js" as="script"><link rel="prefetch" href="/assets/index.html-c3796375.js" as="script"><link rel="prefetch" href="/assets/disable.html-19217888.js" as="script"><link rel="prefetch" href="/assets/encrypt.html-f9f4cdf1.js" as="script"><link rel="prefetch" href="/assets/markdown.html-890091b1.js" as="script"><link rel="prefetch" href="/assets/page.html-bf9b0ca5.js" as="script"><link rel="prefetch" href="/assets/index.html-28d85643.js" as="script"><link rel="prefetch" href="/assets/index.html-423a4e50.js" as="script"><link rel="prefetch" href="/assets/mysql.html-5a0be5f6.js" as="script"><link rel="prefetch" href="/assets/postgresql.html-65cc7a0e.js" as="script"><link rel="prefetch" href="/assets/mongodb.html-90acf583.js" as="script"><link rel="prefetch" href="/assets/idwork.html-d4ae77b6.js" as="script"><link rel="prefetch" href="/assets/css.html-4f40a97b.js" as="script"><link rel="prefetch" href="/assets/html.html-a3b9acb3.js" as="script"><link rel="prefetch" href="/assets/js.html-ce916738.js" as="script"><link rel="prefetch" href="/assets/nginx.html-de1349d5.js" as="script"><link rel="prefetch" href="/assets/elaticsearch.html-0843c52d.js" as="script"><link rel="prefetch" href="/assets/rocketmq.html-976cd0a4.js" as="script"><link rel="prefetch" href="/assets/vue.html-de7169f8.js" as="script"><link rel="prefetch" href="/assets/jvm.html-8f089829.js" as="script"><link rel="prefetch" href="/assets/list.html-7ad4f4ef.js" as="script"><link rel="prefetch" href="/assets/map.html-74dc8f5e.js" as="script"><link rel="prefetch" href="/assets/set.html-8f466ae8.js" as="script"><link rel="prefetch" href="/assets/juc.html-647653ba.js" as="script"><link rel="prefetch" href="/assets/thread.html-bc15370b.js" as="script"><link rel="prefetch" href="/assets/mybatis.html-448b0268.js" as="script"><link rel="prefetch" href="/assets/spring.html-88b31e3c.js" as="script"><link rel="prefetch" href="/assets/springboot.html-90d3e17d.js" as="script"><link rel="prefetch" href="/assets/springmvc.html-91a46607.js" as="script"><link rel="prefetch" href="/assets/springcloud.html-f6fa6894.js" as="script"><link rel="prefetch" href="/assets/springcloudAlibaba.html-9d982f31.js" as="script"><link rel="prefetch" href="/assets/404.html-8d7ddf59.js" as="script"><link rel="prefetch" href="/assets/index.html-117f57c1.js" as="script"><link rel="prefetch" href="/assets/index.html-64c23b9f.js" as="script"><link rel="prefetch" href="/assets/index.html-f3603623.js" as="script"><link rel="prefetch" href="/assets/index.html-cdb1cd21.js" as="script"><link rel="prefetch" href="/assets/index.html-2daae4c3.js" as="script"><link rel="prefetch" href="/assets/index.html-4c9b9c86.js" as="script"><link rel="prefetch" href="/assets/index.html-f1134fa2.js" as="script"><link rel="prefetch" href="/assets/index.html-d8f510ea.js" as="script"><link rel="prefetch" href="/assets/index.html-5b0d539d.js" as="script"><link rel="prefetch" href="/assets/index.html-cbc6836f.js" as="script"><link rel="prefetch" href="/assets/index.html-78bed988.js" as="script"><link rel="prefetch" href="/assets/index.html-567289df.js" as="script"><link rel="prefetch" href="/assets/index.html-9dd75139.js" as="script"><link rel="prefetch" href="/assets/index.html-8bd5f926.js" as="script"><link rel="prefetch" href="/assets/index.html-1986a589.js" as="script"><link rel="prefetch" href="/assets/index.html-311ca7c9.js" as="script"><link rel="prefetch" href="/assets/index.html-9a1933f9.js" as="script"><link rel="prefetch" href="/assets/index.html-0b7262b3.js" as="script"><link rel="prefetch" href="/assets/index.html-273e9410.js" as="script"><link rel="prefetch" href="/assets/index.html-6daa24b2.js" as="script"><link rel="prefetch" href="/assets/index.html-e64a306a.js" as="script"><link rel="prefetch" href="/assets/index.html-cbcea2f3.js" as="script"><link rel="prefetch" href="/assets/index.html-8b43dfd1.js" as="script"><link rel="prefetch" href="/assets/index.html-b9502ddb.js" as="script"><link rel="prefetch" href="/assets/index.html-860a114f.js" as="script"><link rel="prefetch" href="/assets/index.html-782963b7.js" as="script"><link rel="prefetch" href="/assets/index.html-fb4b5ad1.js" as="script"><link rel="prefetch" href="/assets/index.html-fd7d15c8.js" as="script"><link rel="prefetch" href="/assets/index.html-2c51a30d.js" as="script"><link rel="prefetch" href="/assets/index.html-a0864148.js" as="script"><link rel="prefetch" href="/assets/index.html-5fc0e626.js" as="script"><link rel="prefetch" href="/assets/index.html-263613fb.js" as="script"><link rel="prefetch" href="/assets/index.html-cce1ce08.js" as="script"><link rel="prefetch" href="/assets/index.html-6851c096.js" as="script"><link rel="prefetch" href="/assets/index.html-4ff8c7b7.js" as="script"><link rel="prefetch" href="/assets/index.html-3ac086ff.js" as="script"><link rel="prefetch" href="/assets/index.html-d1d41465.js" as="script"><link rel="prefetch" href="/assets/index.html-3b736981.js" as="script"><link rel="prefetch" href="/assets/index.html-2adeca1e.js" as="script"><link rel="prefetch" href="/assets/index.html-7f81a989.js" as="script"><link rel="prefetch" href="/assets/index.html-329bd63b.js" as="script"><link rel="prefetch" href="/assets/index.html-379e8d35.js" as="script"><link rel="prefetch" href="/assets/index.html-4d158d84.js" as="script"><link rel="prefetch" href="/assets/index.html-4b5c4258.js" as="script"><link rel="prefetch" href="/assets/index.html-c954921e.js" as="script"><link rel="prefetch" href="/assets/index.html-c5d3e9ea.js" as="script"><link rel="prefetch" href="/assets/index.html-50403a74.js" as="script"><link rel="prefetch" href="/assets/index.html-4fa66a8d.js" as="script"><link rel="prefetch" href="/assets/index.html-68cb03c4.js" as="script"><link rel="prefetch" href="/assets/index.html-72a13ac8.js" as="script"><link rel="prefetch" href="/assets/index.html-ff2f0e41.js" as="script"><link rel="prefetch" href="/assets/index.html-b882d86f.js" as="script"><link rel="prefetch" href="/assets/index.html-e497066a.js" as="script"><link rel="prefetch" href="/assets/index.html-0a302d00.js" as="script"><link rel="prefetch" href="/assets/index.html-6b6a187d.js" as="script"><link rel="prefetch" href="/assets/index.html-b9a16419.js" as="script"><link rel="prefetch" href="/assets/index.html-8eaf66f1.js" as="script"><link rel="prefetch" href="/assets/index.html-b4337409.js" as="script"><link rel="prefetch" href="/assets/index.html-5aac597d.js" as="script"><link rel="prefetch" href="/assets/index.html-76d6ea93.js" as="script"><link rel="prefetch" href="/assets/index.html-e18f4f65.js" as="script"><link rel="prefetch" href="/assets/index.html-644eebf5.js" as="script"><link rel="prefetch" href="/assets/index.html-1d6c1649.js" as="script"><link rel="prefetch" href="/assets/index.html-9951b9f6.js" as="script"><link rel="prefetch" href="/assets/index.html-72a61392.js" as="script"><link rel="prefetch" href="/assets/index.html-5866170e.js" as="script"><link rel="prefetch" href="/assets/index.html-e9a7e2c1.js" as="script"><link rel="prefetch" href="/assets/index.html-d53bd539.js" as="script"><link rel="prefetch" href="/assets/index.html-a1ad137c.js" as="script"><link rel="prefetch" href="/assets/index.html-9820ca5c.js" as="script"><link rel="prefetch" href="/assets/index.html-5fbb46f5.js" as="script"><link rel="prefetch" href="/assets/index.html-ee8320a3.js" as="script"><link rel="prefetch" href="/assets/index.html-72c728d5.js" as="script"><link rel="prefetch" href="/assets/index.html-b9068540.js" as="script"><link rel="prefetch" href="/assets/index.html-0b3ed243.js" as="script"><link rel="prefetch" href="/assets/index.html-d34fcedf.js" as="script"><link rel="prefetch" href="/assets/index.html-bc23c6fe.js" as="script"><link rel="prefetch" href="/assets/index.html-4f6ef9fe.js" as="script"><link rel="prefetch" href="/assets/index.html-0ca60537.js" as="script"><link rel="prefetch" href="/assets/index.html-57a98e87.js" as="script"><link rel="prefetch" href="/assets/index.html-a25d2e5c.js" as="script"><link rel="prefetch" href="/assets/index.html-8fb62574.js" as="script"><link rel="prefetch" href="/assets/index.html-653530f0.js" as="script"><link rel="prefetch" href="/assets/index.html-c7ccd5a2.js" as="script"><link rel="prefetch" href="/assets/index.html-e6bad382.js" as="script"><link rel="prefetch" href="/assets/index.html-92d775ea.js" as="script"><link rel="prefetch" href="/assets/index.html-b3374bc9.js" as="script"><link rel="prefetch" href="/assets/index.html-04f02cbe.js" as="script"><link rel="prefetch" href="/assets/index.html-f0912e82.js" as="script"><link rel="prefetch" href="/assets/index.html-82c102ea.js" as="script"><link rel="prefetch" href="/assets/index.html-b83f8df8.js" as="script"><link rel="prefetch" href="/assets/index.html-467ea473.js" as="script"><link rel="prefetch" href="/assets/index.html-94c1a7a1.js" as="script"><link rel="prefetch" href="/assets/index.html-8dd82581.js" as="script"><link rel="prefetch" href="/assets/intro.html-88bbbba3.js" as="script"><link rel="prefetch" href="/assets/index.html-f6fd53c8.js" as="script"><link rel="prefetch" href="/assets/slides.html-b6ffd39e.js" as="script"><link rel="prefetch" href="/assets/disable.html-66a5c74b.js" as="script"><link rel="prefetch" href="/assets/encrypt.html-3033137a.js" as="script"><link rel="prefetch" href="/assets/markdown.html-cb727f4d.js" as="script"><link rel="prefetch" href="/assets/page.html-8678032e.js" as="script"><link rel="prefetch" href="/assets/index.html-3499a5f6.js" as="script"><link rel="prefetch" href="/assets/intro.html-63d51bdd.js" as="script"><link rel="prefetch" href="/assets/index.html-5d64d0b2.js" as="script"><link rel="prefetch" href="/assets/slides.html-af8ef7ce.js" as="script"><link rel="prefetch" href="/assets/disable.html-5dcf458d.js" as="script"><link rel="prefetch" href="/assets/encrypt.html-1aabfd29.js" as="script"><link rel="prefetch" href="/assets/markdown.html-b9914991.js" as="script"><link rel="prefetch" href="/assets/page.html-8e83bdc7.js" as="script"><link rel="prefetch" href="/assets/index.html-b594eaa5.js" as="script"><link rel="prefetch" href="/assets/disable.html-2277927a.js" as="script"><link rel="prefetch" href="/assets/encrypt.html-0f82cb4a.js" as="script"><link rel="prefetch" href="/assets/markdown.html-5245eceb.js" as="script"><link rel="prefetch" href="/assets/page.html-1004e52f.js" as="script"><link rel="prefetch" href="/assets/index.html-b3c715af.js" as="script"><link rel="prefetch" href="/assets/index.html-dbf81064.js" as="script"><link rel="prefetch" href="/assets/mysql.html-c6a831a9.js" as="script"><link rel="prefetch" href="/assets/postgresql.html-ae4c86e1.js" as="script"><link rel="prefetch" href="/assets/mongodb.html-c8cedc56.js" as="script"><link rel="prefetch" href="/assets/idwork.html-7d2f83b3.js" as="script"><link rel="prefetch" href="/assets/css.html-006c799c.js" as="script"><link rel="prefetch" href="/assets/html.html-1323cb24.js" as="script"><link rel="prefetch" href="/assets/js.html-aafa85cf.js" as="script"><link rel="prefetch" href="/assets/nginx.html-96968426.js" as="script"><link rel="prefetch" href="/assets/elaticsearch.html-67956eb2.js" as="script"><link rel="prefetch" href="/assets/rocketmq.html-8c8bc6fa.js" as="script"><link rel="prefetch" href="/assets/vue.html-a28e63e0.js" as="script"><link rel="prefetch" href="/assets/jvm.html-50e5372d.js" as="script"><link rel="prefetch" href="/assets/list.html-ae9043b4.js" as="script"><link rel="prefetch" href="/assets/map.html-3d18fdea.js" as="script"><link rel="prefetch" href="/assets/set.html-92d35319.js" as="script"><link rel="prefetch" href="/assets/juc.html-3033f723.js" as="script"><link rel="prefetch" href="/assets/thread.html-ca30083f.js" as="script"><link rel="prefetch" href="/assets/mybatis.html-067666aa.js" as="script"><link rel="prefetch" href="/assets/spring.html-d835cc1f.js" as="script"><link rel="prefetch" href="/assets/springboot.html-c5be012c.js" as="script"><link rel="prefetch" href="/assets/springmvc.html-59b25145.js" as="script"><link rel="prefetch" href="/assets/springcloud.html-8e6e289f.js" as="script"><link rel="prefetch" href="/assets/springcloudAlibaba.html-fe047c42.js" as="script"><link rel="prefetch" href="/assets/404.html-efcbdfb8.js" as="script"><link rel="prefetch" href="/assets/index.html-b9049faa.js" as="script"><link rel="prefetch" href="/assets/index.html-c3c2c32b.js" as="script"><link rel="prefetch" href="/assets/index.html-afb5bce3.js" as="script"><link rel="prefetch" href="/assets/index.html-5ec2fddd.js" as="script"><link rel="prefetch" href="/assets/index.html-da1eec3f.js" as="script"><link rel="prefetch" href="/assets/index.html-7b822086.js" as="script"><link rel="prefetch" href="/assets/index.html-ebf9fe5f.js" as="script"><link rel="prefetch" href="/assets/index.html-4f9a4b5f.js" as="script"><link rel="prefetch" href="/assets/index.html-9df0f0b3.js" as="script"><link rel="prefetch" href="/assets/index.html-c167fb4a.js" as="script"><link rel="prefetch" href="/assets/index.html-d7c67c90.js" as="script"><link rel="prefetch" href="/assets/index.html-178f0ee6.js" as="script"><link rel="prefetch" href="/assets/index.html-48e2a336.js" as="script"><link rel="prefetch" href="/assets/index.html-17eeb5a1.js" as="script"><link rel="prefetch" href="/assets/index.html-fbdff309.js" as="script"><link rel="prefetch" href="/assets/index.html-58b4f273.js" as="script"><link rel="prefetch" href="/assets/index.html-91822548.js" as="script"><link rel="prefetch" href="/assets/index.html-4d0f7e32.js" as="script"><link rel="prefetch" href="/assets/index.html-11b87b78.js" as="script"><link rel="prefetch" href="/assets/index.html-565f97fc.js" as="script"><link rel="prefetch" href="/assets/index.html-db9428bf.js" as="script"><link rel="prefetch" href="/assets/index.html-990bfc25.js" as="script"><link rel="prefetch" href="/assets/index.html-9de5fbad.js" as="script"><link rel="prefetch" href="/assets/index.html-7a26a869.js" as="script"><link rel="prefetch" href="/assets/index.html-b93c98f4.js" as="script"><link rel="prefetch" href="/assets/index.html-da90ef68.js" as="script"><link rel="prefetch" href="/assets/index.html-a3cf3b28.js" as="script"><link rel="prefetch" href="/assets/index.html-e82c4191.js" as="script"><link rel="prefetch" href="/assets/index.html-41c6d8bb.js" as="script"><link rel="prefetch" href="/assets/index.html-78efc0d0.js" as="script"><link rel="prefetch" href="/assets/index.html-074d1cea.js" as="script"><link rel="prefetch" href="/assets/index.html-298c38c9.js" as="script"><link rel="prefetch" href="/assets/index.html-f52000ab.js" as="script"><link rel="prefetch" href="/assets/index.html-ca4faf6e.js" as="script"><link rel="prefetch" href="/assets/index.html-065ae608.js" as="script"><link rel="prefetch" href="/assets/index.html-409f1932.js" as="script"><link rel="prefetch" href="/assets/index.html-616a6c28.js" as="script"><link rel="prefetch" href="/assets/index.html-7a0739b7.js" as="script"><link rel="prefetch" href="/assets/index.html-980af55e.js" as="script"><link rel="prefetch" href="/assets/index.html-c8e4cb15.js" as="script"><link rel="prefetch" href="/assets/index.html-c0990ba7.js" as="script"><link rel="prefetch" href="/assets/index.html-48db118f.js" as="script"><link rel="prefetch" href="/assets/index.html-85615883.js" as="script"><link rel="prefetch" href="/assets/index.html-edee18a6.js" as="script"><link rel="prefetch" href="/assets/index.html-b7547097.js" as="script"><link rel="prefetch" href="/assets/index.html-eefe09e4.js" as="script"><link rel="prefetch" href="/assets/index.html-166d26e5.js" as="script"><link rel="prefetch" href="/assets/index.html-177d03c9.js" as="script"><link rel="prefetch" href="/assets/index.html-ff2ab13e.js" as="script"><link rel="prefetch" href="/assets/index.html-b87283e0.js" as="script"><link rel="prefetch" href="/assets/index.html-6ee8b06d.js" as="script"><link rel="prefetch" href="/assets/index.html-7702533e.js" as="script"><link rel="prefetch" href="/assets/index.html-d65d8d73.js" as="script"><link rel="prefetch" href="/assets/index.html-a8902bc2.js" as="script"><link rel="prefetch" href="/assets/index.html-64389379.js" as="script"><link rel="prefetch" href="/assets/index.html-144bdc4f.js" as="script"><link rel="prefetch" href="/assets/index.html-28893f80.js" as="script"><link rel="prefetch" href="/assets/index.html-5d3e9263.js" as="script"><link rel="prefetch" href="/assets/index.html-4c6d8a73.js" as="script"><link rel="prefetch" href="/assets/index.html-28bf1937.js" as="script"><link rel="prefetch" href="/assets/index.html-737b3cec.js" as="script"><link rel="prefetch" href="/assets/index.html-87fc4efd.js" as="script"><link rel="prefetch" href="/assets/index.html-e3aa9d99.js" as="script"><link rel="prefetch" href="/assets/index.html-fec46570.js" as="script"><link rel="prefetch" href="/assets/index.html-9f82e955.js" as="script"><link rel="prefetch" href="/assets/index.html-69f2b437.js" as="script"><link rel="prefetch" href="/assets/index.html-f69eb88c.js" as="script"><link rel="prefetch" href="/assets/index.html-9a262995.js" as="script"><link rel="prefetch" href="/assets/index.html-1ee7a748.js" as="script"><link rel="prefetch" href="/assets/index.html-c20b48b5.js" as="script"><link rel="prefetch" href="/assets/index.html-5551fcaa.js" as="script"><link rel="prefetch" href="/assets/index.html-74822ef3.js" as="script"><link rel="prefetch" href="/assets/index.html-068b0923.js" as="script"><link rel="prefetch" href="/assets/index.html-fba460db.js" as="script"><link rel="prefetch" href="/assets/index.html-e12d1d6e.js" as="script"><link rel="prefetch" href="/assets/index.html-51ef4f9f.js" as="script"><link rel="prefetch" href="/assets/index.html-27aa4c3a.js" as="script"><link rel="prefetch" href="/assets/index.html-7c752282.js" as="script"><link rel="prefetch" href="/assets/index.html-6ff47688.js" as="script"><link rel="prefetch" href="/assets/index.html-a36273be.js" as="script"><link rel="prefetch" href="/assets/index.html-b2a58a8d.js" as="script"><link rel="prefetch" href="/assets/index.html-2cfeeffe.js" as="script"><link rel="prefetch" href="/assets/index.html-e3b7b7c5.js" as="script"><link rel="prefetch" href="/assets/index.html-8447273f.js" as="script"><link rel="prefetch" href="/assets/index.html-025251c7.js" as="script"><link rel="prefetch" href="/assets/index.html-890a76e8.js" as="script"><link rel="prefetch" href="/assets/index.html-8128a73c.js" as="script"><link rel="prefetch" href="/assets/index.html-d80f1d2d.js" as="script"><link rel="prefetch" href="/assets/index.html-cd3cd59c.js" as="script"><link rel="prefetch" href="/assets/index.html-2ad7ffac.js" as="script"><link rel="prefetch" href="/assets/index.html-07adeb48.js" as="script"><link rel="prefetch" href="/assets/index.html-8c0771f4.js" as="script"><link rel="prefetch" href="/assets/index.html-89bfd3d4.js" as="script"><link rel="prefetch" href="/assets/index.html-8e0d7594.js" as="script"><link rel="prefetch" href="/assets/giscus-16d370b8.js" as="script"><link rel="prefetch" href="/assets/auto-ba5ecab5.js" as="script"><link rel="prefetch" href="/assets/index-8764208e.js" as="script"><link rel="prefetch" href="/assets/flowchart-35969cab.js" as="script"><link rel="prefetch" href="/assets/mermaid.core-e2c044c8.js" as="script"><link rel="prefetch" href="/assets/highlight.esm-a794bb63.js" as="script"><link rel="prefetch" href="/assets/markdown.esm-d92a2fc9.js" as="script"><link rel="prefetch" href="/assets/math.esm-70a288c8.js" as="script"><link rel="prefetch" href="/assets/notes.esm-224f94d9.js" as="script"><link rel="prefetch" href="/assets/reveal.esm-e5069ce0.js" as="script"><link rel="prefetch" href="/assets/search.esm-2c3fba7d.js" as="script"><link rel="prefetch" href="/assets/zoom.esm-b83b91d0.js" as="script"><link rel="prefetch" href="/assets/VuePlayground-a7c60b9a.js" as="script"><link rel="prefetch" href="/assets/photoswipe.esm-6e6cbe40.js" as="script"><link rel="prefetch" href="/assets/SearchResult-29fc22a9.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to main content</a><!--]--><div class="theme-container has-toc"><!--[--><header class="navbar" id="navbar"><div class="navbar-start"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><a href="/" class="brand"><img class="logo" src="/logo.svg" alt="IIIDelay的 Blog"><!----><span class="site-name hide-in-pad">IIIDelay的 Blog</span></a><!--[--><!----><!--]--></div><div class="navbar-center"><!--[--><!----><!--]--><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/" class="nav-link" aria-label="Blog Home"><span class="font-icon icon iconfont icon-home" style=""></span>Blog Home<!----></a></div><div class="nav-item hide-in-mobile"><a href="/demo/" class="nav-link" aria-label="Demo"><span class="font-icon icon iconfont icon-discover" style=""></span>Demo<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="JavaBase"><span class="title"><span class="font-icon icon iconfont icon-edit" style=""></span>JavaBase</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>集合</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/en/javabase/collection/list.html" class="nav-link" aria-label="List"><span class="font-icon icon iconfont icon-edit" style=""></span>List<!----></a></li><li class="dropdown-subitem"><a href="/en/javabase/collection/set.html" class="nav-link" aria-label="Set"><span class="font-icon icon iconfont icon-edit" style=""></span>Set<!----></a></li><li class="dropdown-subitem"><a href="/en/javabase/collection/map.html" class="nav-link" aria-label="Map"><span class="font-icon icon iconfont icon-edit" style=""></span>Map<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>并发编程</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/en/javabase/juc/thread.html" class="nav-link" aria-label="Thread"><span class="font-icon icon iconfont icon-edit" style=""></span>Thread<!----></a></li><li class="dropdown-subitem"><a href="/en/javabase/juc/juc.html" class="nav-link" aria-label="JUC"><span class="font-icon icon iconfont icon-edit" style=""></span>JUC<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>进阶</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/en/javabase/advance/jvm.html" class="nav-link" aria-label="JVM"><span class="font-icon icon iconfont icon-edit" style=""></span>JVM<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="数据库"><span class="title"><span class="font-icon icon iconfont icon-edit" style=""></span>数据库</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>dbms</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/en/database/dbms/mysql.html" class="nav-link" aria-label="Mysql"><span class="font-icon icon iconfont icon-edit" style=""></span>Mysql<!----></a></li><li class="dropdown-subitem"><a href="/en/database/dbms/postgresql.html" class="nav-link" aria-label="Postgresql"><span class="font-icon icon iconfont icon-edit" style=""></span>Postgresql<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>NoSql</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/en/database/nosql/mongodb.html" class="nav-link" aria-label="MongoDB"><span class="font-icon icon iconfont icon-edit" style=""></span>MongoDB<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="分布式"><span class="title"><span class="font-icon icon iconfont icon-edit" style=""></span>分布式</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Cache</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a aria-current="page" href="/en/distributed/cache/redis.html" class="router-link-active router-link-exact-active nav-link active" aria-label="Redis"><span class="font-icon icon iconfont icon-edit" style=""></span>Redis<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Load-Balance</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/en/distributed/loadbalance/nginx.html" class="nav-link" aria-label="Nginx"><span class="font-icon icon iconfont icon-edit" style=""></span>Nginx<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>MQS</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/en/distributed/mqs/rocketmq.html" class="nav-link" aria-label="RocketMQ"><span class="font-icon icon iconfont icon-edit" style=""></span>RocketMQ<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Common</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/en/distributed/common/idwork.html" class="nav-link" aria-label="分布式ID"><span class="font-icon icon iconfont icon-edit" style=""></span>分布式ID<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="JavaEE"><span class="title"><span class="font-icon icon iconfont icon-edit" style=""></span>JavaEE</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Spring-Framework</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/en/javaee/spring_framework/spring.html" class="nav-link" aria-label="Spring"><span class="font-icon icon iconfont icon-edit" style=""></span>Spring<!----></a></li><li class="dropdown-subitem"><a href="/en/javaee/spring_framework/springmvc.html" class="nav-link" aria-label="SpringMVC"><span class="font-icon icon iconfont icon-edit" style=""></span>SpringMVC<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>ORM</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/en/javaee/orm/mybatis.html" class="nav-link" aria-label="Mybatis"><span class="font-icon icon iconfont icon-edit" style=""></span>Mybatis<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="微服务"><span class="title"><span class="font-icon icon iconfont icon-edit" style=""></span>微服务</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>spring微服务体系</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/en/mricoservices/springio/springcloud.html" class="nav-link" aria-label="Spring-Cloud"><span class="font-icon icon iconfont icon-edit" style=""></span>Spring-Cloud<!----></a></li><li class="dropdown-subitem"><a href="/en/mricoservices/springio/springcloudAlibaba.html" class="nav-link" aria-label="Spring-Cloud Alibaba"><span class="font-icon icon iconfont icon-edit" style=""></span>Spring-Cloud Alibaba<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="大前端"><span class="title"><span class="font-icon icon iconfont icon-edit" style=""></span>大前端</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Base</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/en/h5/base/html.html" class="nav-link" aria-label="HTML"><span class="font-icon icon iconfont icon-edit" style=""></span>HTML<!----></a></li><li class="dropdown-subitem"><a href="/en/h5/base/css.html" class="nav-link" aria-label="CSS"><span class="font-icon icon iconfont icon-edit" style=""></span>CSS<!----></a></li><li class="dropdown-subitem"><a href="/en/h5/base/js.html" class="nav-link" aria-label="JavaScript"><span class="font-icon icon iconfont icon-edit" style=""></span>JavaScript<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Framework</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/en/h5/framework/vue.html" class="nav-link" aria-label="VUE"><span class="font-icon icon iconfont icon-edit" style=""></span>VUE<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a href="https://github.com/" rel="noopener noreferrer" target="_blank" aria-label="官网" class="nav-link"><span class="font-icon icon iconfont icon-note" style=""></span>官网<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div></nav><!--[--><!----><!--]--></div><div class="navbar-end"><!--[--><!----><!--]--><div class="nav-item"><div class="dropdown-wrapper i18n-dropdown"><button class="dropdown-title" type="button" aria-label="Select language"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon i18n-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="i18n icon" style="width:1rem;height:1rem;vertical-align:middle;"><path d="M379.392 460.8 494.08 575.488l-42.496 102.4L307.2 532.48 138.24 701.44l-71.68-72.704L234.496 460.8l-45.056-45.056c-27.136-27.136-51.2-66.56-66.56-108.544h112.64c7.68 14.336 16.896 27.136 26.112 35.84l45.568 46.08 45.056-45.056C382.976 312.32 409.6 247.808 409.6 204.8H0V102.4h256V0h102.4v102.4h256v102.4H512c0 70.144-37.888 161.28-87.04 210.944L378.88 460.8zM576 870.4 512 1024H409.6l256-614.4H768l256 614.4H921.6l-64-153.6H576zM618.496 768h196.608L716.8 532.48 618.496 768z"></path></svg><!--]--><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a aria-current="page" href="/en/distributed/cache/redis.html" class="router-link-active router-link-exact-active nav-link active" aria-label="English"><!---->English<!----></a></li><li class="dropdown-item"><a href="/zh/" class="nav-link" aria-label="简体中文"><!---->简体中文<!----></a></li></ul></button></div></div><div class="nav-item"><a class="repo-link" href="https://github.com/vuepress-theme-hope/vuepress-theme-hope" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!--[--><button class="search-pro-button" role="search" aria-label="Search"><svg xmlns="http://www.w3.org/2000/svg" class="icon search-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="search icon"><path d="M192 480a256 256 0 1 1 512 0 256 256 0 0 1-512 0m631.776 362.496-143.2-143.168A318.464 318.464 0 0 0 768 480c0-176.736-143.264-320-320-320S128 303.264 128 480s143.264 320 320 320a318.016 318.016 0 0 0 184.16-58.592l146.336 146.368c12.512 12.48 32.768 12.48 45.28 0 12.48-12.512 12.48-32.768 0-45.28"></path></svg><div class="placeholder">Search</div><div class="key-hints"><kbd class="key">Ctrl</kbd><kbd class="key">K</kbd></div></button><!--]--><!--[--><!----><!--]--><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside class="sidebar" id="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><a href="/" class="nav-link sidebar-link sidebar-page" aria-label="Blog Home"><span class="font-icon icon iconfont icon-home" style=""></span>Blog Home<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><section class="sidebar-group"><p class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-discover" style=""></span><a href="/demo/" class="title">Demo</a><!----></p><ul class="sidebar-links"><li><!--[--><a href="/demo/page.html" class="nav-link sidebar-link sidebar-page" aria-label="Page Config"><span class="font-icon icon iconfont icon-page" style=""></span>Page Config<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/demo/markdown.html" class="nav-link sidebar-link sidebar-page" aria-label="Markdown Enhance"><span class="font-icon icon iconfont icon-markdown" style=""></span>Markdown Enhance<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/demo/disable.html" class="nav-link sidebar-link sidebar-page" aria-label="Disabling layout and features"><span class="font-icon icon iconfont icon-config" style=""></span>Disabling layout and features<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/demo/encrypt.html" class="nav-link sidebar-link sidebar-page" aria-label="Encryption Article"><span class="font-icon icon iconfont icon-lock" style=""></span>Encryption Article<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="sidebar-group"><p class="sidebar-heading"><span class="font-icon icon iconfont icon-note" style=""></span><span class="title">Articles</span><!----></p><ul class="sidebar-links"></ul></section></li><li><!--[--><a href="/intro.html" class="nav-link sidebar-link sidebar-page" aria-label="Intro Page"><span class="font-icon icon iconfont icon-info" style=""></span>Intro Page<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/slides.html" class="nav-link sidebar-link sidebar-page" aria-label="Slide page"><span class="font-icon icon iconfont icon-slides" style=""></span>Slide page<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><span class="font-icon icon iconfont icon-edit" style=""></span>Redis面试题</h1><div class="page-info"><span class="page-author-info" aria-label="Author🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://mrhope.site" target="_blank" rel="noopener noreferrer">Mr.IIIDelay</a></span><span property="author" content="Mr.IIIDelay"></span></span><!----><!----><!----><span class="page-reading-time-info" aria-label="Reading Time⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>About 99 min</span><meta property="timeRequired" content="PT99M"></span><span class="page-category-info" aria-label="Category🌈" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><span class="page-category-item category5 clickable" role="navigation">Cache</span><span class="page-category-item category7 clickable" role="navigation">NoSQL</span><meta property="articleSection" content="Cache,NoSQL"></span><span class="page-tag-info" aria-label="Tag🏷" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon tag-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="tag icon"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z"></path></svg><span class="page-tag-item tag8 clickable" role="navigation">yellow</span><span class="page-tag-item tag8 clickable" role="navigation">curly</span><span class="page-tag-item tag4 clickable" role="navigation">long</span><meta property="keywords" content="yellow,curly,long"></span></div><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">On This Page<button class="print-button" title="Print"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_1-什么是redis" class="router-link-active router-link-exact-active toc-link level2">1. 什么是redis？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_2-分布式缓存常见的技术选型" class="router-link-active router-link-exact-active toc-link level2">2. 分布式缓存常见的技术选型</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_2-1-缓存类型" class="router-link-active router-link-exact-active toc-link level3">2.1 缓存类型</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_2-1-redis-和-memcached-的区别和共同点" class="router-link-active router-link-exact-active toc-link level3">2.1 Redis 和 Memcached 的区别和共同点</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_3-redis有哪些优缺点" class="router-link-active router-link-exact-active toc-link level2">3. Redis有哪些优缺点？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_4-为什么要用-redis-为什么要用缓存" class="router-link-active router-link-exact-active toc-link level2">4. 为什么要用 Redis /为什么要用缓存？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_5-如何保障mysql和redis之间的数据一致性" class="router-link-active router-link-exact-active toc-link level2">5. 如何保障mysql和redis之间的数据一致性？</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#方案一-延时双删" class="router-link-active router-link-exact-active toc-link level3">方案一：延时双删</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#方案二-异步更新缓存-基于订阅binlog的同步机制" class="router-link-active router-link-exact-active toc-link level3">方案二：异步更新缓存(基于订阅binlog的同步机制)</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_6-redis有哪些数据类型及使用场景" class="router-link-active router-link-exact-active toc-link level2">6.Redis有哪些数据类型及使用场景</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#string" class="router-link-active router-link-exact-active toc-link level3">String</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#list" class="router-link-active router-link-exact-active toc-link level3">List</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#hash" class="router-link-active router-link-exact-active toc-link level3">Hash</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#set" class="router-link-active router-link-exact-active toc-link level3">Set</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#sorted-set" class="router-link-active router-link-exact-active toc-link level3">Sorted Set</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#bitmap" class="router-link-active router-link-exact-active toc-link level3">bitmap</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_7-redis持久化机制" class="router-link-active router-link-exact-active toc-link level2">7. Redis持久化机制</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_7-1-为什么要持久化" class="router-link-active router-link-exact-active toc-link level3">7.1 为什么要持久化？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_7-2-快照持久化-snapshotting-rdb" class="router-link-active router-link-exact-active toc-link level3">7.2 快照持久化(snapshotting，RDB)</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_7-3-只追加文件持久化-append-only-file-aof" class="router-link-active router-link-exact-active toc-link level3">7.3 只追加文件持久化(append-only file, AOF)</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_7-4-rdb持久化、aof持久化的区别" class="router-link-active router-link-exact-active toc-link level3">7.4 RDB持久化、AOF持久化的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_7-5-redis持久化数据和缓存怎么做扩容" class="router-link-active router-link-exact-active toc-link level3">7.5 Redis持久化数据和缓存怎么做扩容？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_7-6-rdb和aof如何选择" class="router-link-active router-link-exact-active toc-link level3">7.6 RDB和AOF如何选择？</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_8-redis过期键的删除策略" class="router-link-active router-link-exact-active toc-link level2">8. Redis过期键的删除策略</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_9-redis-内存淘汰机制了解么" class="router-link-active router-link-exact-active toc-link level2">9. Redis 内存淘汰机制了解么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_10-redis-key的过期时间和永久有效分别怎么设置" class="router-link-active router-link-exact-active toc-link level2">10. Redis key的过期时间和永久有效分别怎么设置？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_11-如何进行redis内存优化" class="router-link-active router-link-exact-active toc-link level2">11. 如何进行Redis内存优化？</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_1-key与value的优化" class="router-link-active router-link-exact-active toc-link level3">(1)key与value的优化</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_2-字符串拼接的优化" class="router-link-active router-link-exact-active toc-link level3">(2)字符串拼接的优化</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_3-编码优化" class="router-link-active router-link-exact-active toc-link level3">(3)编码优化</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_4-使用-lazy-free-特性" class="router-link-active router-link-exact-active toc-link level3">(4)使用 lazy free 特性</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_5-设置合理的键值过期时间" class="router-link-active router-link-exact-active toc-link level3">(5)设置合理的键值过期时间</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_6-禁用长耗时的查询命令" class="router-link-active router-link-exact-active toc-link level3">(6)禁用长耗时的查询命令</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_7-使用-slowlog-优化耗时命令" class="router-link-active router-link-exact-active toc-link level3">(7)使用 slowlog 优化耗时命令</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_8-使用-pipeline-批量操作数据" class="router-link-active router-link-exact-active toc-link level3">(8)使用 Pipeline 批量操作数据</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_9-避免大量数据同时失效" class="router-link-active router-link-exact-active toc-link level3">(9)避免大量数据同时失效</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_10-redis-连接池" class="router-link-active router-link-exact-active toc-link level3">(10)Redis 连接池</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_11-限制-redis-内存大小-使用合理的内存淘汰策略" class="router-link-active router-link-exact-active toc-link level3">(11)限制 Redis 内存大小，使用合理的内存淘汰策略</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_12-使用物理机而非虚拟机" class="router-link-active router-link-exact-active toc-link level3">(12)使用物理机而非虚拟机</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_13-使用合理的持久化策略" class="router-link-active router-link-exact-active toc-link level3">(13)使用合理的持久化策略</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_14-使用分布式架构来增加读写速度" class="router-link-active router-link-exact-active toc-link level3">(14)使用分布式架构来增加读写速度</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_12-redis线程模型" class="router-link-active router-link-exact-active toc-link level2">12. Redis线程模型</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_12-1-线程模型" class="router-link-active router-link-exact-active toc-link level3">12.1 线程模型</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_12-2-redis为什么这么快" class="router-link-active router-link-exact-active toc-link level3">12.2 Redis为什么这么快？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_12-3-redis的非阻塞io多路复用模型" class="router-link-active router-link-exact-active toc-link level3">12.3 Redis的非阻塞IO多路复用模型</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_12-4-redis6-0-之前-为什么不使用多线程" class="router-link-active router-link-exact-active toc-link level3">12.4 Redis6.0 之前 为什么不使用多线程？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_12-5-redis6-0-之后为何引入了多线程" class="router-link-active router-link-exact-active toc-link level3">12.5 Redis6.0 之后为何引入了多线程？</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_13-redis事务" class="router-link-active router-link-exact-active toc-link level2">13. Redis事务</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_13-1-实现原理" class="router-link-active router-link-exact-active toc-link level3">13.1 实现原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_13-2-事务的四大特性" class="router-link-active router-link-exact-active toc-link level3">13.2 事务的四大特性</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_14-3-redis-是不支持-roll-back-的原因" class="router-link-active router-link-exact-active toc-link level3">14.3 Redis 是不支持 roll back 的原因</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_14-4-事务失败处理-是否保证原子性" class="router-link-active router-link-exact-active toc-link level3">14.4 事务失败处理(是否保证原子性)</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_15-redis缓存异常" class="router-link-active router-link-exact-active toc-link level2">15. Redis缓存异常</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_15-1-缓存热点key" class="router-link-active router-link-exact-active toc-link level3">15.1 缓存热点key</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_15-2-缓存雪崩" class="router-link-active router-link-exact-active toc-link level3">15.2 缓存雪崩</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_15-3-缓存穿透" class="router-link-active router-link-exact-active toc-link level3">15.3 缓存穿透</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_15-4-缓存击穿" class="router-link-active router-link-exact-active toc-link level3">15.4 缓存击穿</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_15-5-缓存预热" class="router-link-active router-link-exact-active toc-link level3">15.5 缓存预热</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_15-6-缓存降级" class="router-link-active router-link-exact-active toc-link level3">15.6 缓存降级</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_16-分布式问题" class="router-link-active router-link-exact-active toc-link level2">16 分布式问题</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_16-1-redis实现分布式锁" class="router-link-active router-link-exact-active toc-link level3">16.1 Redis实现分布式锁？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_16-2-如何解决-redis-的并发竞争-key-问题" class="router-link-active router-link-exact-active toc-link level3">16.2 如何解决 Redis 的并发竞争 Key 问题？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_16-3-分布式redis是前期做还是后期规模上来了再做好-为什么" class="router-link-active router-link-exact-active toc-link level3">16.3 分布式Redis是前期做还是后期规模上来了再做好？为什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_16-4-什么是-redlock" class="router-link-active router-link-exact-active toc-link level3">16.4 什么是 RedLock？</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_17-集群方案" class="router-link-active router-link-exact-active toc-link level2">17 集群方案</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_17-1-redis主从复制" class="router-link-active router-link-exact-active toc-link level3">17.1 Redis主从复制</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_17-2-哨兵-sentinal-机制" class="router-link-active router-link-exact-active toc-link level3">17.2 哨兵(sentinal)机制</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#_17-3-redis-cluster-模式" class="router-link-active router-link-exact-active toc-link level3">17.3 Redis cluster 模式</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#参考" class="router-link-active router-link-exact-active toc-link level2">参考：</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#string-1" class="router-link-active router-link-exact-active toc-link level2">String</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#基本介绍" class="router-link-active router-link-exact-active toc-link level3">基本介绍</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#数据结构" class="router-link-active router-link-exact-active toc-link level3">数据结构</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#编码方式" class="router-link-active router-link-exact-active toc-link level3">编码方式</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#list-1" class="router-link-active router-link-exact-active toc-link level2">List</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#基本介绍-1" class="router-link-active router-link-exact-active toc-link level3">基本介绍</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#数据结构-1" class="router-link-active router-link-exact-active toc-link level3">数据结构</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#hash-1" class="router-link-active router-link-exact-active toc-link level2">Hash</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#基本介绍-2" class="router-link-active router-link-exact-active toc-link level3">基本介绍</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#数据结构-2" class="router-link-active router-link-exact-active toc-link level3">数据结构</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#dict" class="router-link-active router-link-exact-active toc-link level3">Dict</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#set-1" class="router-link-active router-link-exact-active toc-link level2">Set</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#基本介绍-3" class="router-link-active router-link-exact-active toc-link level3">基本介绍</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#数据结构-3" class="router-link-active router-link-exact-active toc-link level3">数据结构</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#zset" class="router-link-active router-link-exact-active toc-link level2">ZSet</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#基本介绍-4" class="router-link-active router-link-exact-active toc-link level3">基本介绍</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#数据结构-4" class="router-link-active router-link-exact-active toc-link level3">数据结构</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#跳跃表" class="router-link-active router-link-exact-active toc-link level3">跳跃表</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#bitmaps" class="router-link-active router-link-exact-active toc-link level2">Bitmaps</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#基本介绍-5" class="router-link-active router-link-exact-active toc-link level3">基本介绍</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#相关命令" class="router-link-active router-link-exact-active toc-link level3">相关命令</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#bitmaps与set对比" class="router-link-active router-link-exact-active toc-link level3">Bitmaps与set对比</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#hyperloglog" class="router-link-active router-link-exact-active toc-link level2">HyperLogLog</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#基本介绍-6" class="router-link-active router-link-exact-active toc-link level3">基本介绍</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#相关命令-1" class="router-link-active router-link-exact-active toc-link level3">相关命令</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#geospatial" class="router-link-active router-link-exact-active toc-link level2">Geospatial</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#基本介绍-7" class="router-link-active router-link-exact-active toc-link level3">基本介绍</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#相关命令-2" class="router-link-active router-link-exact-active toc-link level3">相关命令</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/en/distributed/cache/redis.html#参看" class="router-link-active router-link-exact-active toc-link level2">参看：</a></li><!----><!--]--></ul></div><!--[--><!----><!--]--></aside></div><!----><div class="theme-hope-content"><h1 id="redis面试题" tabindex="-1"><a class="header-anchor" href="#redis面试题" aria-hidden="true">#</a> Redis面试题</h1><p>redis常见面试题：<a href="https://zhuanlan.zhihu.com/p/354314607" target="_blank" rel="noopener noreferrer">吃透这份Redis学习笔记，直接把阿里面试官按在地上摩擦！<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h2 id="_1-什么是redis" tabindex="-1"><a class="header-anchor" href="#_1-什么是redis" aria-hidden="true">#</a> 1. 什么是redis？</h2><p><strong>Redis (Remote Dictionary Server)就是一个使用 C 语言开发的数据库</strong>，与传统数据库不同的是 <strong>Redis 的数据是存在内存中的</strong> ，也就是它是内存数据库，所以读写速度非常快，因此 Redis 被广泛应用于缓存方向。</p><p><strong>Redis 除了做缓存之外，Redis 也经常用来做分布式锁，甚至是消息队列。</strong></p><p><strong>Redis 提供了多种数据类型来支持不同的业务场景。Redis 还支持事务 、持久化、Lua 脚本、多种集群方案。</strong></p><h2 id="_2-分布式缓存常见的技术选型" tabindex="-1"><a class="header-anchor" href="#_2-分布式缓存常见的技术选型" aria-hidden="true">#</a> 2. 分布式缓存常见的技术选型</h2><h3 id="_2-1-缓存类型" tabindex="-1"><a class="header-anchor" href="#_2-1-缓存类型" aria-hidden="true">#</a> 2.1 缓存类型</h3><p>本地缓存是内存访问，没有远程交互开销，性能最好，但是受限于单机容量，一般缓存较小且无法扩展。</p><p>分布式缓存一般都具有良好的水平扩展能力，对较大数据量的场景也能应付自如。缺点就是需要进行远程请求，性能不如本地缓存。</p><p>分布式缓存主要解决的是单机缓存的容量受服务器限制并且无法保存通用的信息。因为，本地缓存只在当前服务里有效，比如如果你部署了两个相同的服务，他们两者之间的缓存数据是无法共同的。</p><p>Memcached 是分布式缓存最开始兴起的那会，比较常用的。后来，随着 Redis 的发展，大家慢慢都转而使用更加强大的 Redis 了。</p><p>为了平衡这种情况，实际业务中一般采用<strong>多级缓存</strong>，本地缓存只保存访问频率最高的部分热点数据，其他的热点数据放在分布式缓存中。</p><h3 id="_2-1-redis-和-memcached-的区别和共同点" tabindex="-1"><a class="header-anchor" href="#_2-1-redis-和-memcached-的区别和共同点" aria-hidden="true">#</a> 2.1 Redis 和 Memcached 的区别和共同点</h3><p><strong>共同点</strong> ：</p><ol><li>都是基于内存的数据库，一般都用来当做缓存使用。</li><li>都有过期策略。</li><li>两者的性能都非常高。</li></ol><p><strong>区别</strong> ：</p><ol><li><strong>Redis 支持更丰富的数据类型(支持更复杂的应用场景)</strong>。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。</li><li><strong>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memecache 把数据全部存在内存之中。</strong></li><li><strong>Redis 有灾难恢复机制。</strong> 因为可以把缓存中的数据持久化到磁盘上。</li><li><strong>Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。</strong></li><li><strong>Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的.</strong></li><li><strong>Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。</strong> (Redis 6.0 引入了多线程 IO )</li><li><strong>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。</strong></li><li><strong>Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。</strong></li></ol><p>相信看了上面的对比之后，我们已经没有什么理由可以选择使用 Memcached 来作为自己项目的分布式缓存了。</p><h2 id="_3-redis有哪些优缺点" tabindex="-1"><a class="header-anchor" href="#_3-redis有哪些优缺点" aria-hidden="true">#</a> 3. Redis有哪些优缺点？</h2><p>优点：</p><ul><li>性能极高 – Redis 能读的速度是 110000 次/s,写的速度是 81000 次/s 。</li><li>丰富的数据类型</li><li>原子 – Redis 的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。(多操作使用事务保证原子性)</li><li>丰富的特性 – Redis 还支持 publish/subscribe, 通知, key 过期等等特性。</li></ul><p>缺点：</p><ul><li>容量受到物理内存的限制,不能用作海量数据的高性能读写。因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</li></ul><h2 id="_4-为什么要用-redis-为什么要用缓存" tabindex="-1"><a class="header-anchor" href="#_4-为什么要用-redis-为什么要用缓存" aria-hidden="true">#</a> 4. 为什么要用 Redis /为什么要用缓存？</h2><p>从高性能和高并发的角度去思考。</p><p><strong>高性能</strong>：</p><p>用户第一次访问数据库中的高频数据比较慢(硬盘读取)，如果将<strong>用户高频访问而且不经常改变的数据</strong>放到redis，用户下次访问直接从缓存中读取(读取内存)，大大提高访问速度。</p><p>注：但是要注意数据库与缓存的数据一致性。</p><p><strong>高并发</strong>：</p><p>一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右(4 核 8g) ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+(就单机 redis 的情况，redis 集群的话会更高)</p><blockquote><p>QPS(Query Per Second)：服务器每秒可以执行的查询次数</p></blockquote><p>高频访问数据转移到缓存可以大大提升系统的并发能力。</p><h2 id="_5-如何保障mysql和redis之间的数据一致性" tabindex="-1"><a class="header-anchor" href="#_5-如何保障mysql和redis之间的数据一致性" aria-hidden="true">#</a> 5. 如何保障mysql和redis之间的数据一致性？</h2><figure><img src="/assets/202112021507099-d8b95cb2.jpg" alt="mysql和redis的数据一致性" tabindex="0" loading="lazy"><figcaption>mysql和redis的数据一致性</figcaption></figure><p><strong>缓存与数据库双写时数据不一致</strong>的问题。不管是先写数据库，再删除缓存；还是先删除缓存，再写库，都有可能出现数据不一致的情况。具体情况如下：</p><ol><li>如果删除了缓存Redis，还没有来得及写库MySQL，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。</li><li>如果先写了库，在删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。</li></ol><p>因为写和读是并发的，没法保证顺序,就会出现缓存和数据库的数据不一致的问题。如何解决？</p><h3 id="方案一-延时双删" tabindex="-1"><a class="header-anchor" href="#方案一-延时双删" aria-hidden="true">#</a> 方案一：延时双删</h3><p>在写库前后都进行<code>redis.del(key)</code>操作，并且设定合理的超时时间。</p><ul><li>伪代码如下：</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span><span class="token class-name">Object</span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>
    redis<span class="token punctuation">.</span><span class="token function">delKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    db<span class="token punctuation">.</span><span class="token function">updateData</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    redis<span class="token punctuation">.</span><span class="token function">delKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>具体的步骤就是：</strong></p><p>1)先删除缓存</p><p>2)再写数据库</p><p>3)休眠500毫秒</p><p>4)再次删除缓存 <strong>那么，这个500毫秒怎么确定的，具体该休眠多久呢？</strong></p><p>需要评估自己的项目的读数据业务逻辑的耗时。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。</p><p>当然这种策略还要考虑redis和数据库主从同步的耗时。最后的的写数据的休眠时间：则在读数据业务逻辑的耗时基础上，加几百ms即可。比如：休眠1秒。</p><p><strong>设置缓存过期时间</strong></p><p>从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。所有的写操作以数据库为准，只要到达缓存过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。</p><p><strong>该方案的弊端</strong></p><p>结合双删策略+缓存超时设置，这样最差的情况就是在超时时间内数据存在不一致，而且又增加了写请求的耗时。</p><h3 id="方案二-异步更新缓存-基于订阅binlog的同步机制" tabindex="-1"><a class="header-anchor" href="#方案二-异步更新缓存-基于订阅binlog的同步机制" aria-hidden="true">#</a> 方案二：<strong>异步更新缓存(基于订阅binlog的同步机制)</strong></h3><p><strong>整体思路：</strong></p><p>MySQL binlog增量订阅消费+消息队列+增量数据更新到redis</p><p><strong>1)读Redis</strong>：热数据基本都在Redis</p><p><strong>2)写MySQL</strong>:增删改都是操作MySQL</p><p><strong>3)更新Redis数据</strong>：MySQ的数据操作binlog，来更新到Redis</p><p><strong>Redis更新</strong></p><p><strong>1)数据操作主要分为两大块：</strong></p><ul><li>一个是全量(将全部数据一次写入到redis)</li><li>一个是增量(实时更新)</li></ul><p>这里说的是增量,指的是mysql的update、insert、delate变更数据。</p><p><strong>2)读取binlog后分析 ，利用消息队列,推送更新各台的redis缓存数据。</strong></p><p>这样一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新。</p><p>其实这种机制，很类似MySQL的主从备份机制，因为MySQL的主备也是通过binlog来实现的数据一致性。</p><p>这里可以结合使用canal(阿里的一款开源框架)，通过该框架可以对MySQL的binlog进行订阅，而canal正是模仿了mysql的slave数据库的备份请求，使得Redis的数据更新达到了相同的效果。</p><p>当然，这里的消息推送工具你也可以采用别的第三方：kafka、rabbitMQ等来实现推送更新Redis。</p><p>参看：<a href="https://my.oschina.net/jiagouzhan/blog/2990423" target="_blank" rel="noopener noreferrer">高并发架构系列：Redis缓存和MySQL数据一致性方案详解<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h2 id="_6-redis有哪些数据类型及使用场景" tabindex="-1"><a class="header-anchor" href="#_6-redis有哪些数据类型及使用场景" aria-hidden="true">#</a> 6.Redis有哪些数据类型及使用场景</h2><h3 id="string" tabindex="-1"><a class="header-anchor" href="#string" aria-hidden="true">#</a> String</h3><p>K-V结构</p><p>value如果是数字，可以进行计数操作</p><p>常用操作：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 返回 key 所储存的字符串值的长度</span>
strlen key 
<span class="token comment"># 批量设置 key-value 类型的值</span>
mset key1 value1 key2 value2
<span class="token comment"># 批量获取多个 key 对应的 value</span>
mget key1 key2 
 <span class="token comment"># 将 key 中储存的数字值增一</span>
incr number
 <span class="token comment"># 将 key 中储存的数字值减一</span>
decr number
<span class="token comment"># 数据在 60s 后过期</span>
expire key  <span class="token number">60</span> 
<span class="token comment"># 数据在 60s 后过期 (setex:[set] + [ex]pire)</span>
setex key <span class="token number">60</span> value 
<span class="token comment"># 查看数据还有多久过期</span>
ttl key
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用场景：常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。</p><h3 id="list" tabindex="-1"><a class="header-anchor" href="#list" aria-hidden="true">#</a> List</h3><p>Redis 的 list 的实现为一个 <strong>双向链表</strong>，即可以支持反向查找和遍历。特点是易于数据元素的插入和删除并且且可以灵活调整链表长度，但是链表的随机访问困难。</p><p><strong>应用场景:</strong> 发布与订阅或者说消息队列、慢查询。</p><p>常用操作：</p><p><strong>实现队列和栈</strong></p><figure><img src="/assets/20210628214025-c8a4be70.png" alt="redis实现栈和队列" tabindex="0" loading="lazy"><figcaption>redis实现栈和队列</figcaption></figure><p><strong>查看对应下标范围的列表元素(实现分页)</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 查看对应下标的list列表， 0 为 start,1为 end</span>
lrange myList <span class="token number">0</span> <span class="token number">1</span> 
<span class="token comment"># 查看列表中的所有元素，-1表示倒数第一</span>
lrange myList <span class="token number">0</span> <span class="token parameter variable">-1</span> 
查看链表长度
llen myList
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="hash" tabindex="-1"><a class="header-anchor" href="#hash" aria-hidden="true">#</a> Hash</h3><p>hash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。</p><p>hash 是一个 string 类型的 field 和 value 的映射表，<strong>特别适合用于存储对象</strong>，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。</p><p><strong>应用场景:</strong> 系统中对象数据的存储。</p><p>常用操作：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 存储</span>
hmset userInfoKey name <span class="token string">&quot;guide&quot;</span> description <span class="token string">&quot;dev&quot;</span> age <span class="token string">&quot;24&quot;</span>
<span class="token comment"># 查看 key 对应的 value中指定的字段是否存在</span>
hexists userInfoKey name 
<span class="token comment"># 获取存储在哈希表中指定字段的值</span>
hget userInfoKey name 
<span class="token comment"># 获取在哈希表中指定 key 的所有字段和值</span>
hgetall userInfoKey 
 <span class="token comment"># 获取 key 列表</span>
hkeys userInfoKey
<span class="token comment"># 获取 value 列表</span>
hvals userInfoKey 
<span class="token comment"># 修改某个字段对应的值</span>
hset userInfoKey name <span class="token string">&quot;GuideGeGe&quot;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="set" tabindex="-1"><a class="header-anchor" href="#set" aria-hidden="true">#</a> Set</h3><p>set 类似于 Java 中的 <code>HashSet</code> 。Redis 中的 set 类型是一种无序集合，集合中的元素没有先后顺序。当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选择，并且 <strong>set 提供了判断某个成员是否在一个 set 集合内的重要接口</strong>，这个也是 list 所不能提供的。</p><p>可以基于 set 轻易实现<strong>交集、并集、差集</strong>的操作。比如：你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。</p><p>常用操作：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 添加元素进去</span>
sadd mySet value1 value2 
<span class="token comment"># 查看 set 中所有的元素</span>
smembers mySet 
<span class="token comment"># 查看 set 的长度</span>
scard mySet
<span class="token comment"># 检查某个元素是否存在set 中，只能接收单个元素</span>
sismember mySet value1 
<span class="token comment"># 获取 mySet 和 mySet2 的交集并存放在 mySet3 中</span>
sinterstore mySet3 mySet mySet2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="sorted-set" tabindex="-1"><a class="header-anchor" href="#sorted-set" aria-hidden="true">#</a> Sorted Set</h3><p>和 set 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。</p><p><strong>应用场景：</strong> 需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息(可以理解为按消息维度的消息排行榜)等信息。</p><p>常用操作：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 添加元素到 sorted set 中 3.0 为权重</span>
zadd myZset <span class="token number">3.0</span> value1 
 <span class="token comment"># 一次添加多个元素</span>
zadd myZset <span class="token number">2.0</span> value2 <span class="token number">1.0</span> value3
<span class="token comment"># 查看 sorted set 中的元素数量</span>
zcard myZset 
<span class="token comment"># 查看某个 value 的权重</span>
zscore myZset value1 
<span class="token comment"># 顺序输出某个范围区间的元素，0 -1 表示输出所有元素</span>
zrange  myZset <span class="token number">0</span> <span class="token parameter variable">-1</span> 
<span class="token comment"># 逆序输出某个范围区间的元素，0 为 start  1 为 stop</span>
zrevrange  myZset <span class="token number">0</span> <span class="token number">1</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="bitmap" tabindex="-1"><a class="header-anchor" href="#bitmap" aria-hidden="true">#</a> bitmap</h3><p>bitmap 存储的是连续的二进制数字(0 和 1)，通过 bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 bitmap 本身会极大的节省储存空间。</p><p><strong>应用场景:</strong> 适合需要保存状态信息(比如是否签到、是否登录...)并需要进一步对这些信息进行分析的场景。比如用户签到情况、活跃用户情况、用户行为统计(比如是否点赞过某个视频)。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code># SETBIT 会返回之前位的值(默认是 0)这里会生成 7 个位
127.0.0.1:6379&gt; setbit mykey 7 1
(integer) 0
127.0.0.1:6379&gt; setbit mykey 7 0
(integer) 1
127.0.0.1:6379&gt; getbit mykey 7
(integer) 0
127.0.0.1:6379&gt; setbit mykey 6 1
(integer) 0
127.0.0.1:6379&gt; setbit mykey 8 1
(integer) 0
# 通过 bitcount 统计被被设置为 1 的位的数量。
127.0.0.1:6379&gt; bitcount mykey
(integer) 2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>针对上面提到的一些场景，这里进行进一步说明。</p><p><strong>使用场景一：用户行为分析</strong> 很多网站为了分析你的喜好，需要研究你点赞过的内容。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 记录你喜欢过 001 号小姐姐</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> setbit beauty_girl_001 uid 1Copy to clipboardErrorCopied
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>使用场景二：统计活跃用户</strong></p><p>使用时间作为 key，然后用户 ID 为 offset，如果当日活跃过就设置为 1</p><p>那么我该如果计算某几天/月/年的活跃用户呢(暂且约定，统计时间内只有有一天在线就称为活跃)，有请下一个 redis 的命令</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。</span>
<span class="token comment"># BITOP 命令支持 AND 、 OR 、 NOT 、 XOR 这四种操作中的任意一种参数</span>
BITOP operation destkey key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>Copy to clipboardErrorCopied
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>初始化数据：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> setbit <span class="token number">20210308</span> <span class="token number">1</span> <span class="token number">1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> setbit <span class="token number">20210308</span> <span class="token number">2</span> <span class="token number">1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> setbit <span class="token number">20210309</span> <span class="token number">1</span> <span class="token number">1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0Copy to clipboardErrorCopied
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>统计 20210308~20210309 总活跃用户数: 1</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> bitop and desk1 <span class="token number">20210308</span> <span class="token number">20210309</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> bitcount desk1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1Copy to clipboardErrorCopied
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>统计 20210308~20210309 在线活跃用户数: 2</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> bitop or desk2 <span class="token number">20210308</span> <span class="token number">20210309</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> bitcount desk2
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2Copy to clipboardErrorCopied
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>使用场景三：用户在线状态</strong></p><p>对于获取或者统计用户在线状态，使用 bitmap 是一个节约空间效率又高的一种方法。</p><p>只需要一个 key，然后用户 ID 为 offset，如果在线就设置为 1，不在线就设置为 0。</p><h2 id="_7-redis持久化机制" tabindex="-1"><a class="header-anchor" href="#_7-redis持久化机制" aria-hidden="true">#</a> 7. Redis持久化机制</h2><h3 id="_7-1-为什么要持久化" tabindex="-1"><a class="header-anchor" href="#_7-1-为什么要持久化" aria-hidden="true">#</a> 7.1 为什么要持久化？</h3><p>很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据(比如重启机器、机器故障之后恢复数据)，或者是为了防止系统故障而将数据备份到一个远程位置。</p><h3 id="_7-2-快照持久化-snapshotting-rdb" tabindex="-1"><a class="header-anchor" href="#_7-2-快照持久化-snapshotting-rdb" aria-hidden="true">#</a> 7.2 快照持久化(snapshotting，RDB)</h3><p>Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本/快照(<strong>RDB文件</strong>)。</p><p>Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本(Redis 主从结构，主要用来提高 Redis 性能)，还可以将快照留在原地以便重启服务器的时候使用。</p><p><strong>创建快照(RDB文件)</strong>：</p><p>在redis.conf中配置文件名称，默认为<strong>dump.rdb</strong></p><p>快照持久化是 Redis 默认采用的持久化方式，在 Redis.conf 配置文件中默认有此下配置：</p><div class="language-conf line-numbers-mode" data-ext="conf"><pre class="language-conf"><code>save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也可采用手动形式创建快照：</p><ul><li><code>SAVE</code>命令：阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求。</li><li><code>BGSAVE</code>命令：派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程(父进程)继续处理命令请求。</li></ul><p><strong>载入快照(RDB文件)</strong>：</p><p>Redis载入RDB文件并没有专门的命令，而是在Redis服务器启动时自动执行的。而且，Redis服务器启动时是否会载入RDB文件还取决于服务器是否启用了AOF持久化功能，具体判断逻辑为：</p><ul><li>只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据。</li><li>如果服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据。</li></ul><figure><img src="/assets/20210628222057-6c7793c6.png" alt="redis启动载入快照流程" tabindex="0" loading="lazy"><figcaption>redis启动载入快照流程</figcaption></figure><p>默认情况下，Redis服务器的AOF持久化功能是关闭的。</p><p><strong>如何进行备份？</strong></p><p>Redis会单独创建(fork)一个子进程来进行持久化，会先将数据写入到 一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。<strong>RDB的缺点是最后一次持久化后的数据可能丢失</strong>。</p><h3 id="_7-3-只追加文件持久化-append-only-file-aof" tabindex="-1"><a class="header-anchor" href="#_7-3-只追加文件持久化-append-only-file-aof" aria-hidden="true">#</a> 7.3 只追加文件持久化(append-only file, AOF)</h3><p>与快照持久化相比，AOF 持久化 的实时性更好，因此已成为主流的持久化方案。</p><p>默认情况下 Redis 没有开启 AOF方式的持久化，可以通过 <code>appendonly</code> 参数开启：</p><div class="language-conf line-numbers-mode" data-ext="conf"><pre class="language-conf"><code>appendonly yes
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入硬盘中的 AOF 文件。AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 appendonly.aof。</p><p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p><div class="language-conf line-numbers-mode" data-ext="conf"><pre class="language-conf"><code>appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度
appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘
appendfsync no        #让操作系统决定何时进行同步
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>appendfsync选项的默认值是everysec，也推荐使用这个值，因为既保证了效率又保证了安全性。</p><h4 id="redis-4-0-对于持久化机制的优化" tabindex="-1"><a class="header-anchor" href="#redis-4-0-对于持久化机制的优化" aria-hidden="true">#</a> <strong>Redis 4.0 对于持久化机制的优化</strong></h4><p>Redis 4.0 开始支持 RDB 和 AOF 的混合持久化(默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启)。</p><p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p><h4 id="aof-重写" tabindex="-1"><a class="header-anchor" href="#aof-重写" aria-hidden="true">#</a> <strong>AOF 重写</strong></h4><p>因为AOF持久化是通过保存被执行的写命令来记录数据库数据的，所以随着Redis服务器运行时间的增加，AOF文件中的内容会越来越多，文件的体积会越来越大，如果不做控制，会有以下2点坏处：</p><ol><li>过多的占用服务器磁盘空间，可能会对Redis服务器甚至整个宿主计算机造成影响。</li><li>AOF文件的体积越大，使用AOF文件来进行数据库还原所需的时间就越多。</li></ol><p>为了解决AOF文件体积越来越大的问题，Redis提供了AOF文件重写功能，即Redis服务器会创建一个新的AOF文件来替代现有的AOF文件，新旧两个AOF文件所保存的数据库数据相同，但新AOF文件不会包含任何浪费空间的冗余命令，所以新AOF文件的体积通常会比旧AOF文件的体积要小很多。</p><p><strong>原理</strong>：</p><p>AOF文件重写并不需要对现有的AOF文件进行任何读取、分析或者写入操作，而是通过读取服务器当前的数据库数据来实现的。</p><p>举例：</p><figure><img src="/assets/20210628223434-d9980665.png" alt="AOF 重写举例" tabindex="0" loading="lazy"><figcaption>AOF 重写举例</figcaption></figure><p>为了记录这个list键的状态，AOF文件需要保存上面执行的6条命令。</p><p>但list键的结果是“C” &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot;这样的数据，所以AOF文件重写时，可以用一条<code>RPUSH list “C” &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot;</code>命令来代替之前的六条命令，这样就可以将保存list键所需的命令从六条减少为一条了。</p><p>按照上面的原理，如果Redis服务器存储的键值对足够多，AOF文件重写生成的新AOF文件就会减少很多很多的冗余命令，进而大大减小了AOF文件的体积。</p><p>综上所述，<strong>AOF文件重写功能的实现原理为：</strong></p><p><strong>首先从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令。</strong></p><h4 id="aof后台重写" tabindex="-1"><a class="header-anchor" href="#aof后台重写" aria-hidden="true">#</a> <strong>AOF后台重写</strong></h4><p>因为AOF文件重写会进行大量的文件写入操作，所以执行这个操作的线程将被长时间阻塞。</p><p>因为Redis服务器使用单个线程来处理命令请求，所以如果由服务器进程直接执行这个操作，那么在重写AOF文件期间，服务器将无法处理客户端发送过来的命令请求。</p><p>为了避免上述问题，Redis将AOF文件重写功能放到子进程里执行，这样做有以下2个好处：</p><ol><li>子进程进行AOF文件重写期间，服务器进程(父进程)可以继续处理命令请求。</li><li>子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。</li></ol><p>AOF后台重写的步骤如下所示：</p><ol><li>服务器进程创建子进程，子进程开始AOF文件重写</li><li>从创建子进程开始，服务器进程执行的所有写命令不仅要写入AOF缓冲区，还要写入AOF重写缓冲区 <ol><li>写入AOF缓冲区的目的是为了同步到原有的AOF文件。</li><li>写入AOF重写缓冲区的目的是因为子进程在进行AOF文件重写期间，服务器进程还在继续处理命令请求，而新的命令可能会对现有的数据库进行修改，从而使得服务器当前的数据库数据和重写后的AOF文件所保存的数据库数据不一致。</li></ol></li><li>子进程完成AOF重写工作，向父进程发送一个信号，父进 程在接收到该信号后，会执行以下操作： 1.将AOF重写缓冲区中的所有内容写入到新AOF文件中，这样就保证了新AOF文件所保存的数据库数据和服务器当前的数据库数据是一致的。 2.对新的AOF文件进行改名，原子地覆盖现有的AOF文件，完成新旧两个AOF文件的替换。</li></ol><p>Redis提供了<code>BGREWRITEAOF</code>命令来执行以上步骤。</p><p>除了手动执行<code>BGREWRITEAOF</code>命令外，Redis还提供了2个配置项用来自动执行<code>BGREWRITEAOF</code>命令：</p><blockquote><p>auto-aof-rewrite-percentage 100 auto-aof-rewrite-min-size 64mb</p></blockquote><p>该配置表示，当AOF文件的体积大于64MB，并且AOF文件的体积比上一次重写之后的体积大了至少一倍(100%)，Redis将自动执行<code>BGREWRITEAOF</code>命令。</p><h3 id="_7-4-rdb持久化、aof持久化的区别" tabindex="-1"><a class="header-anchor" href="#_7-4-rdb持久化、aof持久化的区别" aria-hidden="true">#</a> 7.4 RDB持久化、AOF持久化的区别</h3><p><strong>实现方式</strong></p><p>RDB持久化是通过将某个时间点Redis服务器存储的数据保存到RDB文件中来实现持久化的。</p><p>AOF持久化是通过将Redis服务器执行的所有写命令保存到AOF文件中来实现持久化的。</p><p><strong>文件体积</strong></p><p>由上述实现方式可知，RDB持久化记录的是结果，AOF持久化记录的是过程，所以<strong>AOF持久化生成的AOF文件会有体积越来越大的问题</strong>，Redis提供了AOF重写功能来减小AOF文件体积。</p><p><strong>安全性</strong></p><p><strong>AOF持久化的安全性要比RDB持久化的安全性高</strong>，即如果发生机器故障，AOF持久化要比RDB持久化丢失的数据要少。</p><p>因为RDB持久化会丢失上次RDB持久化后写入的数据，而AOF持久化最多丢失1s之内写入的数据(使用默认everysec配置的话)。</p><p><strong>优先级</strong></p><p>由于上述的安全性问题，如果Redis服务器开启了AOF持久化功能，Redis服务器在启动时会使用AOF文件来还原数据，如果Redis服务器没有开启AOF持久化功能，Redis服务器在启动时会使用RDB文件来还原数据，所以AOF文件的优先级比RDB文件的优先级高。</p><h3 id="_7-5-redis持久化数据和缓存怎么做扩容" tabindex="-1"><a class="header-anchor" href="#_7-5-redis持久化数据和缓存怎么做扩容" aria-hidden="true">#</a> 7.5 Redis持久化数据和缓存怎么做扩容？</h3><p>1、如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。</p><p>2、如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况)，必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。</p><h3 id="_7-6-rdb和aof如何选择" tabindex="-1"><a class="header-anchor" href="#_7-6-rdb和aof如何选择" aria-hidden="true">#</a> 7.6 RDB和AOF如何选择？</h3><ul><li><p>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储</p></li><li><p>AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾. Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大。</p></li><li><p>只做缓存：如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式.</p></li><li><p>同时开启两种持久化方式</p><ul><li>在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据, 因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.</li><li>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？ 建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)， 快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。</li></ul></li><li><p>性能建议</p><ul><li><p>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。</p></li><li><p>如果使用AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。</p><p>代价，一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。</p></li><li><p>只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。</p></li><li><p>AOF默认超过原大小100%大小时重写可以改到适当的数值。</p></li></ul></li></ul><h2 id="_8-redis过期键的删除策略" tabindex="-1"><a class="header-anchor" href="#_8-redis过期键的删除策略" aria-hidden="true">#</a> 8. Redis过期键的删除策略</h2><p>如果假设你设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？</p><p>常用的过期数据的删除策略就两个(重要！自己造缓存轮子的时候需要格外考虑的东西)：</p><ol><li><strong>惰性删除</strong> ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li><li><strong>定期删除</strong> ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li></ol><p>定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 <strong>定期删除+惰性/懒汉式删除</strong> 。</p><p><strong>为什么不单独用定时删除策略？</strong></p><p>定时删除：用一个定时器来负责监视key，过期则自动删除，十分消耗CPU资源。在大量并发请求下，CPU要将时间应用在处理请求，而不是删除key。</p><p><strong>定期删除+惰性删除是如何工作的呢</strong>?</p><p>定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。</p><p>但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。</p><p>怎么解决这个问题呢？答案就是： <strong>Redis 内存淘汰机制。</strong></p><h2 id="_9-redis-内存淘汰机制了解么" tabindex="-1"><a class="header-anchor" href="#_9-redis-内存淘汰机制了解么" aria-hidden="true">#</a> 9. Redis 内存淘汰机制了解么？</h2><p>查看设置：在redis.conf中有一行配置<code>maxmemory-policy volatile-lru</code></p><p>如何设置：<code>config set maxmemory-policy allkeys-lru</code></p><p>Redis 提供 6 种数据淘汰策略：</p><ol><li><strong>volatile-lru(least recently used)</strong>：从已设置过期时间的数据集(server.db[i].expires)中挑选最近最少使用的数据淘汰</li><li><strong>volatile-ttl</strong>：从已设置过期时间的数据集(server.db[i].expires)中挑选将要过期的数据淘汰</li><li><strong>volatile-random</strong>：从已设置过期时间的数据集(server.db[i].expires)中任意选择数据淘汰</li><li><strong>allkeys-lru(least recently used)</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key(这个是最常用的)</li><li><strong>allkeys-random</strong>：从数据集(server.db[i].dict)中任意选择数据淘汰</li><li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li></ol><p>4.0 版本后增加以下两种：</p><ol><li><strong>volatile-lfu(least frequently used)</strong>：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰</li><li><strong>allkeys-lfu(least frequently used)</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li></ol><p>相关问题：<strong>MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据</strong>?</p><p>Redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。</p><p><strong>内存相关</strong>：</p><p>查看redis占用最大内存：<code>maxmemory &lt;bytes&gt;</code></p><p>如何修改redis内存大小：<code>config set maxmemory</code></p><p>redis默认内存大小：如果不设置最大内存大小或者设置最大内存大小为0，在64位操作系统下不限制内存大小，在32位操作系统下最多使用3GB内存。</p><p>生产上redis内存如何配置？一般推荐设置为最大物理内存的3/4</p><p>redis内存使用情况命令：<code>info memory</code></p><h2 id="_10-redis-key的过期时间和永久有效分别怎么设置" tabindex="-1"><a class="header-anchor" href="#_10-redis-key的过期时间和永久有效分别怎么设置" aria-hidden="true">#</a> 10. Redis key的过期时间和永久有效分别怎么设置？</h2><p><code>EXPIRE</code> 和 <code>PERSIST</code> 命令</p><h2 id="_11-如何进行redis内存优化" tabindex="-1"><a class="header-anchor" href="#_11-如何进行redis内存优化" aria-hidden="true">#</a> 11. 如何进行Redis内存优化？</h2><p>对于Redis中的所有对象在内部都是由一个种叫RedisObject的数据结构来实现。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisObject</span><span class="token punctuation">{</span>
    <span class="token comment">//类型</span>
	<span class="token keyword">unsigned</span> type<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>
	
	<span class="token comment">//编码</span>
	<span class="token keyword">unsigned</span> encoding<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>
	
	<span class="token comment">//指向底层实现的数据结构的指针</span>
	<span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>从RedisObject的结构得知Redis存储一个对象的内存成本是：type + encoding + *ptr指向的数据(数据本身)。</strong></p><h3 id="_1-key与value的优化" tabindex="-1"><a class="header-anchor" href="#_1-key与value的优化" aria-hidden="true">#</a> (1)key与value的优化</h3><ul><li><strong>过滤不必要的数据</strong>。比如我们缓存一个用户的信息,我们通常只要缓存基本信息比如：呢称，性别，角色类型，生日即可。其它的一些不必要信息，我们可以过滤掉。</li><li><strong>精简数据</strong>。比如角色类型：&quot;VIP&quot;。我们可以指定1代表&quot;VIP&quot;，不直接存储VIP字符串。</li><li><strong>数据压缩</strong>。存进redis之前我们还可以对内容进行压缩，常用的工具有GZIP、Snappy。</li><li><strong>缩短键值对的存储长度</strong><ul><li>在 key 不变的情况下，value 值越大操作效率越慢，因为 Redis 对于同一种数据类型会使用不同的内部编码进行存储，然而数据量越大使用的内部编码就越复杂，而越是复杂的内部编码存储的性能就越低。</li><li>因此在保证完整语义的同时，我们要尽量的缩短键值对的存储长度，必要时要对数据进行序列化和压缩再存储。</li></ul></li></ul><h3 id="_2-字符串拼接的优化" tabindex="-1"><a class="header-anchor" href="#_2-字符串拼接的优化" aria-hidden="true">#</a> (2)字符串拼接的优化</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>set redis &quot;hello&quot; 
append redis &quot; redis&quot;
-----------------------
set redis &quot;hello redis&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>分割线上下的命令效果是等价的，最终get redis 得到的结果都是&quot;hello redis&quot;。但这两者占用的内存大小却是不一样的。</p><p>为什么会这样呢？因为Redis的字符串有一个预分配的设定。当执行set redis &quot;hello&quot;命令时，此时内存中存储的是&quot;hello\0&quot;，默认加一个&#39;\0&#39;表示结束符。<strong>当执行append redis &quot; redis&quot;命令之后内存里的存储就变成了&quot;hello redis\0&quot;，额外还多申请一倍的空间，这个空间的上限是1M，所以字段串的append操作是会额外申请一份内存空间！这样做的原因是Redis作者认为如果字符串经常append，与其每一次append重新分配一次内存空间，不如预先分配好，下次append时如果空间够直接存储就行了。所以如果有大量的append字符串操作，并且字符串的长度不大的话，还不如用set 命令重新覆盖 这样比 append追加会更节约内存。</strong></p><h3 id="_3-编码优化" tabindex="-1"><a class="header-anchor" href="#_3-编码优化" aria-hidden="true">#</a> (3)编码优化</h3><p>对于同一个数据类型比如hash map，根据键的数量和值的大小也有不同的底层实现方式。举hash map来说底层的编码方式有两种：ziplist、hash table。从内存和效率来说ziplis与hash table的关系是</p><p>内存：ziplist &lt; hash table 效率：ziplist &lt; hash table。</p><p>ziplist的效率是O(n),hash table的效率是O(1) 也就是说Redis这里采用的是以时间换空间的套路。</p><p><strong>截至redis 4.0 只要hash map的key的数量小于等于 512，value的大小小于等于64字节，hash map的底层数据结构就是ziplist，反之则是hash table</strong>。</p><p>这样当hash map里面的数据不是很多时，用ziplist来实现即节省了内存，效率也不用下降很多，因为数据不多。但生产中如果我们有这样的一个hash map，它的key有512个，value有只有一个的大小超过了64字节，刚好是65。这个时候Redis 就默认把ziplist换成了hash table，这是不是很坑！这时可以自己优化转换规则：config set hash-max-ziplist-entries 65。这样value大于65字节才转换成hash table。</p><p>所以大家可以了解一下Redis底层的编码实现和转换规则，根据实际业务特点修改配置。</p><h3 id="_4-使用-lazy-free-特性" tabindex="-1"><a class="header-anchor" href="#_4-使用-lazy-free-特性" aria-hidden="true">#</a> (4)使用 lazy free 特性</h3><p>lazy free 特性是 Redis 4.0 新增的一个非常使用的功能，它可以理解为惰性删除或延迟删除。意思是在删除的时候提供异步延时释放键值的功能，把键值释放操作放在 BIO(Background I/O) 单独的子线程处理中，以减少删除删除对 Redis 主线程的阻塞，可以有效地避免删除 big key 时带来的性能和可用性问题。</p><p>lazy free 对应了 4 种场景，默认都是关闭的：</p><ul><li>lazyfree-lazy-eviction：表示当 Redis 运行内存超过 maxmeory 时，是否开启 lazy free 机制删除；</li><li>lazyfree-lazy-expire：表示设置了过期时间的键值，当过期之后是否开启 lazy free 机制删除；</li><li>lazyfree-lazy-server-del：有些指令在处理已存在的键时，会带有一个隐式的 del 键的操作，比如 rename 命令，当目标键已存在，Redis 会先删除目标键，如果这些目标键是一个 big key，就会造成阻塞删除的问题，此配置表示在这种场景中是否开启 lazy free 机制删除；</li><li>slave-lazy-flush：针对 slave(从节点) 进行全量数据同步，slave 在加载 master 的 RDB 文件前，会运行 flushall 来清理自己的数据，它表示此时是否开启 lazy free 机制删除。</li></ul><h3 id="_5-设置合理的键值过期时间" tabindex="-1"><a class="header-anchor" href="#_5-设置合理的键值过期时间" aria-hidden="true">#</a> (5)设置合理的键值过期时间</h3><p>我们应该根据实际的业务情况，对键值设置合理的过期时间，这样 Redis 会帮你自动清除过期的键值对，以节约对内存的占用，以避免键值过多的堆积，频繁的触发内存淘汰策略。</p><h3 id="_6-禁用长耗时的查询命令" tabindex="-1"><a class="header-anchor" href="#_6-禁用长耗时的查询命令" aria-hidden="true">#</a> (6)禁用长耗时的查询命令</h3><p>Redis 绝大多数读写命令的时间复杂度都在 O(1) 到 O(N) 之间，在官方文档对每命令都有时间复杂度说明。</p><p>其中 O(1) 表示可以安全使用的，而 O(N) 就应该当心了，N 表示不确定，数据越大查询的速度可能会越慢。因为 Redis 只用一个线程来做数据查询，如果这些指令耗时很长，就会阻塞 Redis，造成大量延时。</p><p>要避免 O(N) 命令对 Redis 造成的影响，可以从以下几个方面入手改造：</p><ul><li>禁止使用 keys 命令；</li><li>避免一次查询所有的成员，要使用 scan 命令进行分批的，游标式的遍历；</li><li>通过机制严格控制 Hash、Set、Sorted Set 等结构的数据大小；</li><li>将排序、并集、交集等操作放在客户端执行，以减少 Redis 服务器运行压力；</li><li>删除 (del) 一个大数据的时候，可能会需要很长时间，所以建议用异步删除的方式 unlink，它会启动一个新的线程来删除目标数据，而不阻塞 Redis 的主线程。</li></ul><h3 id="_7-使用-slowlog-优化耗时命令" tabindex="-1"><a class="header-anchor" href="#_7-使用-slowlog-优化耗时命令" aria-hidden="true">#</a> (7)使用 slowlog 优化耗时命令</h3><p>使用 slowlog 功能找出最耗时的 Redis 命令进行相关的优化，以提升 Redis 的运行速度，慢查询有两个重要的配置项：</p><ul><li>slowlog-log-slower-than ：用于设置慢查询的评定时间，也就是说超过此配置项的命令，将会被当成慢操作记录在慢查询日志中，它执行单位是微秒 (1 秒等于 1000000 微秒)；</li><li>slowlog-max-len ：用来配置慢查询日志的最大记录数。</li></ul><p>我们可以根据实际的业务情况进行相应的配置，其中慢日志是按照插入的顺序倒序存入慢查 询日志中，我们可以使用 slowlog get n 来获取相关的慢查询日志，再找到这些慢查询对应的业务进行相关的优化。</p><h3 id="_8-使用-pipeline-批量操作数据" tabindex="-1"><a class="header-anchor" href="#_8-使用-pipeline-批量操作数据" aria-hidden="true">#</a> (8)使用 Pipeline 批量操作数据</h3><p>Pipeline (管道技术) 是客户端提供的一种批处理技术，用于一次处理多个 Redis 命令，从而提高整个交互的性能。</p><h3 id="_9-避免大量数据同时失效" tabindex="-1"><a class="header-anchor" href="#_9-避免大量数据同时失效" aria-hidden="true">#</a> (9)避免大量数据同时失效</h3><p>Redis 过期键值删除使用的是贪心策略，它每秒会进行 10 次过期扫描，此配置可在 redis.conf 进行配置，默认值是 hz 10，Redis 会随机抽取 20 个值，删除这 20 个键中过期的键，如果过期 key 的比例超过 25% ，重复执行此流程，如下图所示：</p><img src="/assets/20210629094825-93b9c7d8.png" alt="过期删除键流程" style="zoom:50%;"><p>如果在大型系统中有大量缓存在同一时间同时过期，那么会导致 Redis 循环多次持续扫描删除过期字典，直到过期字典中过期键值被删除的比较稀疏为止，而在整个执行过程会导致 Redis 的读写出现明显的卡顿，卡顿的另一种原因是内存管理器需要频繁回收内存页，因此也会消耗一定的 CPU。</p><p>为了避免这种卡顿现象的产生，需要预防大量的缓存在同一时刻一起过期，就简单的解决方案就是在过期时间的基础上添加一个指定范围的随机数。</p><h3 id="_10-redis-连接池" tabindex="-1"><a class="header-anchor" href="#_10-redis-连接池" aria-hidden="true">#</a> (10)Redis 连接池</h3><p>在客户端的使用上我们除了要尽量使用 Pipeline 的技术外，还需要注意要尽量使用 Redis 连接池，而不是频繁创建销毁 Redis 连接，这样就可以减少网络传输次数和减少了非必要调用指令。</p><h3 id="_11-限制-redis-内存大小-使用合理的内存淘汰策略" tabindex="-1"><a class="header-anchor" href="#_11-限制-redis-内存大小-使用合理的内存淘汰策略" aria-hidden="true">#</a> (11)限制 Redis 内存大小，使用合理的内存淘汰策略</h3><p>参看内存淘汰策略</p><h3 id="_12-使用物理机而非虚拟机" tabindex="-1"><a class="header-anchor" href="#_12-使用物理机而非虚拟机" aria-hidden="true">#</a> (12)使用物理机而非虚拟机</h3><p>对性能要求较高可考虑在物理机直接部署Redis而不是使用虚拟机。</p><p>在虚拟机中运行 Redis 服务器，因为和物理机共享一个物理网口，并且一台物理机可能有多个虚拟机在运行，因此在内存占用上和网络延迟方面都会有很糟糕的表现，我们可以通过 ./redis-cli --intrinsic-latency 100 命令查看延迟时间，如果对 Redis 的性能有较高要求的话，应尽可能在物理机上直接部署 Redis 服务器。</p><h3 id="_13-使用合理的持久化策略" tabindex="-1"><a class="header-anchor" href="#_13-使用合理的持久化策略" aria-hidden="true">#</a> (13)使用合理的持久化策略</h3><p>参看持久化策略</p><h3 id="_14-使用分布式架构来增加读写速度" tabindex="-1"><a class="header-anchor" href="#_14-使用分布式架构来增加读写速度" aria-hidden="true">#</a> (14)使用分布式架构来增加读写速度</h3><p>Redis 分布式架构有三个重要的手段：</p><ul><li>主从同步</li><li>哨兵模式</li><li>Redis Cluster 集群</li></ul><p>使用主从同步功能我们可以把写入放到主库上执行，把读功能转移到从服务上，因此就可以在单位时间内处理更多的请求，从而提升的 Redis 整体的运行速度。</p><p>而哨兵模式是对于主从功能的升级，但当主节点奔溃之后，无需人工干预就能自动恢复 Redis 的正常使用。</p><p>Redis Cluster 是 Redis 3.0 正式推出的，Redis 集群是通过将数据库分散存储到多个节点上来平衡各个节点的负载压力。</p><p>Redis Cluster 采用虚拟哈希槽分区，所有的键根据哈希函数映射到 0 ~ 16383 整数槽内，计算公式：slot = CRC16(key) &amp; 16383，每一个节点负责维护一部分槽以及槽所映射的键值数据。这样 Redis 就可以把读写压力从一台服务器，分散给多台服务器了，因此性能会有很大的提升。</p><p>在这三个功能中，我们只需要使用一个就行了，毫无疑问 Redis Cluster 应该是首选的实现方案，它可以把读写压力自动的分担给更多的服务器，并且拥有自动容灾的能力。</p><h2 id="_12-redis线程模型" tabindex="-1"><a class="header-anchor" href="#_12-redis线程模型" aria-hidden="true">#</a> 12. Redis线程模型</h2><h3 id="_12-1-线程模型" tabindex="-1"><a class="header-anchor" href="#_12-1-线程模型" aria-hidden="true">#</a> 12.1 线程模型</h3><p><strong>Redis 基于 Reactor 模式来设计开发了自己的一套高效的事件处理模型</strong> (Netty 的线程模型也基于 Reactor 模式，Reactor 模式不愧是高性能 IO 的基石)。</p><p>Redis内部使用文件事件处理器file event handler，这个文件事件处理器是单线程的所以redis才叫做单线程的模型。它采用IO多路复用机制同时监听多个socket，将产生事件的socket压入到内存队列中，事件分派器根据socket上的事件类型来选择对应的事件处理器来进行处理。</p><p>文件事件处理器包含4个部分：</p><ul><li>多个socket</li><li>IO多路复用程序</li><li>文件事件分派器</li><li>事件处理器(连接应答处理器、命令请求处理器、命令回复处理器)</li></ul><p>Redis 通过<strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接(或者说是监听多个 socket)，它会将感兴趣的事件及类型(读、写)注册到内核中并监听每个事件是否发生。</p><p>这样的好处非常明显： <strong>I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong>(和 NIO 中的 <code>Selector</code> 组件很像)。</p><p><strong>客户端与redis的一次通信过程：</strong></p><figure><img src="/assets/20210629104510-d1e6d3ed.png" alt="Redis线程模型" tabindex="0" loading="lazy"><figcaption>Redis线程模型</figcaption></figure><ol><li>客户端发起建立连接的请求。 <ol><li>服务端会产生一个<strong>AE_READABLE</strong>事件，<strong>IO多路复用程序</strong>接收到server socket事件后，将该socket压入队列中。</li><li><strong>文件事件分派器</strong>从队列中获取socket，交给<strong>连接应答处理器</strong>，创建一个可以和客户端交流的socket01。</li><li>将socket01的<strong>AE_READABLE</strong>事件与<strong>命令请求处理器</strong>关联。</li></ol></li><li>客户端发起set key value请求。 <ol><li>socket01产生<strong>AE_READABLE</strong>事件，socket01压入队列。</li><li>将获取到的socket01与<strong>命令请求处理器</strong>关联。</li><li><strong>命令请求处理器</strong>读取socket01中的key value，并在内存中完成对应的设置。</li><li>将socket01的AE_WRITABLE事件与命令回复处理器关联。</li></ol></li><li>服务端返回结果。 <ol><li>redis中的socket01会产生一个<strong>AE_WRITABLE</strong>事件，压入到队列中。</li><li>将获取到的socket01与<strong>命令回复处理器</strong>关联。</li><li><strong>命令回复处理器</strong>对socket01输入操作结果，比如ok。之后解除socket01的<strong>AE_WRITABLE</strong>事件与<strong>命令回复处理器</strong>的关联。</li></ol></li></ol><h3 id="_12-2-redis为什么这么快" tabindex="-1"><a class="header-anchor" href="#_12-2-redis为什么这么快" aria-hidden="true">#</a> 12.2 Redis为什么这么快？</h3><ol><li>纯内存操作，避免大量访问数据库，减少直接读取磁盘数据，redis将数据储存在内存里面，读写数据的时候都不会受到硬盘 I/O 速度的限制，所以速度快</li><li>单线程操作，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。(Redis6.0引入了多线程)</li><li>采用了非阻塞I/O多路复用机制</li><li>C语言实现，距离操作系统更近，执行速度会更快。</li></ol><h3 id="_12-3-redis的非阻塞io多路复用模型" tabindex="-1"><a class="header-anchor" href="#_12-3-redis的非阻塞io多路复用模型" aria-hidden="true">#</a> 12.3 Redis的非阻塞IO多路复用模型</h3><p>文件事件处理器：组成结构：多个套接字、IO多路复用程序、文件事件分派器、事件处理器</p><figure><img src="/assets/202111251639666-0d40d2f1.png" alt="详解Redis非阻塞io多路复用线程模型" tabindex="0" loading="lazy"><figcaption>详解Redis非阻塞io多路复用线程模型</figcaption></figure><p>Redis客户端对服务端的调用分为发送命令，执行命令，返回结果三个过程。</p><ol><li><p>I/O多路复用(multiplexing)程序来同时监听多个套接字，并关联相应的事件处理器。</p></li><li><p>当被监听的套接字准备好执行连接应答(accept)、读取(read)、写入(write)、关闭(close)等操作时， 产生于操作相对应的文件事件。</p></li><li><p>多个文件事件可能会并发地出现，将产生时间的套接字放入一个队列中，有序、同步、每次一个套接字的方式将文件事件发送给文件事件分派器。</p></li><li><p>文件事件分派器将事件分派给对应处理器处理。</p></li><li><p>文件事件处理完毕后，通过套接字返回。</p></li></ol><p>Redis为文件事件编写了多个处理器，分别为socket关联连接、命令请求、命令回复处理器等。</p><h3 id="_12-4-redis6-0-之前-为什么不使用多线程" tabindex="-1"><a class="header-anchor" href="#_12-4-redis6-0-之前-为什么不使用多线程" aria-hidden="true">#</a> 12.4 Redis6.0 之前 为什么不使用多线程？</h3><p><strong>Redis中只有网络请求模块和数据操作模块是单线程的。而其他的如持久化存储模块、集群支撑模块等是多线程的。</strong></p><p>Redis中并不是没有多线程模型的，早在Redis 4.0的时候就已经针对部分命令做了多线程化。</p><ol><li>单线程编程容易并且更容易维护；</li><li>Redis 的性能瓶颈不在 CPU ，主要在内存和网络；</li><li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li></ol><p>参看：<a href="https://draveness.me/whys-the-design-redis-single-thread/" target="_blank" rel="noopener noreferrer">为什么 Redis 选择单线程模型<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h3 id="_12-5-redis6-0-之后为何引入了多线程" tabindex="-1"><a class="header-anchor" href="#_12-5-redis6-0-之后为何引入了多线程" aria-hidden="true">#</a> 12.5 Redis6.0 之后为何引入了多线程？</h3><p><strong>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能</strong>，因为这个算是 Redis 中的一个性能瓶颈(Redis 的瓶颈主要受限于内存和网络)。</p><p>虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了， 执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。</p><p>Redis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要修改 redis 配置文件 <code>redis.conf</code> ：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>io-threads-do-reads yesCopy to clipboardErrorCopied
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>开启多线程后，还需要设置线程数，否则是不生效的。同样需要修改 redis 配置文件 <code>redis.conf</code> :</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>io-threads <span class="token number">4</span> <span class="token comment">#官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>参看：</p><ul><li><a href="https://mp.weixin.qq.com/s/FZu3acwK6zrCBZQ_3HoUgw" target="_blank" rel="noopener noreferrer">Redis 6.0 新特性-多线程连环13问！<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://zhuanlan.zhihu.com/p/357343339" target="_blank" rel="noopener noreferrer">Redis不是一直号称单线程效率也很高吗，为什么又采用多线程了？<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li></ul><h2 id="_13-redis事务" tabindex="-1"><a class="header-anchor" href="#_13-redis事务" aria-hidden="true">#</a> 13. Redis事务</h2><p>事务是一个单独的隔离操作:事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中,不会被其他客户端发送来的命令请求所打断。</p><p>事务是一个原子操作:事务中的命令要么全部被执行，要么全部都不执行。</p><h3 id="_13-1-实现原理" tabindex="-1"><a class="header-anchor" href="#_13-1-实现原理" aria-hidden="true">#</a> 13.1 实现原理</h3><p>Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p><p>Redis事务的主要作用就是 <strong>串联多个命令防止别的命令插队</strong>。</p><p>Redis 的通过 <code>MULTI</code>，<code>EXEC</code>，<code>DISCARD</code> 和 <code>WATCH</code> 这四个命令来实现事务的，Redis 的单个命令都是<strong>原子性</strong>的。</p><p><strong>三个阶段(事务开始、命令入队、事务执行)</strong>：</p><ol><li><p>使用 <code>MULTI</code>命令后可以输入多个命令。Redis 不会立即执行这些命令，而是将它们放到队列，当调用了<a href="https://redis.io/commands/exec" target="_blank" rel="noopener noreferrer"><code>EXEC</code><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>命令将执行所有命令。</p><p>这个过程是这样的：</p><ol><li>开始事务(<code>MULTI</code>)。</li><li>命令入队(批量操作 Redis 的命令，先进先出(FIFO)的顺序执行)。</li><li>执行事务(<code>EXEC</code>)。</li></ol></li><li><p>也可以通过<code>DISCARD</code>命令取消一个事务，它会清空事务队列中保存的所有命令。</p></li><li><p><code>WATCH</code> 命令用于监听指定的键，当调用 <code>EXEC</code> 命令执行事务时，如果一个被 <code>WATCH</code> 命令监视的键被修改的话，整个事务都不会执行，直接返回失败。</p></li><li><p>调用了<a href="https://redis.io/commands/exec" target="_blank" rel="noopener noreferrer"><code>EXEC</code><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>命令将执行所有命令。</p></li></ol><p>可以将 Redis 中的事务就理解为 ：<strong>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</strong></p><p>原理分析可参考：<a href="https://zhuanlan.zhihu.com/p/144268090" target="_blank" rel="noopener noreferrer">高频Redis面试题解析：Redis 事务是否具备原子性？<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h3 id="_13-2-事务的四大特性" tabindex="-1"><a class="header-anchor" href="#_13-2-事务的四大特性" aria-hidden="true">#</a> 13.2 事务的四大特性</h3><ol><li><strong>原子性(Atomicity)：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li><strong>隔离性(Isolation)：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li><strong>持久性(Durability)：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li><li><strong>一致性(Consistency)：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li></ol><h3 id="_14-3-redis-是不支持-roll-back-的原因" tabindex="-1"><a class="header-anchor" href="#_14-3-redis-是不支持-roll-back-的原因" aria-hidden="true">#</a> 14.3 Redis 是不支持 roll back 的原因</h3><ol><li>大多数事务失败是因为<strong>语法错误或者类型错误</strong>，这两种错误，在开发阶段都是可以预见的。</li><li>Redis 为了<strong>性能方面</strong>就忽略了事务回滚。</li></ol><h3 id="_14-4-事务失败处理-是否保证原子性" tabindex="-1"><a class="header-anchor" href="#_14-4-事务失败处理-是否保证原子性" aria-hidden="true">#</a> 14.4 事务失败处理(是否保证原子性)</h3><ol><li>Redis 语法错误(可以理解为<strong>编译期错误</strong>)</li></ol><p>在一个事务中，当命令出现错误时，后续命令正确依旧是可以添加到命令队列中去得，但是使用 EXEC 命令执行命令队列的时候，就会报错，并且<strong>队列中正确的命令也不会被执行</strong>(支持原子性)。</p><ol start="2"><li>Redis 类型错误(可以理解为<strong>运行期错误</strong>)</li></ol><p>这种错误不是命令错误，而是因为对命令理解不透彻出现的使用错误，在执行过程中会报错。但<strong>队列中正确的命令会被执行</strong>(不支持原子性)。</p><p><strong>Redis不保证原子性，也没有隔离级别。</strong></p><h2 id="_15-redis缓存异常" tabindex="-1"><a class="header-anchor" href="#_15-redis缓存异常" aria-hidden="true">#</a> 15. Redis缓存异常</h2><h3 id="_15-1-缓存热点key" tabindex="-1"><a class="header-anchor" href="#_15-1-缓存热点key" aria-hidden="true">#</a> 15.1 缓存热点key</h3><p>突然有几十万的请求去访问redis上的某个特定key，那么这样会造成流量过于集中，达到物理网卡上限，从而导致这台redis的服务器宕机引发雪崩。</p><figure><img src="/assets/20210629175313-3e751b0f.png" alt="缓存热点key问题" tabindex="0" loading="lazy"><figcaption>缓存热点key问题</figcaption></figure><p>针对热key的解决方案：</p><ol><li>提前把热key打散到不同的服务器，降低压力</li><li>加入二级缓存，提前加载热key数据到内存中，如果redis宕机，走内存查询</li></ol><h3 id="_15-2-缓存雪崩" tabindex="-1"><a class="header-anchor" href="#_15-2-缓存雪崩" aria-hidden="true">#</a> 15.2 缓存雪崩</h3><h4 id="什么是缓存雪崩" tabindex="-1"><a class="header-anchor" href="#什么是缓存雪崩" aria-hidden="true">#</a> 什么是缓存雪崩？</h4><blockquote><p>缓存雪崩：<strong>缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。</strong> 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</p></blockquote><p><strong>有一些被大量访问数据(热点缓存)在某一时刻大面积失效或者系统的缓存模块出了问题比如宕机导致不可用，导致对应的请求直接落到了数据库上。</strong></p><p>例子：秒杀开始 12 个小时之前，统一存放了一批商品到 Redis 中，设置的缓存过期时间也是 12 个小时，那么秒杀开始的时候，这些秒杀的商品的访问直接就失效了。导致的情况就是，相应的请求直接就落到了数据库上，就像雪崩一样可怕。</p><figure><img src="/assets/20210629180514-d4c93379.png" alt="缓存雪崩" tabindex="0" loading="lazy"><figcaption>缓存雪崩</figcaption></figure><h4 id="如何解决缓存雪崩" tabindex="-1"><a class="header-anchor" href="#如何解决缓存雪崩" aria-hidden="true">#</a> <strong>如何解决缓存雪崩</strong>？</h4><p><strong>针对 Redis 服务不可用的情况：</strong></p><ol><li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li><li>限流，避免同时处理大量的请求。</li></ol><p><strong>针对热点缓存失效的情况：</strong></p><ol><li>设置不同的失效时间比如随机设置缓存的失效时间。</li><li>缓存永不失效。</li><li>构建多级缓存架构：nginx缓存 + redis缓存 +其他缓存(ehcache等)</li><li>**设置过期标志更新缓存：**记录缓存数据是否过期(设置提前量)，如果过期会触发通知另外的线程在后台去更新实际key的缓存。Redis有一个过期删除键的监听事件。</li></ol><h3 id="_15-3-缓存穿透" tabindex="-1"><a class="header-anchor" href="#_15-3-缓存穿透" aria-hidden="true">#</a> 15.3 缓存穿透</h3><h4 id="什么是缓存穿透" tabindex="-1"><a class="header-anchor" href="#什么是缓存穿透" aria-hidden="true">#</a> 什么是缓存穿透？</h4><blockquote><p>缓存穿透：大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。</p></blockquote><p>例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库，导致数据库压力过大，严重会击垮数据库。</p><figure><img src="/assets/20210629180428-34e83371.png" alt="缓存穿透" tabindex="0" loading="lazy"><figcaption>缓存穿透</figcaption></figure><h4 id="如何解决缓存穿透" tabindex="-1"><a class="header-anchor" href="#如何解决缓存穿透" aria-hidden="true">#</a> 如何解决缓存穿透？</h4><p><strong>1)缓存无效 key</strong>(对空值缓存)</p><p>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下： <code>SET key value EX 10086</code> 。</p><p>这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟，最长不超过五分钟。</p><p>另外，这里多说一嘴，一般情况下我们是这样设计 key 的： <code>表名:列名:主键名:主键值</code> 。</p><p><strong>2)设置可访问的名单(白名单)</strong></p><p>使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问。</p><p><strong>3)布隆过滤器</strong></p><blockquote><p>布隆过滤器(Bloom Filter)是1970年由布隆提出的。它实际上是一个很长的二进制向量(位图)和一系列随机映射函数(哈希函数)</p><p>布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p></blockquote><p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p><img src="/assets/20210629173643-057e249e.png" alt="布隆过滤器流程" style="zoom:67%;"><p>但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： <strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p><p>我们先来看一下，<strong>当一个元素加入布隆过滤器中的时候，会进行哪些操作：</strong></p><ol><li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值(有几个哈希函数得到几个哈希值)。</li><li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li></ol><p>我们再来看一下，<strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：</strong></p><ol><li>对给定元素再次进行相同的哈希计算；</li><li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li></ol><p>然后，一定会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong> (可以适当增加位数组大小或者调整我们的哈希函数来降低概率)</p><p>布隆过滤器可参看：<a href="https://zhuanlan.zhihu.com/p/43263751" target="_blank" rel="noopener noreferrer">详解布隆过滤器的原理，使用场景和注意事项<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p><strong>4)进行实时监控</strong></p><p>当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务</p><h3 id="_15-4-缓存击穿" tabindex="-1"><a class="header-anchor" href="#_15-4-缓存击穿" aria-hidden="true">#</a> 15.4 缓存击穿</h3><blockquote><p><strong>缓存击穿</strong>是指一个Key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个Key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个完好无损的桶上凿开了一个洞.</p></blockquote><ol><li>**预先设置热门数据：**在redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key的时长。</li><li>**实时调整：**现场监控哪些数据热门，实时调整key的过期时长</li><li>加锁更新，比如请求查询A，发现缓存中没有，对A这个key加锁，同时去数据库查询数据，写入缓存，再返回给用户，这样后面的请求就可以从缓存中拿到数据了。</li><li>将过期时间组合写在value中，通过异步的方式不断的刷新过期时间，防止此类现象。当并发量降低时，可以停止进行刷新。</li></ol><figure><img src="/assets/20210629180343-3d8a1540.png" alt="缓存击穿" tabindex="0" loading="lazy"><figcaption>缓存击穿</figcaption></figure><h3 id="_15-5-缓存预热" tabindex="-1"><a class="header-anchor" href="#_15-5-缓存预热" aria-hidden="true">#</a> 15.5 缓存预热</h3><blockquote><p>缓存预热：系统上线后，将相关缓存数据直接加载到缓存系统。</p></blockquote><p>避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题。用户直接查询事先被预热的缓存数据。</p><p>思路：</p><ul><li>数据量不大时，启动时直接加载</li><li>定时刷新缓存</li><li>手动刷新缓存</li></ul><h3 id="_15-6-缓存降级" tabindex="-1"><a class="header-anchor" href="#_15-6-缓存降级" aria-hidden="true">#</a> 15.6 缓存降级</h3><p>当访问量剧增、服务出现问题(如响应时间慢或不响应)或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有 损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。 降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的(如加入购物车、结算)。<br> 以参考日志级别设置预案： (1)一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级； (2)警告：有些服务在一段时间内成功率有波动(如在95~100%之间)，可以自动降级或人工降级，并发送告警； (3)错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降 级或者人工降级； (4)严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一 起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查 询，而是直接返回默认值给用户</p><h2 id="_16-分布式问题" tabindex="-1"><a class="header-anchor" href="#_16-分布式问题" aria-hidden="true">#</a> 16 分布式问题</h2><h3 id="_16-1-redis实现分布式锁" tabindex="-1"><a class="header-anchor" href="#_16-1-redis实现分布式锁" aria-hidden="true">#</a> 16.1 Redis实现分布式锁？</h3><h4 id="为什么引入分布式锁" tabindex="-1"><a class="header-anchor" href="#为什么引入分布式锁" aria-hidden="true">#</a> 为什么引入分布式锁？</h4><p>在一个分布式系统中，我们从数据库中读取一个数据，然后修改保存，这种情况很容易遇到并发问题。因为读取和更新保存不是一个原子操作，在并发时就会导致数据的不正确。</p><p>这种场景其实并不少见，比如电商秒杀活动，库存数量的更新就会遇到。</p><p>如果是单机应用，直接使用本地锁就可以避免。如果是分布式应用，本地锁派不上用场，这时就需要引入分布式锁来解决。</p><p>由此可见分布式锁的目的其实很简单，就是<strong>为了保证多台服务器在执行某一段代码时保证只有一台服务器执行</strong>。</p><h4 id="分布式锁的实现原则" tabindex="-1"><a class="header-anchor" href="#分布式锁的实现原则" aria-hidden="true">#</a> 分布式锁的实现原则</h4><ul><li><strong>互斥性</strong>。在任何时刻，保证只有一个客户端持有锁。</li><li><strong>不能出现死锁</strong>。如果在一个客户端持有锁的期间，这个客户端崩溃了，也要保证后续的其他客户端可以上锁。</li><li><strong>保证上锁和解锁都是同一个客户端</strong>。</li></ul><p>一般来说，实现分布式锁的方式有以下几种：</p><ul><li>使用MySQL，基于唯一索引。</li><li>使用ZooKeeper，基于临时有序节点。</li><li><strong>使用Redis，基于setnx命令</strong>。</li></ul><h4 id="redis实现分布式锁" tabindex="-1"><a class="header-anchor" href="#redis实现分布式锁" aria-hidden="true">#</a> Redis实现分布式锁</h4><p>Redis实现分布式锁主要利用Redis的<code>setnx</code>命令。<code>setnx</code>是<code>SET if not exists</code>(如果不存在，则 SET)的简写。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> setnx lock value1 <span class="token comment">#在键lock不存在的情况下，将键key的值设置为value1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> setnx lock value2 <span class="token comment">#试图覆盖lock的值，返回0表示失败</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> get lock <span class="token comment">#获取lock的值，验证没有被覆盖</span>
<span class="token string">&quot;value1&quot;</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> del lock <span class="token comment">#删除lock的值，删除成功</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> setnx lock value2 <span class="token comment">#再使用setnx命令设置，返回0表示成功</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> get lock <span class="token comment">#获取lock的值，验证设置成功</span>
<span class="token string">&quot;value2&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这几个命令就是最基本的用来完成分布式锁的命令。</p><p>加锁：使用<code>setnx key value</code>命令，如果key不存在，设置value(加锁成功)。如果已经存在lock(也就是有客户端持有锁了)，则设置失败(加锁失败)。</p><p>解锁：使用<code>del</code>命令，通过删除键值释放锁。释放锁之后，其他客户端可以通过<code>setnx</code>命令进行加锁。</p><p>key的值可以根据业务设置，比如是用户中心使用的，可以命令为<code>USER_REDIS_LOCK</code>，value可以使用uuid保证唯一，用于标识加锁的客户端。保证加锁和解锁都是同一个客户端。</p><p>简单的代码实现：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Jedis</span> jedis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jedis</span><span class="token punctuation">(</span><span class="token string">&quot;127.0.0.1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Long</span> <span class="token constant">SUCCESS</span> <span class="token operator">=</span> <span class="token number">1L</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
  * 加锁
  */</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">String</span> requestId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//使用setnx命令。</span>
    <span class="token comment">//不存在则保存返回1，加锁成功。如果已经存在则返回0，加锁失败。</span>
    <span class="token keyword">return</span> <span class="token constant">SUCCESS</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>jedis<span class="token punctuation">.</span><span class="token function">setnx</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> requestId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//删除key的lua脚本，先比较requestId是否相等，相等则删除</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">DEL_SCRIPT</span> <span class="token operator">=</span> <span class="token string">&quot;if redis.call(&#39;get&#39;, KEYS[1]) == ARGV[1] then return redis.call(&#39;del&#39;, KEYS[1]) else return 0 end&quot;</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
  * 解锁
  */</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">unLock</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">String</span> requestId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//删除成功表示解锁成功</span>
    <span class="token class-name">Long</span> result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Long</span><span class="token punctuation">)</span> jedis<span class="token punctuation">.</span><span class="token function">eval</span><span class="token punctuation">(</span><span class="token constant">DEL_SCRIPT</span><span class="token punctuation">,</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">singletonList</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">singletonList</span><span class="token punctuation">(</span>requestId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token constant">SUCCESS</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>流程：</p><figure><img src="/assets/20210629204433-50d4a775.png" alt="Redis实现分布式锁的流程" tabindex="0" loading="lazy"><figcaption>Redis实现分布式锁的流程</figcaption></figure><h5 id="问题一-持有锁的客户端不能释放锁-引发死锁" tabindex="-1"><a class="header-anchor" href="#问题一-持有锁的客户端不能释放锁-引发死锁" aria-hidden="true">#</a> 问题一：持有锁的客户端不能释放锁，引发死锁</h5><p>这样只能保证互斥性和加锁解锁都是同一个客户端，也保证只有一个客户端持有锁，但<strong>可能会出现死锁问题</strong>，即如果一个持有锁的客户端突然崩溃，导致无法解锁。</p><p>解决——超时机制：</p><p>设置超时机制，在设置key的时候，加上有效时间，如果过期，自动失效，不会出现死锁。</p><p>代码修改：</p><div class="language-Java line-numbers-mode" data-ext="Java"><pre class="language-Java"><code>public boolean tryLock(String key, String requestId, int expireTime) {
    //使用jedis的api，保证原子性
    //NX 不存在则操作 EX 设置有效期，单位是秒
    String result = jedis.set(key, requestId, &quot;NX&quot;, &quot;EX&quot;, expireTime);
    //返回OK则表示加锁成功
    return &quot;OK&quot;.equals(result);
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/assets/20210629205045-8eca29f8.png" alt="解决死锁问题后的流程" tabindex="0" loading="lazy"><figcaption>解决死锁问题后的流程</figcaption></figure><p>虽然，这样不会引发死锁问题，但是<strong>有效时间设置多长是一个问题</strong>。<strong>如果业务操作比有效时间长，业务代码还没执行完就解锁了，不能保证数据一致性</strong>。</p><p>这个问题就有点棘手了，在网上也有很多讨论，第一种解决方法就是靠程序员自己去把握，预估一下业务代码需要执行的时间，然后设置有效期时间比执行时间长一些，保证不会因为自动解锁影响到客户端业务代码的执行。</p><p>但是这并不是万全之策，比如网络抖动这种情况是无法预测的，也有可能导致业务代码执行的时间变长，所以并不安全。</p><p>有一种方法比较靠谱一点，就是<strong>给锁续期</strong>。思路：<strong>当加锁成功后，同时开启守护线程，默认有效期是30秒，每隔10秒就会给锁续期到30秒，只要持有锁的客户端没有宕机，就能保证一直持有锁，直到业务代码执行完毕由客户端自己解锁，如果宕机了自然就在有效期失效后自动解锁</strong>。</p><figure><img src="/assets/20210629205514-8e2f267d.png" alt="避免死锁+锁续期流程" tabindex="0" loading="lazy"><figcaption>避免死锁+锁续期流程</figcaption></figure><h5 id="问题二-不可重入锁" tabindex="-1"><a class="header-anchor" href="#问题二-不可重入锁" aria-hidden="true">#</a> 问题二：不可重入锁</h5><p>上述加的锁只能加一次，不可重入。可重入锁意思是在外层使用锁之后，内层仍然可以使用，那么可重入锁的实现思路又是怎么样的呢？</p><p><strong>使用Redis的哈希表存储可重入次数，当加锁成功后，使用<code>hset</code>命令，value(重入次数)则是1</strong>。</p><div class="language-lua line-numbers-mode" data-ext="lua"><pre class="language-lua"><code><span class="token string">&quot;if (redis.call(&#39;exists&#39;, KEYS[1]) == 0) then &quot;</span> <span class="token operator">+</span>
<span class="token string">&quot;redis.call(&#39;hset&#39;, KEYS[1], ARGV[2], 1); &quot;</span> <span class="token operator">+</span>
<span class="token string">&quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]); &quot;</span> <span class="token operator">+</span>
<span class="token string">&quot;return nil; &quot;</span> <span class="token operator">+</span>
<span class="token string">&quot;end; &quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果同一个客户端再次加锁成功，则使用<code>hincrby</code>自增加一。</p><div class="language-lua line-numbers-mode" data-ext="lua"><pre class="language-lua"><code><span class="token string">&quot;if (redis.call(&#39;hexists&#39;, KEYS[1], ARGV[2]) == 1) then &quot;</span> <span class="token operator">+</span>
<span class="token string">&quot;redis.call(&#39;hincrby&#39;, KEYS[1], ARGV[2], 1); &quot;</span> <span class="token operator">+</span>
<span class="token string">&quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]); &quot;</span> <span class="token operator">+</span>
<span class="token string">&quot;return nil; &quot;</span> <span class="token operator">+</span>
<span class="token string">&quot;end; &quot;</span> <span class="token operator">+</span>
<span class="token string">&quot;return redis.call(&#39;pttl&#39;, KEYS[1]);&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>加锁流程：</p><figure><img src="/assets/20210629210314-7526c690.png" alt="Redis分布式可重入锁加锁流程" tabindex="0" loading="lazy"><figcaption>Redis分布式可重入锁加锁流程</figcaption></figure><p>解锁时，先判断可重复次数是否大于0，大于0则减一，否则删除键值，释放锁资源。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token class-name">RFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Boolean</span><span class="token punctuation">&gt;</span></span> <span class="token function">unlockInnerAsync</span><span class="token punctuation">(</span><span class="token keyword">long</span> threadId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> commandExecutor<span class="token punctuation">.</span><span class="token function">evalWriteAsync</span><span class="token punctuation">(</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">LongCodec</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">,</span> <span class="token class-name">RedisCommands</span><span class="token punctuation">.</span><span class="token constant">EVAL_BOOLEAN</span><span class="token punctuation">,</span>
<span class="token string">&quot;if (redis.call(&#39;hexists&#39;, KEYS[1], ARGV[3]) == 0) then &quot;</span> <span class="token operator">+</span>
<span class="token string">&quot;return nil;&quot;</span> <span class="token operator">+</span>
<span class="token string">&quot;end; &quot;</span> <span class="token operator">+</span>
<span class="token string">&quot;local counter = redis.call(&#39;hincrby&#39;, KEYS[1], ARGV[3], -1); &quot;</span> <span class="token operator">+</span>
<span class="token string">&quot;if (counter &gt; 0) then &quot;</span> <span class="token operator">+</span>
<span class="token string">&quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[2]); &quot;</span> <span class="token operator">+</span>
<span class="token string">&quot;return 0; &quot;</span> <span class="token operator">+</span>
<span class="token string">&quot;else &quot;</span> <span class="token operator">+</span>
<span class="token string">&quot;redis.call(&#39;del&#39;, KEYS[1]); &quot;</span> <span class="token operator">+</span>
<span class="token string">&quot;redis.call(&#39;publish&#39;, KEYS[2], ARGV[1]); &quot;</span> <span class="token operator">+</span>
<span class="token string">&quot;return 1; &quot;</span><span class="token operator">+</span>
<span class="token string">&quot;end; &quot;</span> <span class="token operator">+</span>
<span class="token string">&quot;return nil;&quot;</span><span class="token punctuation">,</span>
<span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getChannelName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">LockPubSub</span><span class="token punctuation">.</span><span class="token constant">UNLOCK_MESSAGE</span><span class="token punctuation">,</span> internalLockLeaseTime<span class="token punctuation">,</span> <span class="token function">getLockName</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/assets/20210629210532-4e4812e9.jpg" alt="Redis分布式可重入锁解锁流程" tabindex="0" loading="lazy"><figcaption>Redis分布式可重入锁解锁流程</figcaption></figure><p>为了保证操作原子性，加锁和解锁操作都是使用lua脚本执行。</p><h5 id="问题三-操作成功后立即返回结果-消耗性能" tabindex="-1"><a class="header-anchor" href="#问题三-操作成功后立即返回结果-消耗性能" aria-hidden="true">#</a> 问题三：操作成功后立即返回结果，消耗性能</h5><p>上面的加锁方法是加锁后立即返回加锁结果，如果加锁失败的情况下，总不可能一直轮询尝试加锁，直到加锁成功为止，这样太过耗费性能。所以需要利用发布订阅的机制进行优化。</p><p>步骤如下：</p><ol><li>当加锁失败后，订阅锁释放的消息，自身进入阻塞状态。</li><li>当持有锁的客户端释放锁的时候，发布锁释放的消息。</li><li>当进入阻塞等待的其他客户端收到锁释放的消息后，解除阻塞等待状态，再次尝试加锁。</li></ol><figure><img src="/assets/20210629210758-60730d9b.png" alt="增加发布订阅流程" tabindex="0" loading="lazy"><figcaption>增加发布订阅流程</figcaption></figure><p>参考：</p><ul><li><a href="https://blog.csdn.net/Muscleheng/article/details/82906617" target="_blank" rel="noopener noreferrer">Springboot+Redis实现消息队列(发布订阅模式)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://www.jianshu.com/p/a37d455618f7" target="_blank" rel="noopener noreferrer">Springboot集成Redis实现消息队列-生产消费者<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li></ul><h4 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h4><p>以上的实现思路仅仅考虑在单机版Redis上，如果是集群版Redis需要考虑的问题还要再多一点。Redis由于他的高性能读写能力，所以在并发高的场景下使用Redis分布式锁会多一点。</p><h3 id="_16-2-如何解决-redis-的并发竞争-key-问题" tabindex="-1"><a class="header-anchor" href="#_16-2-如何解决-redis-的并发竞争-key-问题" aria-hidden="true">#</a> 16.2 如何解决 Redis 的并发竞争 Key 问题？</h3><h4 id="什么是redis-的并发竞争-key-问题" tabindex="-1"><a class="header-anchor" href="#什么是redis-的并发竞争-key-问题" aria-hidden="true">#</a> 什么是Redis 的并发竞争 Key 问题？</h4><p>Redis 的并发竞争 Key 问题：多个redis的client同时set key引起的并发问题。</p><p>由于单线程所以Redis本身并没有锁的概念，多个客户端连接并不存在竞争关系，但是利用jedis等客户端对Redis进行并发访问时会出现问题。</p><p>比如：同时有多个子系统去set一个key。这个时候要注意什么呢？</p><h4 id="场景一-库存问题" tabindex="-1"><a class="header-anchor" href="#场景一-库存问题" aria-hidden="true">#</a> 场景一：库存问题</h4><p>例如有多个请求一起去对某个商品减库存，通常操作流程是：</p><ul><li>取出当前库存值</li><li>计算新库存值</li><li>写入新库存值</li></ul><p>假设当前库存值为 20，现在有2个连接都要减 5，结果库存值应该是 10 才对，但存在下面这种情况：</p><figure><img src="/assets/20210629212028-2c11423b.png" alt="库存问题" tabindex="0" loading="lazy"><figcaption>库存问题</figcaption></figure><h4 id="场景二-顺序问题" tabindex="-1"><a class="header-anchor" href="#场景二-顺序问题" aria-hidden="true">#</a> 场景二：顺序问题</h4><p>比如有3个请求有序的修改某个key，按正常顺序的话，数据版本应该是 1-&gt;2-&gt;3，最后应该是 3。</p><p>但如果第二个请求由于网络原因迟到了，数据版本就变为了 1-&gt;3-&gt;2，最后值为 2，出问题了。</p><h4 id="解决方案一-利用消息队列" tabindex="-1"><a class="header-anchor" href="#解决方案一-利用消息队列" aria-hidden="true">#</a> 解决方案一：利用消息队列</h4><p>在并发量过大的情况下,可以通过消息中间件进行处理,把并行读写进行串行化。</p><p>把Redis.set操作放在队列中使其串行化,必须的一个一个执行。</p><p>这种方式在一些高并发的场景中算是一种通用的解决方案。</p><h4 id="解决方案二-分布式锁-时间戳" tabindex="-1"><a class="header-anchor" href="#解决方案二-分布式锁-时间戳" aria-hidden="true">#</a> 解决方案二：分布式锁+时间戳</h4><p><strong>整体技术方案</strong>：</p><p>准备一个分布式锁，大家去抢锁，抢到锁就做set操作。</p><p>加锁的目的实际上就是把并行读写改成串行读写的方式，从而来避免资源竞争。</p><p><strong>分布式锁</strong>参看上文</p><p><strong>时间戳</strong>：</p><p>要求key的操作需要顺序执行，所以需要保存一个时间戳判断set顺序。</p><blockquote ValueB:07:05=""><p>系统A key 1 {&#39;ValueA&#39;:&#39;07:00&#39;} 系统B key 1</p></blockquote><p>假设系统B先抢到锁，将key1设置为{&quot;ValueB&quot;: &#39;07:05&#39;}。接下来系统A抢到锁，发现自己的key1的时间戳早于缓存中的时间戳(&#39;07:00&#39;&lt;&#39;07:05&#39;)，那就不做set操作了。</p><h3 id="_16-3-分布式redis是前期做还是后期规模上来了再做好-为什么" tabindex="-1"><a class="header-anchor" href="#_16-3-分布式redis是前期做还是后期规模上来了再做好-为什么" aria-hidden="true">#</a> 16.3 分布式Redis是前期做还是后期规模上来了再做好？为什么？</h3><p>Redis是轻量的(单实例只使用1M内存)，为防止以后的扩容，最好的办法就是一开始就启动较多实例。即便只有一台服务器，也可以开说个实例，前期比较麻烦，但随着数据增长，牺牲是值得的。需要更多的Redis服务器时，你需要做的就是仅仅将Redis实例从一台服务迁移到另外一台服务器而已，而不用考虑重新分区的问题。</p><h3 id="_16-4-什么是-redlock" tabindex="-1"><a class="header-anchor" href="#_16-4-什么是-redlock" aria-hidden="true">#</a> 16.4 什么是 RedLock？</h3><p>参看：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/59256821" target="_blank" rel="noopener noreferrer">Redlock：Redis分布式锁最牛逼的实现<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://zhuanlan.zhihu.com/p/111354065" target="_blank" rel="noopener noreferrer">细说Redis分布式锁：setnx/redisson/redlock？了解一波？<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li></ul><h2 id="_17-集群方案" tabindex="-1"><a class="header-anchor" href="#_17-集群方案" aria-hidden="true">#</a> 17 集群方案</h2><h3 id="_17-1-redis主从复制" tabindex="-1"><a class="header-anchor" href="#_17-1-redis主从复制" aria-hidden="true">#</a> 17.1 Redis主从复制</h3><p>Redis为了解决单点数据库问题，会把数据复制多个副本部署到其他节点上，通过复制，实现Redis的高可用性，实现对数据的冗余备份，保证数据和服务的高度可靠性。</p><p>简介：</p><ul><li>主从模式里使用一个redis实例作为主机(master)，其余多个实例作为备份机(slave)；</li><li>master用来支持数据的写入和读取操作，而slave支持读取及master的数据同步；</li><li>在整个架构里，master和slave实例里的数据完全一致；</li></ul><p>流程：</p><p>①从数据库向主数据库发送sync(数据同步)命令。</p><p>②主数据库接收同步命令后，会保存快照，创建一个RDB文件。</p><p>③当主数据库执行完保持快照后，会向从数据库发送RDB文件，而从数据库会接收并载入该文件。</p><p>④主数据库将缓冲区的所有写命令发给从服务器执行。</p><p>⑤以上处理完之后，之后主数据库每执行一个写命令，都会将被执行的写命令发送给从数据库。</p><p>注意：在Redis2.8之后，主从断开重连后会根据断开之前最新的命令偏移量进行增量复制。</p><figure><img src="/assets/20210629215906-ed384595.png" alt="Redis主从复制流程" tabindex="0" loading="lazy"><figcaption>Redis主从复制流程</figcaption></figure><figure><img src="/assets/20210629215936-77a5342d.png" alt="断开重连增量同步" tabindex="0" loading="lazy"><figcaption>断开重连增量同步</figcaption></figure><p><strong>主节点故障处理方式</strong></p><p>主从模式中，每个客户端连接redis实例时都指定了ip和端口号。如果所连接的redis实例因为故障下线了，则无法通知客户端连接其他客户端地址，因此只能进行手动操作。</p><p><strong>不支持高可用</strong></p><p>显而易见，主从模式很好地解 决了数据备份的问题，但是主节点因为故障下线后，需要手动更改客户端配置重新连接，这种模式并不能保证服务的高可用。</p><p>于是redis集群迎来了哨兵模式......</p><h3 id="_17-2-哨兵-sentinal-机制" tabindex="-1"><a class="header-anchor" href="#_17-2-哨兵-sentinal-机制" aria-hidden="true">#</a> 17.2 哨兵(sentinal)机制</h3><p>哨兵的出现主要是解决了主从复制出现故障时 <strong>需要人为干预</strong> 的问题。</p><p>简介：</p><ul><li>和主从模式不一样的是，哨兵模式中 <strong>增加了独立进程(即哨兵)来监控集群中的一举一动</strong> 。客户端在连接集群时，首先连接哨兵，通过哨兵查询主节点的地址，然后再去连接主节点进行数据交互。</li><li>如果master异常，则会进行master-slave切换，将最优的一个slave切换为主节点。</li><li>同时，哨兵持续监控挂掉的主节点，待其恢复后，作为新的从节点加入集群中。</li></ul><p><strong>Redis哨兵主要功能</strong></p><p><strong>(1)集群监控</strong>：负责监控Redis master和slave进程是否正常工作</p><p><strong>(2)消息通知</strong>：如果某个Redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员</p><p><strong>(3)故障转移</strong>：如果master node挂掉了，会自动转移到slave node上</p><p><strong>(4)配置中心</strong>：如果故障转移发生了，通知client客户端新的master地址</p><p><strong>Redis哨兵的高可用</strong></p><p>原理：当主节点出现故障时，由Redis Sentinel自动完成故障发现和转移，并通知应用方，实现高可用性。</p><figure><img src="/assets/20210629215356-915de8ac.png" alt="Redis哨兵高可用" tabindex="0" loading="lazy"><figcaption>Redis哨兵高可用</figcaption></figure><p><strong>主节点故障处理方式/哨兵工作方式</strong>：</p><ol><li>哨兵机制建立了多个哨兵节点(进程)，共同监控数据节点的运行状况。</li><li>同时哨兵节点之间也互相通信，交换对主从节点的监控状况。</li><li><strong>每隔1秒每个哨兵会向整个集群</strong>：Master主服务器+Slave从服务器+其他Sentinel(哨兵)进程，发送一次ping命令做一次心跳检测。</li></ol><p><strong>主观下线和客观下线</strong></p><p>**主观下线：**一个哨兵节点判定主节点down掉是主观下线。</p><p>**客观下线：**只有半数哨兵节点都主观判定主节点down掉，此时多个哨兵节点交换主观判定结果，才会判定主节点客观下线。</p><p><strong>原理</strong>：</p><p>基本上哪个哨兵节点最先判断出这个主节点客观下线，就会在各个哨兵节点中发起投票机制Raft算法(选举算法)，最终被投为领导者的哨兵节点完成主从自动化切换的过程，客户端在master节点发生故障时会重向哨兵要地址，此时会获得最新的master节点地址。。</p><p><strong>扩容问题</strong></p><p>哨兵模式的出现虽然解决了主从模式中master节点宕机不能自主切换(即高可用)的问题。但是，随着业务的逐渐增长，不可避免需要对当前业务进行扩容。</p><p>常见的扩容方式有垂直和水平扩容两种方式：</p><ul><li><strong>垂直扩容</strong>：通过增加master内存来增加容量；</li><li><strong>水平扩容</strong>：通过增加节点来进行扩容，即在当前基础上再增加一个master节点。</li></ul><p>虽然垂直扩容方式很便捷，不需要添加多余的节点，但是机器的容量是有限的，最终还是需要通过水平扩容方式来解决。而水平扩容涉及到数据的迁移，且迁移过程中又要保证服务的可用性。因此，数据能不迁移就尽量不要迁移。</p><p>显然，哨兵模式无法满足这种情形。因此，redis cluster应运而生。</p><h3 id="_17-3-redis-cluster-模式" tabindex="-1"><a class="header-anchor" href="#_17-3-redis-cluster-模式" aria-hidden="true">#</a> 17.3 Redis cluster 模式</h3><p>简介：</p><ol><li><p>redis cluster模式采用了 <strong>无中心节点</strong> 的方式来实现，<strong>每个主节点都会与其它主节点保持连接</strong>。节点间通过gossip协议交换彼此的信息，同时每个主节点又有一个或多个从节点；</p></li><li><p>客户端连接集群时，直接与redis集群的每个主节点连接，根据hash算法取模将key存储在不同的哈希槽上；</p></li><li><p>在集群中采用数据分片的方式，将redis集群分为16384个哈希槽。如下图所示，这些哈希槽分别存储于三个主节点中：</p></li></ol><ul><li>Master1负责0~5460号哈希槽</li><li>Master2负责5461~10922号哈希槽</li><li>Master3负责10922~16383号哈希槽</li></ul><ol start="4"><li><p>每个节点会保存一份数据分布表，节点会将自己的slot信息发送给其他节点，节点间不停的传递数据分布表；</p></li><li><p>客户端连接集群时，通过集群中某个节点地址进行连接。客户端尝试向这个节点执行命令时，比如获取某个key值，如果key所在的slot刚好在该节点上，则能够直接执行成功。如果slot不在该节点，则节点会返回MOVED错误，同时把该slot对应的节点告诉客户端，客户端可以去该节点执行命令。</p></li></ol><p><strong>主节点故障处理方式</strong>：</p><p>redis cluster中主节点故障处理方式与哨兵模式较为相像，当约定时间内某节点无法与集群中的另一个节点顺利完成ping消息通信时，则将该节点标记为主观下线状态，同时将这个信息向整个集群广播。</p><p>如果一个节点收到某个节点失联的数量达到了集群的大多数时，那么将该节点标记为客观下线状态，并向集群广播下线节点的fail消息。然后立即对该故障节点进行主从切换。等到原来的主节点恢复后，会自动成为新主节点的从节点。<strong>如果主节点没有从节点，那么当它发生故障时，集群就将处于不可用状态。</strong></p><p><strong>扩容问题</strong></p><p>在哨兵模式中我们在扩容的时候遇到了问题，那么cluster中我们如何动态上线某个节点呢。当集群中加入某个节点时，哈希槽又是如何来进行分配的？当集群中加入新节点时，会与集群中的某个节点进行握手，该节点会把集群内的其它节点信息通过gossip协议发送给新节点，新节点与这些节点完成握手后加入到集群中。</p><p>然后集群中的节点会各取一部分哈希槽分配给新节点，如下图：</p><ul><li>Master1负责1365-5460</li><li>Master2负责6827-10922</li><li>Master3负责12288-16383</li><li>Master4负责0-1364,5461-6826,10923-12287</li></ul><p>当集群中要删除节点时，只需要将节点中的所有哈希槽移动到其它节点，然后再移除空白(不包含任何哈希槽)的节点就可以了。</p><p>一致性hash解决每个节点都要进行数据变更的问题：<a href="https://blog.csdn.net/wlccomeon/article/details/86553831" target="_blank" rel="noopener noreferrer">Redis分布式算法原理—Hash一致性理解<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考：</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/354314607" target="_blank" rel="noopener noreferrer">吃透这份Redis学习笔记，直接把阿里面试官按在地上摩擦！<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> (Redis常见面试题，全面)</li><li><a href="https://snailclimb.gitee.io/javaguide/#/docs/database/Redis/redis-all" target="_blank" rel="noopener noreferrer">JavaGuild-Redis面试总结<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://zhuanlan.zhihu.com/p/368770382" target="_blank" rel="noopener noreferrer">面试题系列：Redis 夺命连环11问<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://zhuanlan.zhihu.com/p/130923806" target="_blank" rel="noopener noreferrer">Redis 21问，你接得住不？<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://segmentfault.com/a/1190000019910205" target="_blank" rel="noopener noreferrer">七道常见的Redis面试题分享<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> (部分问题回答比较经典)</li><li><a href="https://zhuanlan.zhihu.com/p/118561398" target="_blank" rel="noopener noreferrer">我和面试官的博弈：Redis 篇 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://zhuanlan.zhihu.com/p/106997927" target="_blank" rel="noopener noreferrer">阿里二面：熟悉Redis？讲讲你理解的Redis的持久化机制(RDB、AOF)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> (详细介绍Redis持久化原理)</li><li><a href="https://zhuanlan.zhihu.com/p/91770135" target="_blank" rel="noopener noreferrer">如何保障mysql和redis之间的数据一致性？<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://zhuanlan.zhihu.com/p/134314240" target="_blank" rel="noopener noreferrer">吊打面试官系列：Redis 性能优化的 13 条军规大全<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> (各个角度阐述Redis内存优化，很全面)</li><li><a href="https://zhuanlan.zhihu.com/p/55068567" target="_blank" rel="noopener noreferrer">redis内存篇之内存优化<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> (对比上条，有额外的几个点值得参考)</li><li><a href="https://www.pianshen.com/article/2203950362/" target="_blank" rel="noopener noreferrer">Redis进阶-----Redis线程模型<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> (参考其线程模型过程)</li><li><a href="http://www.jackypeng.cn/archives/2019091116004462560" target="_blank" rel="noopener noreferrer">分布式缓存<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> (参考其线程模型图片，另外别的关于分布式缓存的流程图很值得参考)</li><li><a href="https://draveness.me/whys-the-design-redis-single-thread/" target="_blank" rel="noopener noreferrer">为什么 Redis 选择单线程模型<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://mp.weixin.qq.com/s/FZu3acwK6zrCBZQ_3HoUgw" target="_blank" rel="noopener noreferrer">Redis 6.0 新特性-多线程连环13问！<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://zhuanlan.zhihu.com/p/357343339" target="_blank" rel="noopener noreferrer">Redis不是一直号称单线程效率也很高吗，为什么又采用多线程了？<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://zhuanlan.zhihu.com/p/112569352" target="_blank" rel="noopener noreferrer">一文深入了解 Redis 内存模型，Redis 的快是有原因的！<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> (深入底层讲解Redis内存)</li><li><a href="https://zhuanlan.zhihu.com/p/144268090" target="_blank" rel="noopener noreferrer">高频Redis面试题解析：Redis 事务是否具备原子性？<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> (偏向原理)</li><li><a href="https://zhuanlan.zhihu.com/p/43897838" target="_blank" rel="noopener noreferrer">第三十三章：Redis事务<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> (偏向基础和操作)</li><li><a href="https://juejin.cn/post/6844903986475057165" target="_blank" rel="noopener noreferrer">《我们一起进大厂》系列-缓存雪崩、击穿、穿透<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://www.zhihu.com/question/300767410/answer/1749442787" target="_blank" rel="noopener noreferrer">怎样实现redis分布式锁？<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://zhuanlan.zhihu.com/p/52756935" target="_blank" rel="noopener noreferrer">高并发架构系列：Redis并发竞争key的解决方案详解<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://zhuanlan.zhihu.com/p/59256821" target="_blank" rel="noopener noreferrer">Redlock：Redis分布式锁最牛逼的实现<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://zhuanlan.zhihu.com/p/111354065" target="_blank" rel="noopener noreferrer">细说Redis分布式锁：setnx/redisson/redlock？了解一波？<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://blog.csdn.net/qq_36417677/article/details/104904306" target="_blank" rel="noopener noreferrer">redis集群搭建以及redis集群中添加新结点，重新分配哈希槽<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://www.cnblogs.com/crazymakercircle/p/14731826.html" target="_blank" rel="noopener noreferrer">Redis分布式锁 (图解-秒懂-史上最全)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li></ul><h1 id="redis常见的数据结构" tabindex="-1"><a class="header-anchor" href="#redis常见的数据结构" aria-hidden="true">#</a> Redis常见的数据结构</h1><h2 id="string-1" tabindex="-1"><a class="header-anchor" href="#string-1" aria-hidden="true">#</a> String</h2><h3 id="基本介绍" tabindex="-1"><a class="header-anchor" href="#基本介绍" aria-hidden="true">#</a> 基本介绍</h3><p>String是Redis最基本的类型，一个key对应一个value，<strong>一个Redis中字符串value最多可以是512M</strong>。</p><p>String类型是二进制安全的。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。</p><p>使用场景：常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。</p><h3 id="数据结构" tabindex="-1"><a class="header-anchor" href="#数据结构" aria-hidden="true">#</a> 数据结构</h3><p>String的数据结构为<strong>简单动态字符串</strong>(Simple Dynamic String，缩写SDS)。是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用<strong>预分配冗余空间的方式来减少内存的频繁分配</strong>。</p><figure><img src="/assets/202111091645431-cbc1c28e.png" alt="String数据结构" tabindex="0" loading="lazy"><figcaption>String数据结构</figcaption></figure><p>如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。</p><p>当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。</p><h3 id="编码方式" tabindex="-1"><a class="header-anchor" href="#编码方式" aria-hidden="true">#</a> 编码方式</h3><p>对于<code>string</code>类型的字符串，其底层编码方式共有三种，分别为<code>int</code>、<code>embstr</code>和<code>raw</code>。</p><ul><li><code>int</code>：当存储的字符串全是数字时，此时使用<code>int</code>方式来存储；</li><li><code>embstr</code>：当存储的字符串长度小于44个字符时，此时使用<code>embstr</code>方式来存储；</li><li><code>raw</code>：当存储的字符串长度大于44个字符时，此时使用<code>raw</code>方式来存储；</li></ul><p>使用<code>object encoding key</code>可以查看<code>key</code>对应的<code>encoding</code>类型。</p><h2 id="list-1" tabindex="-1"><a class="header-anchor" href="#list-1" aria-hidden="true">#</a> List</h2><h3 id="基本介绍-1" tabindex="-1"><a class="header-anchor" href="#基本介绍-1" aria-hidden="true">#</a> 基本介绍</h3><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部(左边)或者尾部(右边)。它是单键多值的。</p><p>它的底层实际是个<strong>双向链表</strong>，<strong>对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差</strong>。</p><figure><img src="/assets/202111091645367-229cfe0f.png" alt="image-20211109164542487" tabindex="0" loading="lazy"><figcaption>image-20211109164542487</figcaption></figure><p><strong>应用场景:</strong> 发布与订阅或者说消息队列、慢查询。</p><h3 id="数据结构-1" tabindex="-1"><a class="header-anchor" href="#数据结构-1" aria-hidden="true">#</a> 数据结构</h3><p>List的数据结构为快速链表quickList。</p><ul><li>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。</li><li>当数据量比较多的时候才会改成quicklist。因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。</li></ul><figure><img src="/assets/202111091647949-32c71a9b.png" alt="image-20211109164705085" tabindex="0" loading="lazy"><figcaption>image-20211109164705085</figcaption></figure><p>Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p><h4 id="linkedlist" tabindex="-1"><a class="header-anchor" href="#linkedlist" aria-hidden="true">#</a> linkedList</h4><p>与<code>Java</code>中的<code>LinkedList</code>类似，<code>Redis</code>中的<code>linkedList</code>是一个双向链表，也是由一个个节点组成的。<code>Redis</code>中借助<code>C</code>语言实现的链表节点结构如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>//定义链表节点的结构体 
typedf struct listNode{
    //前一个节点
    struct listNode *prev;
    //后一个节点
    struct listNode *next;
    //当前节点的值的指针
    void *value;
}listNode;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>pre</code>指向前一个节点，<code>next</code>指针指向后一个节点，<code>value</code>保存着当前节点对应的数据对象。<code>listNode</code>的示意图如下所示：</p><figure><img src="/assets/202111091749843-27f5bcd9.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>链表的结构如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>typedf struct list{
    //头指针
    listNode *head;
    //尾指针
    listNode *tail;
    //节点拷贝函数
    void *(*dup)(void *ptr);
    //释放节点函数
    void *(*free)(void *ptr);
    //判断两个节点是否相等的函数
    int (*match)(void *ptr,void *key);
    //链表长度
    unsigned long len;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>head</code>指向链表的头节点，<code>tail</code>指向链表的尾节点，<code>dup</code>函数用于链表转移复制时对节点<code>value</code>拷贝的一个实现，一般情况下使用<strong>等号</strong>足以，但在某些特殊情况下可能会用到节点转移函数，默认可以给这个函数赋值<code>NULL</code>即表示使用等号进行节点转移。<code>free</code>函数用于释放一个节点所占用的内存空间，默认赋值<code>NULL</code>的话，即使用<code>Redis</code>自带的<code>zfree</code>函数进行内存空间释放。<code>match</code>函数是用来比较两个链表节点的<code>value</code>值是否相等，相等返回1，不等返回0。<code>len</code>表示这个链表共有多少个节点，这样就可以在<code>O(1)</code>的时间复杂度内获得链表的长度。</p><p>链表的结构如下所示：</p><figure><img src="/assets/202111091750815-7874f826.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h4 id="ziplist" tabindex="-1"><a class="header-anchor" href="#ziplist" aria-hidden="true">#</a> ZipList</h4><p><code>Redis</code>的<code>zipList</code>结构如下所示：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>typedf <span class="token keyword">struct</span> <span class="token class-name">ziplist</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">{</span>
    <span class="token comment">//压缩列表占用字符数</span>
    int32 zlbytes<span class="token punctuation">;</span>
    <span class="token comment">//最后一个元素距离起始位置的偏移量，用于快速定位最后一个节点</span>
    int32 zltail_offset<span class="token punctuation">;</span>
    <span class="token comment">//元素个数</span>
    int16 zllength<span class="token punctuation">;</span>
    <span class="token comment">//元素内容</span>
    T<span class="token punctuation">[</span><span class="token punctuation">]</span> entries<span class="token punctuation">;</span>
    <span class="token comment">//结束位 0xFF</span>
    int8 zlend<span class="token punctuation">;</span>
<span class="token punctuation">}</span>ziplist
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>zipList</code>的结构如下所示：</p><figure><img src="/assets/202111091737927-f99044f0.png" alt="ziplist" tabindex="0" loading="lazy"><figcaption>ziplist</figcaption></figure><p>注意到<code>zltail_offset</code>这个参数，有了这个参数就可以快速定位到最后一个<code>entry</code>节点的位置，然后开始倒序遍历，也就是说<code>zipList</code>支持双向遍历。</p><p>下面是<code>entry</code>的结构：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>typede struct entry{
    //前一个entry的长度
    int&lt;var&gt; prelen;
    //元素类型编码
    int&lt;var&gt; encoding;
    //元素内容
    optional byte[] content;
}entry
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>prelen</code>保存的是前一个<code>entry</code>节点的长度，这样在倒序遍历时就可以通过这个参数定位到上一个<code>entry</code>的位置。<code>encoding</code>保存了<code>content</code>的编码类型。<code>content</code>则是保存的元素内容，它是<code>optional</code>类型的，表示这个字段是可选的。当<code>content</code>是很小的整数时，它会内联到<code>content</code>字段的尾部。<code>entry</code>结构的示意图如下所示：</p><figure><img src="/assets/202111091738937-0ee059a3.png" alt="entry" tabindex="0" loading="lazy"><figcaption>entry</figcaption></figure><p>好了，那现在我们思考一个问题，为什么有了<code>linkedList</code>还有设计一个<code>zipList</code>呢？就像<code>zipList</code>的名字一样，它是一个压缩列表，是为了节约内存而开发的。相比于<code>linkedList</code>，其少了<code>pre</code>和<code>next</code>两个指针。在<code>Redis</code>中，<code>pre</code>和<code>next</code>指针就要占用16个字节(64位系统的一个指针就是8个字节)。另外，<code>linkedList</code>的每个节点的内存都是单独分配，加剧内存的碎片化，影响内存的管理效率。与之相对的是，<code>zipList</code>是由连续的内存组成的，这样一来，由于内存是连续的，就减少了许多内存碎片和指针的内存占用，进而节约了内存。</p><p><code>zipList</code>遍历时，先根据<code>zlbytes</code>和<code>zltail_offset</code>定位到最后一个<code>entry</code>的位置，然后再根据最后一个<code>entry</code>里的<code>prelen</code>时确定前一个<code>entry</code>的位置。</p><p><strong>连锁更新</strong></p><p>上面说到了，<code>entry</code>中有一个<code>prelen</code>字段，它的长度要么是1个字节，要么都是5个字节：</p><ul><li>前一个节点的长度小于254个字节，则<code>prelen</code>长度为1字节；</li><li>前一个节点的长度大于254字节，则<code>prelen</code>长度为5字节；</li></ul><p>假设现在有一组压缩列表，长度都在250~253字节之间，突然新增一个<code>entry</code>节点，这个<code>entry</code>节点长度大于等于254字节。由于新的<code>entry</code>节点大于等于254字节，这个<code>entry</code>节点的<code>prelen</code>为5个字节，随后会导致其余的所有<code>entry</code>节点的<code>prelen</code>增大为5字节。</p><figure><img src="/assets/202111091740545-83e6093a.png" alt="连锁更新" tabindex="0" loading="lazy"><figcaption>连锁更新</figcaption></figure><p>同样地，删除操作也会导致出现<strong>连锁更新</strong>这种情况，假设在某一时刻，插入一个长度大于等于254个字节的<code>entry</code>节点，同时删除其后面的一个长度小于254个字节的<code>entry</code>节点，由于小于254的<code>entry</code>节点的删除，大于等于254个字节的<code>entry</code>节点将会与后面小于254个字节的<code>entry</code>节点相连，此时就与新增一个长度大于等于254个字节的<code>entry</code>节点时的情况一样，将会发生连续更新。发生连续更新时，<code>Redis</code>需要不断地对压缩列表进行<strong>内存分配工作</strong>，直到结束。</p><h4 id="quicklist" tabindex="-1"><a class="header-anchor" href="#quicklist" aria-hidden="true">#</a> quickList</h4><p>在<code>Redis</code>3.2版本之后，<code>list</code>的底层实现方式又多了一种，<code>quickList</code>。<code>qucikList</code>是由<code>zipList</code>和双向链表<code>linkedList</code>组成的混合体。它将<code>linkedList</code>按段切分，每一段使用<code>zipList</code>来紧凑存储，多个<code>zipList</code>之间使用双向指针串接起来。示意图如下所示：</p><figure><img src="/assets/202111091743491-5b69067e.png" alt="quicklist" tabindex="0" loading="lazy"><figcaption>quicklist</figcaption></figure><p>节点<code>quickListNode</code>的定义如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>typedf <span class="token keyword">struct</span> <span class="token class-name">quicklistNode</span><span class="token punctuation">{</span>
    <span class="token comment">//前一个节点</span>
    quicklistNode<span class="token operator">*</span> prev<span class="token punctuation">;</span>
    <span class="token comment">//后一个节点</span>
    quicklistNode<span class="token operator">*</span> next<span class="token punctuation">;</span>
    <span class="token comment">//压缩列表</span>
    ziplist<span class="token operator">*</span> zl<span class="token punctuation">;</span>	
    <span class="token comment">//ziplist大小</span>
    int32 size<span class="token punctuation">;</span>		
    <span class="token comment">//ziplist 中元素数量</span>
    int16 count<span class="token punctuation">;</span>
    <span class="token comment">//编码形式 存储 ziplist 还是进行 LZF 压缩储存的zipList</span>
    int2 encoding<span class="token punctuation">;</span>			
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>quickListNode
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>quickList</code>的定义如下所示：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>typedf <span class="token keyword">struct</span> <span class="token class-name">quicklist</span><span class="token punctuation">{</span>
    <span class="token comment">//指向头结点</span>
    quicklistNode<span class="token operator">*</span> head<span class="token punctuation">;</span>
    <span class="token comment">//指向尾节点</span>
    quicklistNode<span class="token operator">*</span> tail<span class="token punctuation">;</span>
    <span class="token comment">//元素总数</span>
    <span class="token keyword">long</span> count<span class="token punctuation">;</span>
    <span class="token comment">//quicklistNode节点的个数</span>
    <span class="token keyword">int</span> nodes<span class="token punctuation">;</span>	
    <span class="token comment">//压缩算法深度</span>
    <span class="token keyword">int</span> compressDepth<span class="token punctuation">;</span>		
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>quickList
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码简单地表示了<code>quickList</code>的大致结构，为了进一步节约空间，<code>Redis</code>还会对<code>zipList</code>进行压缩存储，使用<strong>LZF</strong>算法进行压缩，可以选择压缩深度。</p><h4 id="每个ziplist可以存储多少个元素" tabindex="-1"><a class="header-anchor" href="#每个ziplist可以存储多少个元素" aria-hidden="true">#</a> 每个zipList可以存储多少个元素？</h4><p>想要了解这个问题，就得打开<code>redis.conf</code>文件了。在<code>DVANCED CONFIG</code>下面有着清晰的记载。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code># Lists are also encoded in a special way to save a lot of space.
# The number of entries allowed per internal list node can be specified
# as a fixed maximum size or a maximum number of elements.
# For a fixed maximum size, use -5 through -1, meaning:
# -5: max size: 64 Kb  &lt;-- not recommended for normal workloads
# -4: max size: 32 Kb  &lt;-- not recommended
# -3: max size: 16 Kb  &lt;-- probably not recommended
# -2: max size: 8 Kb   &lt;-- good
# -1: max size: 4 Kb   &lt;-- good
# Positive numbers mean store up to _exactly_ that number of elements
# per list node.
# The highest performing option is usually -2 (8 Kb size) or -1 (4 Kb size),
# but if your use case is unique, adjust the settings as necessary.
list-max-ziplist-size -2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>quickList</code>内部默认单个<code>zipList</code>长度为<strong>8k</strong>字节，即<code>list-max-ziplist-size</code>的值设置为**-2**，超出了这个阈值，就会重新生成一个<code>zipList</code>来存储数据。根据注释可知，性能最好的时候就是就是<code>list-max-ziplist-size</code>为**-1<strong>和</strong>-2**，即分别是<strong>4kb和8kb</strong>的时候，当然，这个值也可以被设置为正数，当<code>list-max-ziplist-szie</code>为<strong>正数n</strong>时，表示每个<code>quickList</code>节点上的<code>zipList</code>最多包含<strong>n个</strong>数据项。</p><h4 id="压缩深度" tabindex="-1"><a class="header-anchor" href="#压缩深度" aria-hidden="true">#</a> 压缩深度</h4><p>上面提到过，<code>quickList</code>中可以使用压缩算法对<code>zipList</code>进行进一步的压缩，这个算法就是**<a href="https://blog.csdn.net/u012319493/article/details/83653860" target="_blank" rel="noopener noreferrer">LZF算法<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>**，这是一种无损压缩算法，具体可以参考上面的链接。使用压缩算法对<code>zipList</code>进行压缩后，<code>zipList</code>的结构如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>typedf struct ziplist_compressed{
    //元素个数
    int32 size;
    //元素内容
    byte[] compressed_data
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时<code>quickList</code>的示意图如下所示：</p><p><img src="/assets/202111091748141-2776f62b.png" alt="img" loading="lazy">]</p><p>当然，在<code>redis.conf</code>文件中的<code>DVANCED CONFIG</code>下面也可以对压缩深度进行配置。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code># Lists may also be compressed.
# Compress depth is the number of quicklist ziplist nodes from *each* side of
# the list to *exclude* from compression.  The head and tail of the list
# are always uncompressed for fast push/pop operations.  Settings are:
# 0: disable all list compression
# 1: depth 1 means &quot;don&#39;t start compressing until after 1 node into the list,
#    going from either the head or tail&quot;
#    So: [head]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[tail]
#    [head], [tail] will always be uncompressed; inner nodes will compress.
# 2: [head]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[tail]
#    2 here means: don&#39;t compress head or head-&gt;next or tail-&gt;prev or tail,
#    but compress all nodes between them.
# 3: [head]-&gt;[next]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[prev]-&gt;[tail]
# etc.
list-compress-depth 0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>list-compress-depth</code>这个参数表示**一个<code>quickList</code>两端不被压缩的节点个数。**需要注意的是，这里的节点个数是指<code>quicklist</code>双向链表的节点个数，而不是指<code>ziplist</code>里面的数据项个数。实际上，一个<code>quicklist</code>节点上的<code>ziplist</code>，如果被压缩，就是整体被压缩的。</p><ul><li><code>quickList</code>默认的压缩深度为<strong>0</strong>，也就是不开启压缩</li><li>当<code>list-compress-depth</code>为1，表示<code>quickList</code>的两端各有1个节点不进行压缩，中间结点进行压缩；</li><li>当<code>list-compress-depth</code>为2，表示<code>quickList</code>的首尾2个节点不进行压缩，中间结点进行压缩；</li><li>以此类推</li></ul><p>从上面可以看出，对于<code>quickList</code>来说，其首尾两个节点永远不会被压缩。</p><h2 id="hash-1" tabindex="-1"><a class="header-anchor" href="#hash-1" aria-hidden="true">#</a> Hash</h2><h3 id="基本介绍-2" tabindex="-1"><a class="header-anchor" href="#基本介绍-2" aria-hidden="true">#</a> 基本介绍</h3><p>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。类似Java里面的 <code>Map&lt;String,Object&gt;</code></p><p>用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储，主要如下：</p><p><strong>应用场景:</strong> 系统中对象数据的存储。</p><h3 id="数据结构-2" tabindex="-1"><a class="header-anchor" href="#数据结构-2" aria-hidden="true">#</a> 数据结构</h3><p>Hash类型对应的数据结构是两种：ziplist(压缩列表)，dict(哈希表)。当field-value长度较短且个数较少时，使用ziplist，否则使用dict。</p><h3 id="dict" tabindex="-1"><a class="header-anchor" href="#dict" aria-hidden="true">#</a> Dict</h3><p>字典<code>dict</code>作为一种常用的数据结构，<code>C</code>语言内部并不具备，因而<code>Redis</code>的开发人员自己设计和开发了<code>Redis</code>中的<code>dict</code>结构。</p><h4 id="dict-1" tabindex="-1"><a class="header-anchor" href="#dict-1" aria-hidden="true">#</a> dict</h4><p>其定义如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>typedf <span class="token keyword">struct</span> <span class="token class-name">dict</span><span class="token punctuation">{</span>
    dictType <span class="token operator">*</span>type<span class="token punctuation">;</span><span class="token comment">//类型特定函数，包括一些自定义函数，这些函数使得key和</span>
                   <span class="token comment">//value能够存储</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>private<span class="token punctuation">;</span><span class="token comment">//私有数据</span>
    dictht ht<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//两张hash表 </span>
    <span class="token keyword">int</span> rehashidx<span class="token punctuation">;</span><span class="token comment">//rehash索引，字典没有进行rehash时，此值为-1</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> iterators<span class="token punctuation">;</span> <span class="token comment">//正在迭代的迭代器数量</span>
<span class="token punctuation">}</span>dict<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>type</code>和<code>private</code>这两个属性是为了实现字典多态而设置的，当字典中存放着不同类型的值，对应的一些复制，比较函数也不一样，这两个属性配合起来可以实现多态的方法调用；</li><li><code>ht[2]</code>，两个<code>hash</code>表</li><li><code>rehashidx</code>，这是一个辅助变量，用于记录<code>rehash</code>过程的进度，以及是否正在进行<code>rehash</code>等信息，当此值为**-1**时，表示该<code>dict</code>此时没有<code>rehash</code>过程</li><li><code>iterators</code>，记录此时<code>dict</code>有几个迭代器正在进行遍历过程</li></ul><h4 id="dictht" tabindex="-1"><a class="header-anchor" href="#dictht" aria-hidden="true">#</a> <strong>dictht</strong></h4><p>由上面可以看出，<code>dict</code>本质上是对哈希表<code>dictht</code>的一个简单封装，<code>dictht</code>的定义如下所示：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>typedf <span class="token keyword">struct</span> <span class="token class-name">dictht</span><span class="token punctuation">{</span>
    dictEntry <span class="token operator">*</span><span class="token operator">*</span>table<span class="token punctuation">;</span><span class="token comment">//存储数据的数组 二维</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">;</span><span class="token comment">//数组的大小</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> sizemask<span class="token punctuation">;</span><span class="token comment">//哈希表的大小的掩码，用于计算索引值，总是等于 </span>
                           <span class="token comment">//size-1</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> used<span class="token punctuation">;</span><span class="token comment">//// 哈希表中中元素个数</span>
<span class="token punctuation">}</span>dictht<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>table</code>是一个<code>dictEntry</code>类型的数组，用于真正存储数据；<code>size</code>表示<code>table</code>这个数组的大小；<code>sizemask</code>用于计算索引位置，且总是等于<code>size-1</code>；<code>used</code>表示<code>dictht</code>中已有的节点数量，其示意图如下所示： <img src="/assets/202111091726815-437fe666.png" alt="img" loading="lazy"></p><h4 id="dictentry" tabindex="-1"><a class="header-anchor" href="#dictentry" aria-hidden="true">#</a> <strong>dictEntry</strong></h4><p>上面分析<code>dictht</code>时说到，真正存储数据的结构是<code>dictEntry</code>数组，其结构定义如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>typedf <span class="token keyword">struct</span> <span class="token class-name">dictEntry</span><span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">;</span><span class="token comment">//键</span>
    <span class="token keyword">union</span><span class="token punctuation">{</span>
        <span class="token keyword">void</span> val<span class="token punctuation">;</span>
        <span class="token class-name">unit64_t</span> u64<span class="token punctuation">;</span>
        <span class="token class-name">int64_t</span> s64<span class="token punctuation">;</span>
        <span class="token keyword">double</span> d<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>v<span class="token punctuation">;</span><span class="token comment">//值</span>
    <span class="token keyword">struct</span> <span class="token class-name">dictEntry</span> <span class="token operator">*</span>next；<span class="token comment">//指向下一个节点的指针</span>
<span class="token punctuation">}</span>dictEntry<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其示意图如下所示：</p><figure><img src="/assets/202111091727359-59144519.png" alt="image-20200831175713878" tabindex="0" loading="lazy"><figcaption>image-20200831175713878</figcaption></figure><p>最后整个<code>dict</code>的结构示意图如上所示：</p><p>上图是一个没有处于<code>rehash</code>状态下的字典<code>dict</code>，整个<code>dict</code>中有两个哈希表<code>dictht</code>，其中一个哈希表存储数据，另一个哈希表为空。</p><h4 id="扩容和缩容" tabindex="-1"><a class="header-anchor" href="#扩容和缩容" aria-hidden="true">#</a> <strong>扩容和缩容</strong></h4><p>当哈希表中元素数量逐渐增加时，此时产生<code>hash冲突</code>的概率逐渐增大，且由于<code>dict</code>也是采用<strong>拉链法</strong>解决<code>hash冲突</code>的，随着<code>hash冲突</code>概率上升，链表会越来越长，这就会导致查找效率下降。相反，当元素不断减少时，元素占用<code>dict</code>的空间就越少，出于对内存的极致利用，此时就需要进行缩容操作。</p><p>既然说到扩容和缩容，熟悉<code>Java</code>集合的小伙伴是不是想到了什么。不错，那就是<strong>负载因子</strong>。<strong>负载因子一般用于描述集合当前被填充的程度</strong>。在<code>Redis</code>的字典<code>dict</code>中，<strong>负责因子=哈希表中已保存节点数量/哈希表的大小</strong>，即：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>load factor = ht[0].used / ht[0].size
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>Redis</code>中，三条关于扩容和缩容的规则：</p><ul><li>没有执行BGSAVE和BGREWRITEAOF指令的情况下，哈希表的负载因子大于等于1时进行扩容；</li><li>正在执行BGSAVE和BGREWRITEAOF指令的情况下，哈希表的负载因大于等于5时进行扩容；</li><li>负载因子小于0.1时，<code>Redis</code>自动开始对哈希表进行收缩操作；</li></ul><p>其中，扩容和缩容的数量大小也有一定的规则：</p><ul><li>扩容：<strong>扩容后的<code>dictEntry</code>数组数量为第一个大于等于<code>ht[0].used*2</code>的<code>2^n</code></strong>；</li><li>缩容：<strong>缩容后的<code>dictEntry</code>数组数量为第一个大于等于<code>ht[0].used</code>的<code>2^n</code></strong>；</li></ul><h2 id="set-1" tabindex="-1"><a class="header-anchor" href="#set-1" aria-hidden="true">#</a> Set</h2><h3 id="基本介绍-3" tabindex="-1"><a class="header-anchor" href="#基本介绍-3" aria-hidden="true">#</a> 基本介绍</h3><p>Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以<strong>自动排重</strong>的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</p><p>Redis的Set是string类型的无序集合。它 <strong>底层其实是一个value为null的hash表</strong> ，所以添加，删除，查找的 <strong>复杂度都是O(1)</strong>。</p><p>使用场景：可以基于 set 轻易实现<strong>交集、并集、差集</strong>的操作。比如：你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。</p><h3 id="数据结构-3" tabindex="-1"><a class="header-anchor" href="#数据结构-3" aria-hidden="true">#</a> 数据结构</h3><p>Set数据结构是dict字典，字典是用哈希表实现的。</p><p>Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。</p><h2 id="zset" tabindex="-1"><a class="header-anchor" href="#zset" aria-hidden="true">#</a> ZSet</h2><h3 id="基本介绍-4" tabindex="-1"><a class="header-anchor" href="#基本介绍-4" aria-hidden="true">#</a> 基本介绍</h3><p>Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。不同之处是有序集合的每个成员都关联了一个<strong>评分</strong>(score),这个评分(score)被用来按照从最低分到最高分的方式排序集合中的成员。<strong>集合的成员是唯一的，但是评分可以是重复的</strong> 。</p><p>因为元素是有序的，所以你也可以很快的根据评分(score)或者次序(position)来获取一个范围的元素。</p><p>访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。</p><p><strong>应用场景：</strong> 需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息(可以理解为按消息维度的消息排行榜)等信息。</p><h3 id="数据结构-4" tabindex="-1"><a class="header-anchor" href="#数据结构-4" aria-hidden="true">#</a> 数据结构</h3><p>SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构 <code>Map&lt;String, Double&gt;</code>，可以给每一个元素value赋予一个权重score，另一方面它又类似于<code>TreeSet</code>，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。</p><p>zset底层使用了两个数据结构：</p><ol><li><p>hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。</p></li><li><p>跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。</p></li></ol><p>zset也有两种不同的实现，分别是<code>zipList</code>和<code>skipList</code>：</p><ul><li>zipList：满足以下两个条件 <ul><li><code>[score,value]</code>键值对数量少于128个；</li><li>每个元素的长度小于64字节；</li></ul></li><li>skipList：不满足以上两个条件时使用跳表、组合了hash和skipList <ul><li><code>hash</code>用来存储<code>value</code>到<code>score</code>的映射，这样就可以在<code>O(1)</code>时间内找到<code>value</code>对应的分数；</li><li><code>skipList</code>按照<strong>从小到大</strong>的顺序存储分数</li><li><code>skipList</code>每个元素的值都是<code>[socre,value]</code>对</li></ul></li></ul><h3 id="跳跃表" tabindex="-1"><a class="header-anchor" href="#跳跃表" aria-hidden="true">#</a> 跳跃表</h3><p>有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。</p><p>Redis采用的是跳跃表。跳表可以保证增、删、查等操作时的时间复杂度为<code>O(logN)</code>，这个性能可以与平衡树相媲美，但实现方式上却更加简单，唯一美中不足的就是跳表占用的空间比较大，其实就是一种<strong>空间换时间</strong>的思想。</p><p>实例：对比有序链表和跳跃表，从链表中查询出51</p><p>(1) 有序链表：</p><figure><img src="/assets/202111091711455-e9a0a0aa.png" alt="image-20211109171136112" tabindex="0" loading="lazy"><figcaption>image-20211109171136112</figcaption></figure><p>要查找值为51的元素，需要从第一个元素开始依次查找、比较才能找到。共需要6次比较。</p><p>(2) 跳跃表</p><figure><img src="/assets/202111091712526-807d373b.png" alt="image-20211109171219713" tabindex="0" loading="lazy"><figcaption>image-20211109171219713</figcaption></figure><ul><li>从第2层开始，1节点比51节点小，向后比较。</li><li>21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层</li><li>在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下</li><li>在第0层，51节点为要查找的节点，节点被找到，共查找4次。</li></ul><p>从此可以看出跳跃表比有序链表效率要高。</p><h2 id="bitmaps" tabindex="-1"><a class="header-anchor" href="#bitmaps" aria-hidden="true">#</a> Bitmaps</h2><h3 id="基本介绍-5" tabindex="-1"><a class="header-anchor" href="#基本介绍-5" aria-hidden="true">#</a> 基本介绍</h3><p>现代计算机用二进制(位) 作为信息的基础单位， 1个字节等于8位， 例如“abc”字符串是由3个字节组成， 但实际在计算机存储时将其用二进制表示， “abc”分别对应的ASCII码分别是97、 98、 99， 对应的二进制分别是01100001、 01100010和01100011，如下图</p><figure><img src="/assets/202111111002687-8857c33b.png" alt="image-20211111100250796" tabindex="0" loading="lazy"><figcaption>image-20211111100250796</figcaption></figure><p>合理地使用操作位能够有效地提高内存使用率和开发效率。</p><p>Redis提供了Bitmaps这个“数据类型”可以实现对位的操作：</p><p>(1) Bitmaps本身不是一种数据类型， 实际上它就是字符串(key-value) ， 但是它可以对字符串的位进行操作。</p><p>(2) Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做偏移量。</p><figure><img src="/assets/202111111003757-5e84d813.png" alt="image-20211111100301872" tabindex="0" loading="lazy"><figcaption>image-20211111100301872</figcaption></figure><h3 id="相关命令" tabindex="-1"><a class="header-anchor" href="#相关命令" aria-hidden="true">#</a> 相关命令</h3><h4 id="_1、setbit" tabindex="-1"><a class="header-anchor" href="#_1、setbit" aria-hidden="true">#</a> 1、setbit</h4><p>设置Bitmaps中某个偏移量的值(0或1)(offset:偏移量从0开始)</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>setbit<span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>offset<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>每个独立用户是否访问过网站存放在Bitmaps中， 将访问的用户记做1， 没有访问的用户记做0， 用偏移量作为用户的id。</p><p>设置键的第offset个位的值(从0算起) ， 假设现在有20个用户，userid=1， 6， 11， 15， 19的用户对网站进行了访问， 那么当前Bitmaps初始化结果如图:</p><figure><img src="/assets/202111111005756-8ba9f1d0.png" alt="image-20211111100540833" tabindex="0" loading="lazy"><figcaption>image-20211111100540833</figcaption></figure><p>unique:users:20201106代表2020-11-06这天的独立访问用户的Bitmaps.</p><figure><img src="/assets/202111111006438-23f1074e.png" alt="image-20211111100601628" tabindex="0" loading="lazy"><figcaption>image-20211111100601628</figcaption></figure><blockquote><p>很多应用的用户id以一个指定数字(例如10000) 开头， 直接将用户id和Bitmaps的偏移量对应势必会造成一定的浪费， 通常的做法是每次做setbit操作时将用户id减去这个指定数字。</p><p>在第一次初始化Bitmaps时， 假如偏移量非常大， 那么整个初始化过程执行会比较慢， 可能会造成Redis的阻塞。</p></blockquote><h4 id="_2、getbit" tabindex="-1"><a class="header-anchor" href="#_2、getbit" aria-hidden="true">#</a> 2、getbit</h4><p>获取Bitmaps中某个偏移量的值(偏移量不存在，也是返回0)</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>getbit<span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>offset<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="_3、bitcount" tabindex="-1"><a class="header-anchor" href="#_3、bitcount" aria-hidden="true">#</a> 3、bitcount</h4><p>统计<strong>字符串</strong>被设置为1的bit数。</p><p>一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。start 和 end 参数的设置，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，start、end 是指bit组的字节的下标数，二者皆包含。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 统计字符串从start字节到end字节比特值为1的数量</span>
bitcount<span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token punctuation">[</span>start end<span class="token punctuation">]</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_4、bitop" tabindex="-1"><a class="header-anchor" href="#_4、bitop" aria-hidden="true">#</a> 4、bitop</h4><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>bitop and<span class="token punctuation">(</span>or/not/xor<span class="token punctuation">)</span> <span class="token operator">&lt;</span>destkey<span class="token operator">&gt;</span> <span class="token punctuation">[</span>key…<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>bitop是一个复合操作， 它可以做多个Bitmaps的and(交集) 、 or(并集) 、 not(非) 、 xor(异或) 操作并将结果保存在destkey中。</p><p>实例：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 2020-11-04 日访问网站的userid=1,2,5,9。</span>
setbit unique:users:20201104 <span class="token number">1</span> <span class="token number">1</span>
setbit unique:users:20201104 <span class="token number">2</span> <span class="token number">1</span>
setbit unique:users:20201104 <span class="token number">5</span> <span class="token number">1</span>
setbit unique:users:20201104 <span class="token number">9</span> <span class="token number">1</span>

<span class="token comment">#2020-11-03 日访问网站的userid=0,1,4,9。</span>
setbit unique:users:20201103 <span class="token number">0</span> <span class="token number">1</span>
setbit unique:users:20201103 <span class="token number">1</span> <span class="token number">1</span>
setbit unique:users:20201103 <span class="token number">4</span> <span class="token number">1</span>
setbit unique:users:20201103 <span class="token number">9</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>计算出两天都访问过网站的用户数量:<code>bitop and unique:users:20201103 unique:users:20201104</code></p><p>计算出任意一天都访问过网站的用户数量(例如月活跃就是类似这种) ， 可以使用or求并集：<code>bitop or unique:users:20201103 unique:users:20201104</code></p><h3 id="bitmaps与set对比" tabindex="-1"><a class="header-anchor" href="#bitmaps与set对比" aria-hidden="true">#</a> Bitmaps与set对比</h3><p>假设网站有1亿用户， 每天独立访问的用户有5千万， 如果每天用集合类型和Bitmaps分别存储活跃用户可以得到表：</p><figure><img src="/assets/202111111015921-66264340.png" alt="image-20211111101502391" tabindex="0" loading="lazy"><figcaption>image-20211111101502391</figcaption></figure><figure><img src="/assets/202111111015690-3dfc7093.png" alt="image-20211111101542846" tabindex="0" loading="lazy"><figcaption>image-20211111101542846</figcaption></figure><p>很明显， 这种情况下使用Bitmaps能节省很多的内存空间， 尤其是随着时间推移节省的内存还是非常可观的。</p><p>但Bitmaps并不是万金油， 假如该网站每天的独立访问用户很少， 例如只有10万(大量的僵尸用户) ， 那么两者的对比如下表所示， 很显然， 这时候使用Bitmaps就不太合适了， 因为基本上大部分位都是0。</p><figure><img src="/assets/202111111016925-b655547b.png" alt="image-20211111101625476" tabindex="0" loading="lazy"><figcaption>image-20211111101625476</figcaption></figure><h2 id="hyperloglog" tabindex="-1"><a class="header-anchor" href="#hyperloglog" aria-hidden="true">#</a> HyperLogLog</h2><h3 id="基本介绍-6" tabindex="-1"><a class="header-anchor" href="#基本介绍-6" aria-hidden="true">#</a> 基本介绍</h3><p>在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站PV(PageView页面访问量),可以使用Redis的incr、incrby轻松实现。</p><p>但像UV(UniqueVisitor，独立访客)、独立IP数、搜索记录数等需要去重和计数的问题如何解决？这种 <strong>求集合中不重复元素个数</strong> 的问题称为 <strong>基数</strong> 问题。解决基数问题有很多种方案：</p><p>(1)数据存储在MySQL表中，使用distinct count计算不重复个数</p><p>(2)使用Redis提供的hash、set、bitmaps等数据结构来处理</p><p>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。</p><p>**能否能够降低一定的精度来平衡存储空间？**Redis推出了HyperLogLog</p><p>Redis HyperLogLog 是用来做基数统计的算法，<strong>HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</strong></p><p>在 Redis 里面，<strong>每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数</strong>。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p><p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p><p><strong>什么是基数?</strong></p><p>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p><h3 id="相关命令-1" tabindex="-1"><a class="header-anchor" href="#相关命令-1" aria-hidden="true">#</a> 相关命令</h3><h4 id="_1、pfadd" tabindex="-1"><a class="header-anchor" href="#_1、pfadd" aria-hidden="true">#</a> 1、pfadd</h4><p>添加指定元素到 HyperLogLog 中</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>pfadd <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span> element<span class="token operator">&gt;</span> <span class="token punctuation">[</span>element <span class="token punctuation">..</span>.<span class="token punctuation">]</span>   
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>将所有元素添加到指定HyperLogLog数据结构中。如果执行命令后HLL估计的近似基数发生变化，则返回1，否则返回0。</p><figure><img src="/assets/202111111021159-c59786b6.png" alt="image-20211111102059470" tabindex="0" loading="lazy"><figcaption>image-20211111102059470</figcaption></figure><h4 id="_2、pfcount" tabindex="-1"><a class="header-anchor" href="#_2、pfcount" aria-hidden="true">#</a> 2、pfcount</h4><p><strong>计算HLL的近似基数</strong>，可以计算多个HLL，比如用HLL存储每天的UV，计算一周的UV可以使用7天的UV合并计算即可</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>pfcount<span class="token operator">&lt;</span>key<span class="token operator">&gt;</span> <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="_3、pfmerge" tabindex="-1"><a class="header-anchor" href="#_3、pfmerge" aria-hidden="true">#</a> 3、pfmerge</h4><p>将一个或多个HLL合并后的结果存储在另一个HLL中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>pfmerge<span class="token operator">&lt;</span>destkey<span class="token operator">&gt;</span><span class="token operator">&lt;</span>sourcekey<span class="token operator">&gt;</span> <span class="token punctuation">[</span>sourcekey <span class="token punctuation">..</span>.<span class="token punctuation">]</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="geospatial" tabindex="-1"><a class="header-anchor" href="#geospatial" aria-hidden="true">#</a> Geospatial</h2><h3 id="基本介绍-7" tabindex="-1"><a class="header-anchor" href="#基本介绍-7" aria-hidden="true">#</a> 基本介绍</h3><p>Redis 3.2 中增加了对GEO类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。</p><h3 id="相关命令-2" tabindex="-1"><a class="header-anchor" href="#相关命令-2" aria-hidden="true">#</a> 相关命令</h3><table><thead><tr><th style="text-align:left;">命令</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:left;"><a href="https://www.redis.net.cn/order/3687.html" target="_blank" rel="noopener noreferrer">Redis GEOHASH 命令<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></td><td style="text-align:left;">返回一个或多个位置元素的 Geohash 表示</td></tr><tr><td style="text-align:left;"><a href="https://www.redis.net.cn/order/3688.html" target="_blank" rel="noopener noreferrer">Redis GEOPOS 命令<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></td><td style="text-align:left;">从key里返回所有给定位置元素的位置(经度和纬度)</td></tr><tr><td style="text-align:left;"><a href="https://www.redis.net.cn/order/3686.html" target="_blank" rel="noopener noreferrer">Redis GEODIST 命令<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></td><td style="text-align:left;">返回两个给定位置之间的距离</td></tr><tr><td style="text-align:left;"><a href="https://www.redis.net.cn/order/3689.html" target="_blank" rel="noopener noreferrer">Redis GEORADIUS 命令<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></td><td style="text-align:left;">以给定的经纬度为中心， 找出某一半径内的元素</td></tr><tr><td style="text-align:left;"><a href="https://www.redis.net.cn/order/3685.html" target="_blank" rel="noopener noreferrer">Redis GEOADD 命令<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></td><td style="text-align:left;">将指定的地理空间位置(纬度、经度、名称)添加到指定的key中</td></tr><tr><td style="text-align:left;"><a href="https://www.redis.net.cn/order/3690.html" target="_blank" rel="noopener noreferrer">Redis GEORADIUSBYMEMBER 命令<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></td><td style="text-align:left;">找出位于指定范围内的元素，中心点是由给定的位置元素决定</td></tr></tbody></table><h2 id="参看" tabindex="-1"><a class="header-anchor" href="#参看" aria-hidden="true">#</a> 参看：</h2><ul><li><a href="https://www.bilibili.com/video/BV1Rv41177Af?p=4" target="_blank" rel="noopener noreferrer">【尚硅谷】Redis 6 入门到精通 超详细 教程<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://www.cnblogs.com/reecelin/p/13358432.html" target="_blank" rel="noopener noreferrer">Redis底层数据结构之List<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://www.cnblogs.com/reecelin/p/13362104.html" target="_blank" rel="noopener noreferrer">Redis底层数据结构之hash<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://www.cnblogs.com/reecelin/p/13352694.html" target="_blank" rel="noopener noreferrer">Redis底层数据结构之string<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://www.cnblogs.com/reecelin/p/13364089.html" target="_blank" rel="noopener noreferrer">Redis底层数据结构之set<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://www.cnblogs.com/reecelin/p/13368374.html" target="_blank" rel="noopener noreferrer">Redis底层数据结构之 zset<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li></ul></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/vuepress-theme-hope/vuepress-theme-hope/edit/main/docs/en/distributed/cache/redis.md" rel="noopener noreferrer" target="_blank" aria-label="Edit this page on GitHub" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->Edit this page on GitHub<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><!----><!----></div></footer><!----><div class="giscus-wrapper input-top" id="comment" style="display:block;"><div class="loading-icon-wrapper" style="display:flex;align-items:center;justify-content:center;height:96px"><svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" preserveAspectRatio="xMidYMid" viewBox="25 25 50 50"><animateTransform attributeName="transform" type="rotate" dur="2s" keyTimes="0;1" repeatCount="indefinite" values="0;360"></animateTransform><circle cx="50" cy="50" r="20" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round"><animate attributeName="stroke-dasharray" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="1,200;90,200;1,200"></animate><animate attributeName="stroke-dashoffset" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="0;-35px;-125px"></animate></circle></svg></div></div><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer">Default footer</div><div class="copyright">Copyright © 2023 Mr.IIIDelay</div></footer></div><!--]--><!----><!----><!--]--></div>
    <script type="module" src="/assets/app-50a824e8.js" defer></script>
  </body>
</html>
